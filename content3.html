<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="description" content="Shell variables">
	<meta name="keywords" content="bash, tutorial">
	<meta name="author" content="Monica Keith">
	
	<link rel="stylesheet" type="text/css" href="styles.css">
</head>
	
    <body>
            <h2>3. Variables</h2>
		    	<h3>3.1. Utility, declaration and accessing variables</h3>
		    		<p>
						A very important aspect of programming (in bash or any other language) is the ability to use a label (called 
						variable) to indicate some other quantity (a number, character, string or command). For example, I can use 
						the variable <font class="bashcommand">${desktop}</font> to represent the string 
						<font class="bashcommand">"/Users/monica/Desktop"</font>. Or the variable 
						<font class="bashcommand">${year}</font> to represent the number <font class="bashcommand">2020</font> 
						(after correctly declaring these variables). Variables can be used for many purposes, including making the 
						code more readable, short and organized and to prevent typing errors. They are also very useful in cases in 
						which the actual value of a variable is not known before executing the program, or when you need to save the 
						output of one command to use as input for another command. For example, when reading the contents of a file 
						you can read line by line in an iterative manner (which you will learn later), saving each line in a variable 
						and then doing something with it (depending the purpose of the program). 
					</p>
					
					<p>
						The easy thing about declaring variables in bash is that you don't have to specify data types. However, if 
						the value that you are assigning is a string of characters, you should use quotation marks 
						(<font class="bashcommand">"</font>) between the beginning and the end of your string (especially if the 
						string contains spaces). You must also be careful to not include any white space between the variable name, 
						the equals sign, and the value. Additionally, be aware that the quotation marks used in bash are 
						<font class="bashcommand">"</font>, which is different than those used in Microsoft Word. They look very 
						similar, but bash won't recognize the later ones. So, if you copy-paste from Microsoft Word a command that
						includes quotation marks, you will probably get an error.
					</p>
					
					<p>
						<font class="example">Declaring variables of different data types</font>
						In the following commands, I will assign a number to the variable <font class="bashcommand">YEAR</font>, a String 
						to the variables <font class="bashcommand">MONTH</font> and <font class="bashcommand">NAME</font> and a character to 
						the variable <font class="bashcommand">GENDER</font>. As you can observe, numbers, strings and characters should 
						be declared in a different manner.
					</p>
					
					<p>
						<font class="bashcommand">
						$ YEAR=2018<br>
						$ MONTH="August"<br>
						$ NAME="Monica Keith"<br>
						$ GENDER='F'
						</font>
					</p>
					
					<p>
						<font class="example">Common mistakes when declaring variables</font>
						The following commands will produce errors because there is a white space before and/or after the equal sign 
						(<font class="bashcommand">=</font>), or because the quotation marks (<font class="bashcommand">"</font>) are 
						missing when declaring a string that contains a space. Bellow each erroneous command you can see the error 
						that Bash produces.
					</p>
					
					<p>
						<font class="bashcommand">
						$ NAME ="Monica Keith"<br>
						<font class="bashcommand-result">-bash: NAME: command not found</font><br>
						$ NAME= "Monica Keith"<br>
						<font class="bashcommand-result">-bash: Monica Keith: command not found</font><br>
						$ NAME = "Monica Keith"<br>
						<font class="bashcommand-result">-bash: NAME: command not found</font><br>
						$ NAME=Monica Keith<br>
						<font class="bashcommand-result">-bash: Keith: command not found</font>
						</font>
					</p>
					
					<p>
						Once you assign a value to a variable, you can reference it with a dollar sign, located immediately before 
						the variable name. You can also reference a variable by including curly brackets 
						(<font class="bashcommand">{}</font>) at the beginning and the end of the variable name. It is better (but 
						not mandatory) to always reference variables using brackets. This will prevent errors in your code (specially 
						when referencing strings that have spaces or special characters).
					</p>
					
					<p>
						<font class="example">Referencing variables</font>
						In the following example, I will declare variable <font class="bashcommand">VAR1</font> with value 
						<font class="bashcommand">2</font>, and variable <font class="bashcommand">VAR2</font> with value 
						<font class="bashcommand">"Subject"</font>. Then, I will use the function 
						<font class="bashcommand">echo</font> to print in the command line the value of the two variables.
					</p>
					
					<p>
						<font class="bashcommand">
						$ VAR1=2<br>
						$ VAR2="Subject"<br>
						$ echo ${VAR1}<br>
						<font class="bashcommand-result">2</font><br>
						$ echo ${VAR2}<br>
						<font class="bashcommand-result">Subject</font>
						</font>
					</p>
					
					<p>
						<font class="example">Common mistakes when referencing variables</font>
						When referencing a variable, be careful not to include any space before or after the brackets. The following 
						examples will produce an error because of the inclusion of a space around the brackets:
					</p>
					
					<p>
						<font class="bashcommand">
						$ echo ${ VAR2}<br>
						<font class="bashcommand-result">-bash: ${ VAR2}: bad substitution</font><br>
						$ echo ${VAR2 }<br>
						<font class="bashcommand-result">-bash: ${VAR2 }: bad substitution</font><br>
						$ echo ${ VAR2 }<br>
						<font class="bashcommand-result">-bash: ${ VAR2 }: bad substitution</font>
						</font>
					</p>
					
					<p>
						The following erroneous reference (with a space between the dollar sign and the first bracket) will not cause 
						an error but will not substitute <font class="bashcommand">${VAR2}</font> for the correct value. It will just 
						print <font class="bashcommand">$ {VAR2}</font> instead of <font class="bashcommand">Subject</font>.
					</p>
					
					<p>
						<font class="bashcommand">
						$ echo $ {VAR2}<br>
						$ {VAR2}
						</font>
					</p>
					
					<p>
						<font class="example">Concatenating variables</font>
						You can concatenate different variables and characters to form new strings. To do this, you will need to 
						reference the variables using the curly brackets and use quotation marks at the beginning and the end of your 
						final string. For example, if you want to use the previously declared variables 
						<font class="bashcommand">VAR1</font> and <font class="bashcommand">VAR2</font> to generate the String 
						<font class="bashcommand">Subject_02</font>, you can concatenate them the following way:
					</p>
					
					<p>
						<font class="bashcommand">
						$ echo ${VAR2}<br>
						<font class="bashcommand-result">Subject</font><br>
						$ echo ${VAR1}<br>
						<font class="bashcommand-result">2</font><br>
						$ echo "${VAR2}_0${VAR1}"<br>
						<font class="bashcommand-result">Subject_02</font>
						</font>
					</p>
					
					<p>Here are a few more examples on how to declare and concatenate variables:</p>
					
					<p>
						<font class="bashcommand">
						$ ID="Subject_202"<br>
						$ VOLUME=20<br>
						$ MEASURE="mm"<br>
						$ echo "${ID}: ${VOLUME}${MEASURE}"<br>
						<font class="bashcommand-result">Subject_202: 20mm</font>
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
						$ VAR1="MacOS"<br>
						$ VAR2="Linux"<br>
						$ VAR3="Windows"<br>
						$ echo "(${VAR1},${VAR2},${VAR3})"<br>
						<font class="bashcommand-result">(MacOS,Linux,Windows)</font>
						</font>
					</p>
					
					<p>
						<font class="example">A common mistake when concatenating variables</font>
						It is very common when you are referencing many variables or concatenating variables to create a long string 
						to forget the closing quotation mark. For example, writing<br>
						<font class="bashcommand">$ echo "(${VAR1},${VAR2},${VAR3})</font><br>
						instead of<br>
						<font class="bashcommand">$ echo "(${VAR1},${VAR2},${VAR3})"</font>
					</p>
					
					<p>
						When that happens and you click enter in the keyboard, the command line won't allow you to enter any more 
						commands. You will see the symbol <font class="bashcommand">></font> and if you continue pressing enter it 
						will do nothing. This is because the command line is waiting for you to close the open String. To close the 
						string just add the missing quotation mark or cancel and ignore what you have written so far in the current 
						line by pressing CTR+C. 
					</p>
					
				<h3>3.2. Rules for assigning variable names</h3>
					<p>You can assign any value to a variable. However, a variable cannot have just any name. There are a few 
					rules for assigning variable names.</p>
					
					<ol>
						<li>
							A variable name should not be a number.<br>
							This type of variable is only used to read arguments on a shell script. For example, 
							<font class="bashcommand">$1</font> refers to the first argument of a script, 
							<font class="bashcommand">$2</font> to the second argument, etc. Later you will learn the meaning and use 
							of script arguments.
						</li><br>
						
						<li>
							Variable names must start with an alphabetical letter or an underscore.<br>
							Variable names can contain any number, but it should not be located at the beginning.
						</li><br>
						
						<li>
							Do not use <font class="bashcommand">$</font> or <font class="bashcommand">${}</font> to declare a 
							variable. These characters are used only to reference variables (not to declare).
						</li><br>
						
						<li>
							Do <u>NOT</u> assign the name <font class="bashcommand">PATH</font> to any variable.<br>
							If you do so, you won't get any error right away. But it will mess up the execution of other programs. 
							<font class="bashcommand">PATH</font> is a system variable that specifies a set of directories where 
							executable programs are located. For example, when you install a software that runs in the command line 
							(i.e. FSL), the path to the executable of that program will be included in the system variable 
							<font class="bashcommand">PATH</font>. So, if you rename that variable, you won't be able to execute the 
							program again in the current terminal. If you forget about this rule and mistakenly re-write the value 
							of this variable, close the current terminal and open a new one. Every time you open a new terminal, 
							this system variable will be re-set to the correct value (which is stored in the bash_profile, we will 
							talk about this file in a later chapter). At any moment you can know the value of your 
							<font class="bashcommand">PATH</font> by typing <font class="bashcommand">echo ${PATH}</font>. You will 
							see something like this (although this will significantly varies between one computer and the other 
							depending which programs you have installed and referenced in the bash_profile):<br><br>
							
							<font class="bashcommand">
							$ echo ${PATH}<br>
							<font class="bashcommand-result">/usr/local/fsl/bin:/Applications/freesurfer/bin:/Applications/freesurfer/fsfast/bin:/Applications/freesurfer/tktools:/usr/local/fsl/bin:/Applications/freesurfer/mni/bin:/Users/bunbury/bin:/Applications/MATLAB_R2018a.app/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin</font>
							</font><br><br>
							
							Another Unix reserved name that you should not use is <font class="bashcommand">BASH</font>. There is a long list 
							of Unix reserved words that I will not include here but you will learn as you get more experienced.
						</li><br>
						
						<li>
							Avoid using the following reserved characters from appearing in variable names:
							<font class="bashcommand">/ &gt; &lt; | : &amp; . *</font>	
						</li><br><br>
						
						<font class="example">Some valid and invalid variable names</font><br>
						<table>
							<caption>Valid and invalid variable names</caption>
							<tr>
								<th style="width:50%"><b>Valid variable names</b></th>
								<th style="width:50%"><b>Invalid variable names</b></th>
							</tr>
							<tr>
								<td>V</td>
								<td>1</td>
							</tr>
							<tr>
								<td>VAR</td>
								<td>1VAR</td>
							</tr>
							<tr>
								<td>VAR1</td>
								<td>2_VAR</td>
							</tr>
							<tr>
								<td>VAR_1</td>
								<td>.VAR</td>
							</tr>
							<tr>
								<td>_VAR1</td>
								<td>$VAR</td>
							</tr>
							<tr>
								<td>_1VAR</td>
								<td>${VAR}</td>
							</tr>
							<tr>
								<td>VARIABLE_NAME</td>
								<td>{VAR}</td>
							</tr>
							<tr>
								<td>PATH1</td>
								<td>PATH</td>
							</tr>
							<tr>
								<td>BASH1</td>
								<td>BASH</td>
							</tr>
						</table>
						
						<p>
							Variable names can be in lower and/or upper case. However, they are case sensitive. If you declare a 
							variable as <font class="bashcommand">VAR1</font>, but you reference it as 
							<font class="bashcommand">${var1}</font>, bash will not recognize the value. You must reference it as 
							<font class="bashcommand">${VAR1}</font>.
						</p>
					</ol>
					
				<h3>3.3. Reading user input into a variable</h3>
					<p>
						The command <font class="bashcommand">read</font> is the counterpart of <font class="bashcommand">echo</font>. 
						Instead of printing things in the terminal the way <font class="bashcommand">echo</font> does, 
						<font class="bashcommand">read</font> reads input from the user and saves it in the specified variable (in 
						this case <font class="bashcommand">VAR</font>). The word read is followed by the name of the variable where 
						you want to save the information. In the following example, I am going to read the input from the user and 
						save it in the variable <font class="bashcommand">VAR</font>. Generally, Bash will read everything that is 
						written until the user presses the Enter key and save all the information in the corresponding variable.
					</p>
					
					<p>
						<font class="example">Saving user input into a new variable</font>
						<font class="bashcommand">
						$ echo "Username:"<br>
						<font class="bashcommand-result">Username:</font><br>
						$ read VAR<br>
						<font class="bashcommand-result">Noemi</font><br>
						$ echo "You typed: ${VAR}"<br>
						<font class="bashcommand-result">You typed: Noemi</font>
						</font>
					</p>
					
					<p>
						There are some flags (options) that can be added to the command read to change the way in which information is 
						displayed or captured:
					</p>
					
					<table>
						<caption>Options for reading user input</caption>
						<tr>
							<th style="width:30%"><b>Flag</b></th>
							<th style="width:70%"><b>Usage</b></th>
						</tr>
						<tr>
							<td><font class="bashcommand">-s</font></td>
							<td>
							Silent mode. The characters that the user inputs are not displayed (used specially when asking the user to 
							input a password).
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-p "MESSAGE"</font></td>
							<td>
								Displays the <font class="bashcommand">MESSAGE</font> where the user must write the input.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-n NUM_CHARS</font></td>
							<td>
							The input line ends after reading <font class="bashcommand">NUM_CHARS</font> characters, rather than waiting for the 
							user to press Enter in the keyboard.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-d 'CHAR_NEW_LINE'</font></td>
							<td>
							<font class="bashcommand">CHAR_NEW_LINE</font> is used to determine the end of the input line (if different than Enter).
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-r</font></td>
							<td>
								Backslash does not act as an escape character but instead is part of the line.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-t NSECONDS</font></td>
							<td>
							Bash will stop reading the user input after <font class="bashcommand">NSECONDS</font>. Whatever was entered in that 
							time is captured as the input line.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-a ARRAY_NAME</font></td>
							<td>
							The words that the user inputs are assigned to sequential indices of the array 
							<font class="bashcommand">ARRAY_NAME</font>. The array is emptied before assigning the values if it 
							already exists.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-u FILEDESCRIPTOR</font></td>
							<td>
							Read input from <font class="bashcommand">FILEDESCRIPTOR</font>.
							</td>
						</tr>
					</table>
					
					<p>
						The following examples will show how to use the flags mentioned in the previous table. Be aware on how the 
						variable name is always written at the end of the command. In this section, I will not explain the use of 
						flags <font class="bashcommand">-a</font> and <font class="bashcommand">-u</font> because we haven't learned 
						yet about arrays or file manipulation. Some of the examples will also show common mistakes that will make bash 
						show an error.
					</p>
					
					<p>
						<font class="example">read -s</font>
						In the following example, the flag <font class="bashcommand">-s</font> causes the user input to be silenced, 
						so when the user writes the password, it is not shown in the screen. If the user input is 
						<font class="bashcommand">ThisIsMyPassword</font>, then that string is saved in the variable 
						<font class="bashcommand">PASSWORD</font>. While the user is writing its password and until it presses Enter, 
						you will see the following symbol underneath <font class="bashcommand">$ read -s PASSWORD </font>:
						<img src="pwd.png"/>. Afterwards, the symbol will disappear.
					</p>
					
					<p>
						In the example of a wrong syntax, the mistake is that the variable <font class="bashcommand">PASSWORD</font> 
						is written before the flag <font class="bashcommand">-s</font>. The variable must go at the end of the command 
						independently of which flags are used. As a result, bash is not silencing the user input, is giving the invalid 
						identifier error, and is not saving any string in the variable.
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
								$ read -s PASSWORD<br>
								<img src="pwd.png"/><br>
								$ echo ${PASSWORD}</br>
								<font class="bashcommand-result">ThisIsMyPassword</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
								$ read PASSWORD -s<br>
								ThisIsMyPassword<br>
								<font class="bashcommand-result">-bash: read: `-s': not a valid identifier</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">read -p</font>
						The flag <font class="bashcommand">-p</font> is useful if you want to prompt a message so that the user 
						knows what the input should be. The examples in the following table combine the flags 
						<font class="bashcommand">-p</font> and <font class="bashcommand">-s</font> to indicate the user to input a 
						password and hide the password while its being typed. The prompt message should go right after the flag 
						<font class="bashcommand">-p</font>.
					</p>
					
					<p>
						The following table shows some examples of commands written using a wrong syntax (as well as the correct way 
						to write them). In the first example, the error is that the prompt message is not located right after the flag 
						<font class="bashcommand">-p</font> (instead, it is located after the flag <font class="bashcommand">-s</font>). 
						In the second example, the error is that the variable <font class="bashcommand">PASSWORD</font> is not located 
						at the end of the command. In the third example, the problem is that the prompt message 
						(<font class="bashcommand">Please input your password</font>) is not surrounded by quotation marks. So, for 
						bash only the first word of that sentence (<font class="bashcommand">Please</font>) is the prompt message, and 
						the next word (<font class="bashcommand">input</font>) is read as the variable name. The rest of the command 
						(<font class="bashcommand">your password</font>) is ignored. That is why when reading 
						<font class="bashcommand">${PASSWORD}</font>, nothing is echoed, the variable is empty because nothing was 
						saved with that variable name. Instead, the input was saved in <font class="bashcommand">${input}</font>. This 
						is the reason why the prompt message should always be surrounded by quotation marks.
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -p "Please input your password" -s PASSWORD<br>
									<font class="bashcommand-result">Please input your password</font> <img src="pwd.png"/><br>
									$ echo ${PASSWORD}<br> 
									<font class="bashcommand-result">ThisIsMyPassword</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read -p -s "Please input your password" PASSWORD<br>
									<font class="bashcommand-result">-s</font><br>
									<font class="bashcommand-result">-bash: read: `Please input your password': not a valid identifier</font>
								</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -p "Please input your password" -s PASSWORD<br>
									<font class="bashcommand-result">Please input your password</font> <img src="pwd.png"/><br>
									$ echo ${PASSWORD}<br> 
									<font class="bashcommand-result">ThisIsMyPassword</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read PASSWORD -s -p "Please input your password"<br>
									ThisIsMyPassword<br>
									<font class="bashcommand-result">-bash: read: `-s': not a valid identifier</font>
								</font>
							</td>
						</tr>
						<tr>
							<td>
							</td>
							<td>
								<font class="bashcommand">
									$ read -s -p Please input your password<br>
									ThisIsMyPassword<br>
									$ echo $PASSWORD<br>
									<br>
									$ echo ${input}<br>
									<font class="bashcommand-result">ThisIsMyPassword</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">read -n</font>
						In the following example, <font class="bashcommand">-n 1</font> forces bash to accept only one character in the 
						input. So, the terminal will finish reading after one character. Here we are combining flags 
						<font class="bashcommand">-n</font> and <font class="bashcommand">-p</font> to also prompt a message to the 
						user.
					</p>
					
					<p>
						In the wrong syntax, <font class="bashcommand">1</font> (the number of characters to be accepted) and the 
						prompt message are located in the wrong place. The number of characters accepted should always go after 
						<font class="bashcommand">-n</font> and the prompt message should always go after 
						<font class="bashcommand">-p</font>. 
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -n 1 -p "Do you wish to continue? (y/n)" VAR<br>
									<font class="bashcommand-result">Do you wish to continue? (y/n)y</font><br>
									$ echo $VAR<br>
									<font class="bashcommand-result">y</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read -n -p 1 "Do you wish to continue? (y/n)" VAR<br>
									<font class="bashcommand-result">-bash: read: -p: invalid number</font>
								</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -p "Do you wish to continue? (y/n)" -n 1 VAR<br>
									<font class="bashcommand-result">Do you wish to continue? (y/n)y</font><br>
									$ echo $VAR<br>
									<font class="bashcommand-result">y</font>					
								</font>
							</td>
							<td>
								<font class="bashcommand">
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">read -d</font>
						In the following example the end of the line is determined by the character <font class="bashcommand">#</font> 
						instead of Enter (using the flag <font class="bashcommand">-d</font>). As soon as the user types 
						<font class="bashcommand">#</font>, bash finishes reading and saves the input in the variable 
						<font class="bashcommand">VAR</font>.
					</p>
					
					<p>
						In the wrong syntax, the command is missing the apostrophes (<font class="bashcommand">'</font>) around the 
						character <font class="bashcommand">#</font>.
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -d '#' VAR<br>
									$ echo $VAR<br>
									<font class="bashcommand-result">SomeText</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read -d # VAR<br>
									<font class="bashcommand-result">-bash: read: -d: option requires an argument</font><br>
									<font class="bashcommand-result">read: usage: read [-ers] [-u fd] [-t timeout] [-p prompt] [-a array] [-n nchars] [-d delim] [name ...]</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">The backslash</font>
						In bash, certain characters have special meanings. For example, the dollar sign 
						(<font class="bashcommand">$</font>) is used to reference a variable. When you type 
						<font class="bashcommand">${VAR}</font>, it will print the value of 
						<font class="bashcommand">VAR</font> instead of the actual string 
						"<font class="bashcommand">${VAR}</font>". The backslash (<font class="bashcommand">\</font>) is used to remove 
						those special meanings from the character followed by it. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ VAR="Some text"<br>
							$ echo ${VAR}<br>
							<font class="bashcommand-result">Some text</font><br>
							$ echo \${VAR}<br>
							${VAR}
						</font>
					</p>
					
					<p>
						When using the flag <font class="bashcommand">-r</font>, the backslash is part of the line instead of being 
						used as an escape character. The following table shows examples in which the user inputs the same string but it 
						is read differently because in one case the flag is used (first column) but not in the other (second column).
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Examples using flag -r</b></th>
							<th style="width:50%"><b>Examples without the flag -r</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -r VAR<br>
									<font class="bashcommand-result">C:\Documents\Newsletters\Summer2018.pdf</font><br>
									$ echo ${VAR}<br>
									<font class="bashcommand-result">C:\Documents\Newsletters\Summer2018.pdf</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read VAR<br>
									<font class="bashcommand-result">C:\Documents\Newsletters\Summer2018.pdf</font><br>
									$ echo ${VAR}<br>
									<font class="bashcommand-result">C:DocumentsNewslettersSummer2018.pdf</font>
									</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -r MESSAGE<br>
									<font class="bashcommand-result">In HTML \n is used to indicate a new line</font><br>
									$ echo ${MESSAGE}<br>
									<font class="bashcommand-result">In HTML \n is used to indicate a new line</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read MESSAGE<br>
									<font class="bashcommand-result">In HTML \n is used to indicate a new line</font><br>
									$ echo ${MESSAGE}<br>
									<font class="bashcommand-result">In HTML n is used to indicate a new line</font>
								</font>
							</td>
						</tr>
					</table>
				
				<h3>3.4. Using &lt;&lt;&lt; to get input from a different source</h3>
					<p>
						So far, we have used the command <font class="bashcommand">read</font> to save the user input into a variable. 
						This command can also be used to read from other sources (i.e. other variables or files).
					</p>
					
					<p>
						<font class="example">Reading content from a variable</font>
						In the following example, <font class="bashcommand">read</font> reads the content of the variable 
						<font class="bashcommand">VAR</font>, but only keeps the first character (because it is using the 
						<font class="bashcommand">-n 1</font> flag):
					</p>
					
					<p>
						<font class="bashcommand">
						$ VAR=yes<br>
						$ read -n 1 R &lt;&lt;&lt; ${VAR}<br>
						$ echo ${R}<br>
						<font class="bashcommand-result">y</font>
						</font>
					</p>
					
					<p>
						<font class="example">Reading and saving the output of a function</font>	
						<font class="bashcommand">read</font> also allows you to read the output of a function and save it in a variable. 
						In this example, we are saving the output of the <font class="bashcommand">pwd</font> function into the variable 
						<font class="bashcommand">CURRENT_DIR</font>. <font class="bashcommand">pwd</font> is a function that prints the 
						current folder in which you are located in the command line. 
					</p>
					
					<p>
						<font class="bashcommand">
						$ pwd<br>
						<font class="bashcommand-result">/Users/myUserName</font><br>
						$ read CURRENT_DIR &lt;&lt;&lt; $(pwd)<br>
						$ echo ${CURRENT_DIR}<br>
						<font class="bashcommand-result">/Users/myUserName</font>
						</font>
					</p>
					
					<p>
						<font class="example">**Example specific for people doing neuroimaging**</font>
						<b>WARNING:</b> If you have never analyzed MRI brain images, the following paragraph might sound like written in 
						extraterrestrial language, and it probably will not work in your computer since you need neuroimaging software
						to execute it.
					</p>
					
					<p>	
						In this example, we are reading the output of a function and saving it in the variable 
						<font class="bashcommand">VOL</font>. The output of this function (<font class="bashcommand">fslstats -V</font>) 
						consists of two values separated by a space. The first value is the volume of a region of interest (ROI) from 
						an MRI file in number of voxels, and the second value is the volume in mm<sup>3</sup>. Because we are using the 
						flag <font class="bashcommand">-d ' '</font>, it will read only until the first space (which is the character 
						we are choosing to indicate the end of line). So, bash will save in the variable 
						<font class="bashcommand">VOL</font> only the volume in number of voxels and not in mm<sup>3</sup>. 
					</p>
					
					<p>
						<font class="bashcommand">
						$ fslstats /Users/myUserName/Desktop/MRI/subject001/LGN_L.nii.gz -V<br>
						<font class="bashcommand-result">196 186.920166</font><br>
						$ read -d ' ' VOL &lt;&lt;&lt; $(fslstats /Users/myUserName/Desktop/MRI/subject001/LGN_L.nii.gz -V)<br>
						$ echo $VOL<br>
						<font class="bashcommand-result">196</font>
						</font>
					</p>
    </body>
</html>

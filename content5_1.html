<!DOCTYPE html>
<html>

<body>
<h3>5.1. Declaring and assigning values</h3>
			    	<p>
						An array is a data structure that stores a group of elements and allows you to access each element 
						individually or all elements sequentially. For example, you can have an array of subject IDs. The first 
						object in the array would be the ID of your first subject; the second object would be the ID of your 
						second subject, and so on. An analogy could be a To Do List. In that case, you would have an array of 
						things to do and you can ask yourself what is the first thing in your To-Do list, the second thing, or 
						the last thing, etc. There are different ways of creating an array, as well as different ways of adding 
						elements to it:
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Syntax</b></th>
							<th style="width:70%"><b>Usage</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY[INDEX]=VAL</font>
							</td>
							<td>
								If <font class="bashcommand">ARRAY</font> hasn't been initialized, it will create the array and 
								put element <font class="bashcommand">VAL</font> in the position 
								<font class="bashcommand">INDEX</font>. The first element of an array is always in 
								<font class="bashcommand">INDEX=0</font>, instead of <font class="bashcommand">INDEX=1</font>. 
								If <font class="bashcommand">ARRAY</font> already exists, it will replace 
								<font class="bashcommand">ARRAY</font> in the position <font class="bashcommand">INDEX</font> by 
								the value <font class="bashcommand">VAL</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">declare -a ARRAY=('VAL1' 'VAL2' 'VAL3' ...)</font>
							</td>
							<td>
								Initializes <font class="bashcommand">ARRAY</font> and puts the values inside the parenthesis 
								into the array, respecting the same order. You can specify any number of values. The array is 
								emptied before assigning the values if it already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">read -a ARRAY</font>
							</td>
							<td>
								The words that the user inputs are assigned to sequential indices of 
								<font class="bashcommand">ARRAY</font>. The words must be separated by spaces. The array is 
								emptied before assigning the values if it already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">IFS='DEL' read -a ARRAY</font>
							</td>
							<td>
								Splits the user input using delimiter <font class="bashcommand">DEL</font>, which must be a 
								character or a space. Then, saves the different elements into 
								<font class="bashcommand">ARRAY</font>. The array is emptied before assigning the values if it 
								already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">IFS='DEL' read -a ARRAY &lt;&lt;&lt; STRING</font>
							</td>
							<td>
								Splits <font class="bashcommand">STRING</font> using delimiter 
								<font class="bashcommand">DEL</font>, which must be a character or a space. Then, saves the 
								different elements into <font class="bashcommand">ARRAY</font>. The array is emptied before 
								assigning the values if it already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=($(seq FIRST STEP SIZE))</font>
							</td>
							<td>
								Creates an array of equally spaced numbers beginning with <font class="bashcommand">FIRST</font> 
								and separated by <font class="bashcommand">STEP</font>. It will add 
								<font class="bashcommand">SIZE</font> numbers to <font class="bashcommand">ARRAY</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=$(count -digits N FIRST LAST)</font>
							</td>
							<td>
								Creates an array of numbers, each with <font class="bashcommand">N</font> number of digits, 
								starting with <font class="bashcommand">FIRST</font> and ending with 
								<font class="bashcommand">LAST</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=$(seq N)</font>
							</td>
							<td>
								Creates an array of sequential numbers, starting with 1 and ending with 
								<font class="bashcommand">N</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=(ELEMENT1 ELEMENT3 ...)</font>
							</td>
							<td>
								Creates an array with the elements specified inside the parenthesis.
							</td>
						</tr>
					</table>
					
					<p>
						In the following examples we will use the syntax <font class="bashcommand">${ARRAY[INDEX]}</font> to 
						access the element located in the position <font class="bashcommand">INDEX</font> inside 
						<font class="bashcommand">ARRAY</font>. Remember that the first item in an array has index 0, the second 
						item has index 1, etc. I will also use the syntax <font class="bashcommand">${#ARRAY[@]}</font> to get 
						the number of non-empty values inside <font class="bashcommand">ARRAY</font>.
					</p>
					
					<font class="example">ARRAY[INDEX]=VAL</font>
					<p>
						Create an array of subjects' age where each element in the array corresponds to the age of one subject. 
						There are five subjects, so the size of the array is five. Remember, subject 1 will have its age in the 
						position 0, subject 2 in the position 1, etc. This is because <u>in bash, arrays start in the position 0 
						instead of position 1</u>. After assigning all the values to my array, I can print its contents using 
						the expression echo <font class="bashcommand">${ARRAY[@]}</font>. I can also check the size of my array 
						using <font class="bashcommand">echo ${#ARRAY[@]}</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ age[0]=59<br>
							$ age[1]=63<br>
							$ age[2]=21<br>
							$ age[3]=15<br>
							$ age[4]=94<br>
							$ echo ${age[@]}<br>
							<font class="bashcommand-result">59 63 21 15 94</font><br>
							$ echo "Array size: ${#age[@]}"<br>
							<font class="bashcommand-result">Array size: 5</font>
						</font>
					</p>
					
					<p>
						In the following example, I will start assigning values to the array in the position 1 (instead of 0). 
						That is not a problem, but the first position of my array (index=0) will remain empty, and my array will 
						have only 4 values. If I echo the item in position 0 (echo <font class="bashcommand">${ARRAY[0]}</font>), 
						I will get an empty string.
					</p>
					
					<p>
						<font class="bashcommand">
							$ age[1]=63<br>
							$ age[2]=21<br>
							$ age[3]=15<br>
							$ age[4]=94<br>
							$ echo ${age[@]}<br>
							<font class="bashcommand-result">63 21 15 94</font><br>
							$ echo "Array size: ${#age[@]}"<br>
							<font class="bashcommand-result">Array size: 4</font><br>
							$ echo "age(0): ${age[0]} "<br>
							<font class="bashcommand-result">age(0):</font>
						</font>
					</p>
					
					<p>
						<font class="example">declare -a ARRAY=('VAL1' 'VAL2' 'VAL3' ...)</font>
						It is also possible to initiate an array and assign all the values at the same time. To print an element 
						of the array, located in the position <font class="bashcommand">INDEX</font>, you must use the expression 
						<font class="bashcommand">${ARRAY[INDEX]}</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Germany' 'Spain' 'Canada')<br>
							$ echo "The element in position 0 is: ${array[0]}"<br>
							<font class="bashcommand-result">The element in position 0 is: Colombia</font><br>
							$ echo "The element in position 1 is: ${array[1]}"<br>
							<font class="bashcommand-result">The element in position 1 is: United States</font><br>
							$ echo "The element in position 2 is: ${array[2]}"<br>
							<font class="bashcommand-result">The element in position 2 is: Germany</font><br>
							$ echo "The element in position 3 is: ${array[3]}"<br>
							<font class="bashcommand-result">The element in position 3 is: Spain</font><br>
							$ echo "The element in position 4 is: ${array[4]}"<br>
							<font class="bashcommand-result">The element in position 4 is: Canada</font><br>
							$ echo "List of elements in the array: ${array[@]}"<br> 
							<font class="bashcommand-result">List of elements in the array: Colombia United States Germany Spain Canada</font><br>
							$ echo "The number of elements in the array is ${#array[@]}"<br>
							<font class="bashcommand-result">The number of elements in the array is 5</font>
						</font>
					</p>
					
					<p>
						After you declare an array, it doesn't need to stay static. You can keep adding items:
					</p>
					
					<p>
						<font class="bashcommand">
							$ array[5]="Argentina"<br>
							$ array[6]="France"<br>
							$ echo "List of elements in the array: ${array4[@]}"<br>
							<font class="bashcommand-result">List of elements in the array: Colombia United States Germany Spain Canada Argentina France</font>
						</font>
					</p>
					
					<p>
						<font class="example">read -a ARRAY</font>
						Another way of creating and initializing an array is by reading a user input. As we previously learned, 
						the command read captures the user input and saves it in a variable. By using the flag 
						<font class="bashcommand">-a</font>, the user can input more than one word (separated by a space) and bash 
						will assign each word to sequential indexes of the array, starting at 0.
					</p>
					
					<p>
						<font class="bashcommand">
							$ read -a ARRAY<br>
							<font class="bashcommand-result">Element1 Element2 Element3</font><br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">Element1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Element2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Element3</font>
						</font>
					</p>
					
					<p>
						<font class="example">IFS='DEL' read -a ARRAY</font>
						If you want to use a different delimiter other than a space to split the user input into array elements, 
						you can add <font class="bashcommand">IFS='DEL'</font> before the read command, with 
						<font class="bashcommand">DEL</font> being any character.
					</p>
					
					<font class="bashcommand">
						<p>
							$ IFS='/' read -a ARRAY<br>
							<font class="bashcommand-result">Element1/Element2/Element3</font><br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">Element1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Element2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Element3</font>
						</p>
						
						<p>
							$ IFS='.' read -a ARRAY<br>
							<font class="bashcommand-result">1.2.3</font><br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">3</font>
						</p>
					</font>
					
					<p>
						<font class="example">IFS='DEL' read -a ARRAY &lt;&lt;&lt; STRING</font>
						The same way as you can split a user input into elements of an array using a specific delimiter, you can 
						split elements of a string. This is very useful when trying to retain parts of a file path.
					</p>
					
					<p>
						<font class="bashcommand">
							$ IFS='/' read -a ARRAY &lt;&lt;&lt; "Element1/Element2/Element3"<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">Element1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Element2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Element3</font>
						</font>
					</p>
					
					<p>
						In the following example, the input string (<font class="bashcommand">/Element1/Element2/Element3</font>) 
						starts with the delimiter (<font class="bashcommand">/</font>). So, when you split it, 
						<font class="bashcommand">Element1</font> will be in position 1 (not in position 0), because the element 
						in position 0 would be the string located before the first appearance of the delimiter (which is an 
						empty string). 
					</p>
					
					<font class="bashcommand">
						<p>
							$ IFS='/' read -a ARRAY &lt;&lt;&lt; "/Element1/Element2/Element3"<br>
							$ echo ${ARRAY[0]}<br>
							<br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Element1</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Element2</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">Element3</font>
						</p>
						
						<p>
							$ IFS='/' read -a ARRAY &lt;&lt;&lt; "./Folder/Subfolder/file.txt"<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">.</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Folder</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Subfolder</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">file.txt</font>
						</p>
						
						<p>
							$ IFS='.' read -a ARRAY &lt;&lt;&lt; "1.2.3"<br>
							<font class="bashcommand-result">1.2.3</font><br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">3</font>
						</p>
						
						<p>
							$ IFS='.' read -a ARRAY &lt;&lt;&lt; "23.485"<br>
							$ echo "The integer part is ${ARRAY[0]}, and the decimal part is 0.${ARRAY[1]}"<br>
							<font class="bashcommand-result">The integer part is 23, and the decimal part is 0.485</font>
						</p>
					</font>
					
					<p>
						<font class="example">ARRAY=($(seq FIRST STEP SIZE))</font>
						You can also create an array of equally spaced or consecutive numbers in a very easy way using the 
						command <font class="bashcommand">seq</font>. In this example, I will create an array of numbers that go 
						from 15 to 19. The distance between each number (<font class="bashcommand">STEP</font>) is 0.5.
					</p>
					
					<p>
						<font class="bashcommand">
							$ ARRAY=($(seq 15 0.5 19))<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">15</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">15.5</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">16</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">16.5</font><br>
							$ echo ${ARRAY[4]}<br>
							<font class="bashcommand-result">17</font><br>
							$ echo ${ARRAY[5]}<br>
							<font class="bashcommand-result">17.5</font><br>
							$ echo ${ARRAY[6]}<br>
							<font class="bashcommand-result">18</font><br>
							$ echo ${ARRAY[7]}<br>
							<font class="bashcommand-result">18.5</font><br>
							$ echo ${ARRAY[8]}<br>
							<font class="bashcommand-result">19</font>
						</font>
					</p>
					
					<p>
						In this example, I will create an array of numbers that go from 1 to 10. The distance between each 
						number (<font class="bashcommand">STEP</font>) is 2. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ ARRAY=($(seq 1 2 10))<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">3</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">5</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">7</font><br>
							$ echo ${ARRAY[4]}<br>
							<font class="bashcommand-result">9</font>
						</font>
					</p>
					
					<p>
						When the step between the numbers is 1, it doesn't need to be written:<br>
	 					<font class="bashcommand">($(seq 15 1 19))</font> is the same as 
	 					<font class="bashcommand">($(seq 15 19))</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ ARRAY=($(seq 15 19))<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">15</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">16</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">17</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">18</font><br>
							$ echo ${ARRAY[4]}<br>
							<font class="bashcommand-result">19</font>
						</font>
					</p>
					
					<font class="example">ARRAY=(ELEMENT1 ELEMENT2 ELEMENT3 ...)</font>
					
					<p>
						<font class="bashcommand">
							$ array=(e1 e2 e3 e4 e5 e6)<br>
							$ echo ${array[0]}<br>
							<font class="bashcommand-result">e1</font><br>
							$ echo ${array[1]}<br>
							<font class="bashcommand-result">e2</font><br>
							$ echo ${array[2]}<br>
							<font class="bashcommand-result">e3</font><br>
							$ echo ${array[3]}<br>
							<font class="bashcommand-result">e4</font><br>
							$ echo ${array[4]}<br>
							<font class="bashcommand-result">e5</font><br>
							$ echo ${array[5]}<br>
							<font class="bashcommand-result">e6</font>
						</font>
					</p>
					
					<p>
						Bash and other programs have functions that return a list of elements. For example, as you will learn in 
						the section of file manipulation, the command <font class="bashcommand">ls</font> returns the list of 
						files in your current working directory. In these cases, instead of manually entering a list of elements 
						between parentheses to convert into an array, you can write the function name, and its output will be saved in the array:
					</p>
					
					<font class="bashcommand">
						<p>
							$ ls<br>
							<font class="bashcommand-result">
							<table class="ghostTable">
								<tr>
									<td>@update.afni.binaries</td>
									<td>Downloads</td>
									<td>abin</td>
								</tr>
								
								<tr>
									<td>AFNI_data5</td>
									<td>Library</td>
									<td>afni_handouts</td>
								</tr>
								
								<tr>
									<td>AFNI_data6</td>
									<td>Movies</td>
									<td>dax</td>
								</tr>
								
								<tr>
									<td>AFNI_demos</td>
									<td>Music</td>
									<td>std_meshes</td>
								</tr>
								
								<tr>
									<td>Desktop</td>
									<td>Pictures</td>
									<td>suma_demo</td>
								</tr>
								
								<tr>
									<td>Documents</td>
									<td>Public</td>
									<td>test.txt</td>
								</tr>
							</table>
							</font>
						</p>
						
						<p>
							$ array=($(ls))<br>
							$ echo ${array[0]}<br>
							<font class="bashcommand-result">@update.afni.binaries</font><br>
							$ echo ${array[1]}<br>
							<font class="bashcommand-result">AFNI_data5</font><br>
							$ echo ${array[2]}<br>
							<font class="bashcommand-result">AFNI_data6</font><br>
							$ echo ${array[3]}<br>
							<font class="bashcommand-result">AFNI_demos</font><br>
							$ echo ${array[4]}<br>
							<font class="bashcommand-result">Desktop</font>
						</p>
					</font>
</body>

</html>

<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="description" content="Bash iteration">
	<meta name="keywords" content="bash, tutorial, iteration, while, for, loops">
	<meta name="author" content="Monica Keith">
	
	<link rel="stylesheet" type="text/css" href="styles.css">
	<script src="functions.js"></script>
	<noscript>Sorry, your browser does not support JavaScript. This page needs to have JavaScript enabled.</noscript>
</head>
	
    <body>
        <h2>7. Iteration</h2>
				<p>
					In the following section we will learn how to use loops to iterate through the content of arrays or through a list of files. However, we will leave the part of iterating through the content of a file for the next section (File manipulation). Iteration is basically the repetition of a process or group of commands on a list of items. For example, you might use iteration to repeat the same processing steps on the MRI images of a list of subjects, or to manipulate in the same way a list of files. It saves time because instead of typing the same command 100 times to do the exact same thing on 100 subjects, you type it just one time inside a loop. You will use loops (as well as condition-testing) in almost every script that you write.
				</p>
				
				<table>
						<tr>
							<th><b>Command</b></th>
							<th><b>Use</b></th>
							<th><b>Syntax</b></th>
						</tr>
						
						<tr>
							<td><font class="bashcommand">for</font></td>
							<td>For iterating over a series of items within a list (array).</td>
							<td>
								for item in list_of_items<br>
								do<br>
								&emsp;Commands to run on each item<br>
								done 
							</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">for</font></td>
							<td>For iterating through an index.</td>
							<td>
								for ((i=1; i<=64; i+=1))<br>
								do<br>
								&emsp;Commands to run on each iteration<br>
								done
							</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">while</font></td>
							<td>For iterating while a control expression (condition) is true.</td>
							<td>
								while condition_is_true<br>
								do<br>
								&emsp;Commands to run while the condition is true<br>
								done 
							</td>
						</tr>
				</table>
		    	
		    	<h3>7.1. The for loop</h3>
					<h4>Iterating through an array of words</h4>
		    		
					<p>
						In the following example we have an array with a list of subjects ID:<br>
						<font class="bashcommand">
						$ declare -a ARRAY=('SUBJ0' 'SUBJ9' 'SUBJ3' 'SUBJ4' 'SUBJ3') 
						</font>
					</p>
					
					<p>If we wanted to print the ID of each subject within the list without using a loop, we would have to type 5 different commands (imagine if you have 800 subjects?):</p>
					
					<p>
						<font class="bashcommand">
							$ echo ${ARRAY[0]}<br> 
							<font class="bashcommand-result">SUBJ0</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">SUBJ9</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">SUBJ3</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">SUBJ4</font><br>
							$ echo ${ARRAY[4]}<br>
							<font class="bashcommand-result">SUBJ3</font> 
						</font>
					</p>
					
					<p>If we use a loop, you will just need to write the command one time. In this example, with only five subjects it doesnâ€™t save too much lines of code. But normally you will be working with many more subjects than five.</p>
					
					<p>
						<font class="bashcommand">
							$ for ID in ${ARRAY[@]}<br>
							&gt;  do<br>
							&gt;  echo ${ID}<br>
							&gt;  done<br>
							<font class="bashcommand-result">
							SUBJ0<br>
							SUBJ9<br>
							SUBJ3<br>
							SUBJ4<br>
							SUBJ3  
							</font>
						</font>
					</p>
		    		
					<p>What this for loop does is iterate through every item in <font class="bashcommand">${ARRAY[@]}</font> (the items that would be listed if you typed echo <font class="bashcommand">${ARRAY[@]}</font>) and assign each item to the variable <font class="bashcommand">ID</font> during the corresponding loop. So, the loop will run 5 times. The first time it runs it will assign subject <font class="bashcommand">'SUBJ0'</font> to variable <font class="bashcommand">ID</font>, the second time subject <font class="bashcommand">'SUBJ9'</font>, etc.</p>

					<p>
						<font class="bashcommand">
							$ num=0<br>
							$ for ID in ${ARRAY[@]}<br>
							&gt;  do<br>
							&gt;  echo "Subject number ${num} is ${ID}"<br>
							&gt;  ((num++))<br>
							&gt;  done<br>
							<font class="bashcommand-result">
							Subject number 0 is SUBJ0<br>
							Subject number 1 is SUBJ9<br>
							Subject number 2 is SUBJ3<br>
							Subject number 3 is SUBJ4<br>
							Subject number 4 is SUBJ3 
							</font>
						</font>
					</p>
					
					<h4>Iterating through files using patterns</h4>
					<p>
						As we learned in the Arrays section, you can use patterns to create arrays. You can also use patterns to list files which path is very similar except for a few words. For example, if you have a folder located in the following path:<br>  
						/Users/MyUserName/Desktop/MyProjectFolder<br>
						And inside this folder you have 100 files named very similarly (only vary in one character):<br>
						DTI_SUBJ1.nii.gz<br>
						DTI_SUBJ2.nii.gz<br>
						DTI_SUBJ3.nii.gz<br>
						DTI_SUBJ4.nii.gz<br>
						DTI_SUBJ5.nii.gz<br> 
						...<br>
						DTI_SUBJ100.nii.gz<br>
						Then, you could echo the list of all those files by simply typing:<br>
						<font class="bashcommand">$ echo /Users/MyUserName/Desktop/MyProjectFolder/DTI_SUBJ*.nii.gz</font><br>
						The previous command matches all the file paths that contain any characters in the position where the asterisk is located.
					</p>
					
					<p>
						Or let's suppose that you have your subject's information organized in the following way:<br>
						You have your main subjects folder located in this path:<br>
						/Users/MyUserName/Desktop/MyProjectFolder<br>
						Then, inside that folder you have one folder per subject:<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject1<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject2<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject3<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject4<br>
						...<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject100<br>
						And inside each subject folder, you have the following files:<br>
						DTI.nii.gz<br>
						ANAT.nii.gz<br>
						LGN.nii.gz 
					</p>
					
					<p>
						So, if you wanted to obtain the list of the DTI.nii.gz files for all subjects, you could type:<br> 
						<font class="bashcommand">echo /Users/MyUserName/Desktop/MyProjectFolder/Subject*/DTI.nii.gz</font><br>
						Because the path of the DTI of all subjects is the same except for the subject number, then you create the pattern by substituting the part that changes by an asterisk <font class="bashcommand">*</font>. 
					</p>
					
					<p>
						When using the asterisk, it will select all files that contain any amount of characters in that position. But if you want to restrict the search to a specific amount of characters, you could also use the interrogation character.
					</p>
					
					<p>
						For example, let's supose you have a main folder located in the folowing path:<br>
						/MyComputer/MyUser/MyDocuments/MyFolder<br>
						And inside that folder you have 100 files named:<br>
						myFile001.txt<br>
						myFile002.txt<br>
						...<br>
						myFile099.txt<br>
						myFile100.txt
					</p>
					
					<p>You want to iterate through the files myFile001.txt to myFile009.txt. All those files have the exact same path and name except for exactly one character. So, you can replace that character by an interrogration:</p>
					
					<p>	
						<font class="bashcommand">
							$ for f in /MyComputer/MyUser/MyDocuments/MyFolder/myFile00?.txt<br>
							&gt;  do<br>
							&gt;  echo $f<br>
							&gt;  done<br>
							<font class="bashcommand-result">
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile001.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile002.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile003.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile004.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile005.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile006.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile007.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile008.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile009.txt
							</font>
						</font>
					</p>
					
					<p>
						You could choose to print the results into a file instead of the command prompt. This can be easily achieved using the symbol <font class="bashcommand">&gt;&gt;</font>. After running the following loop, you will not see any output in the command line, the path of the nine files will be saved in output.txt:<br>
						The command <font class="bashcommand">cat ${maindir}output.txt</font> prints the content of this output file.
					</p>
					
					<p>
						<font class="bashcommand">
							$ maindir=/MyComputer/MyUser/MyDocuments/MyFolder/<br>
							$ for f in ${maindir}myFile00?.txt<br>
							&gt;  do<br>
							&gt;  echo $f &gt;&gt; ${maindir}output.txt<br>
							&gt;  done<br>
							$ cat ${maindir}output.txt<br>
							<font class="bashcommand-result">
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile001.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile002.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile003.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile004.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile005.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile006.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile007.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile008.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile009.txt
							</font>
						</font>
					</p>
					
					<h4>Iterating through files in your current directory</h4>
					<p>To know the current directory in which you are located in the command line, type <font class="bashcommand">pwd</font>. In the following example we want to we want to perform some action on all the files inside the current directory. To get the list of those files we use the command <font class="bashcommand">ls</font>.</p>
					
					<p>
						<font class="bashcommand">
						$ pwd<br>
						<font class="bashcommand-result">/path/to/my/current/directory</font><br>
						$ for f in $( ls )<br>
						&gt;  do<br>
						&gt;  echo "Do something with this file: ${f}"<br>
						&gt;  done
						</font>
					</p>
					
		    	<h3>7.2. From for to while</h3>
		    		<p>Every loop that you write using the for command, can also be written using the while command. The results will be the same but sometimes one of them will be more efficient and easier to code than the other. In general, the for command is a lot easier to use and understand. However:</p>

					<ul>
					  <li>You should use the <b>for</b> command when you want to iterate through <b>all the elements</b> of an array.</li>
					  <li>You should use the <b>while</b> command when you want to iterate through <b>a limited number of elements within the array.</b></li>
					  <li>You should use the <b>while</b> command when you want to <b>iterate through more than one array</b> or while <b>several conditions should be met</b>.</li>
					</ul>
					
					<p>The following example shows how a for loop can be converted into a while loop. The objective of this piece of code is to print the elements of an array.</p>
		    		
					<p>
						<font class="example">From for to while</font>
						<font class="bashcommand">$ declare -a ARRAY=('SUBJ0' 'SUBJ9' 'SUBJ3' 'SUBJ4' 'SUBJ3')</font>
					</p>
					
					<table>
						<tr>
							<th><b>Using a for loop</b></th>
							<th><b>Using a while loop</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">
									$ for E in ${ARRAY[@]}<br>
									&gt;  do<br>
									&gt;  echo ${E}<br>
									&gt;  done<br>
									<font class="bashcommand-result"> 
									SUBJ0<br>
									SUBJ9<br>
									SUBJ3<br>
									SUBJ4<br>
									SUBJ3  
									</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ SIZE=${#ARRAY[@]} <br>
									$ i=0 <br>
									$ while [ ${i} -lt ${SIZE} ] <br>
									&gt;  do <br>
									&gt;  echo ${ARRAY[${i}]} <br>
									&gt;  ((i++)) <br>
									&gt;  done <br>
									<font class="bashcommand-result">
									SUBJ0 <br>
									SUBJ9 <br>
									SUBJ3 <br>
									SUBJ4 <br>
									SUBJ3 
									</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>In the previous example, both loops (the one in the left using a <b>for</b> and the one in the right using a <b>while</b>) iterate through the elements of an array and echoes them in the terminal window. However, there are some important differences:</p>
					
					<ul>
						<li>The <u>for loop</u> automatically stops when iteration reaches the end of the array. The <u>while loop</u> stops when the condition (<font class="bashcommand">[ ${i} -lt ${SIZE} ]</font>) evaluates false. This means that it will iterate as long as variable <font class="bashcommand">i</font> is less (<font class="bashcommand">-lt</font>) <font class="bashcommand">SIZE</font>. In the while loop, variable <font class="bashcommand">i</font> contains the index of each item during the iteration and variable <font class="bashcommand">SIZE</font> contains the size of the array. For this reason, <font class="bashcommand">((i++))</font> is included inside the while loop. <font class="bashcommand">((i++))</font> increments the value of <font class="bashcommand">i</font> in 1 on each iteration. If you didn't include this, bash would iterate forever, because you wouldn't be increasing the value of <font class="bashcommand">i</font> and it would always equal zero. Hence, it would never be less than the size of the array, so the condition that the while evaluates will never be false. Since while iterates as long as that condition is true, it would iterate forever.</li>
						<li>In the <u>for loop</u> each element of the array is saved in variable <font class="bashcommand">E</font>. However, you don't have to assign each value to the variable, it is done automatically. In the <u>while loop</u> the element in the position <font class="bashcommand">i</font> is being referenced with <font class="bashcommand">${ARRAY[${i}]}</font>.</li>
						<li>Off course, in this case as we want to iterate through all the elements of <font class="bashcommand">ARRAY</font>, it makes no sense to use the while loop. It requires more lines of code; it is easier to make mistakes and it is harder to understand. But this is a good example to show how it works. </li>
					</ul>
					
					<p>
						<font class="example">Printing the elements of an array and their position within the array</font>
						<font class="bashcommand">$ declare -a ARRAY=('SUBJ0' 'SUBJ9' 'SUBJ3' 'SUBJ4' 'SUBJ3')</font>
					</p>
					
					<table>
						<tr>
							<th><b>Using a for loop</b></th>
							<th><b>Using a while loop</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">
									$ i=0 <br>
									$ for ID in ${ARRAY[@]} <br>
									&gt;  do <br>
									&gt;  echo "Subject number ${i} is ${ID}" <br>
									&gt;  ((i++)) <br>
									&gt;  done <br>
									<font class="bashcommand-result"> 
									Subject number 0 is SUBJ0 <br>
									Subject number 1 is SUBJ9 <br>
									Subject number 2 is SUBJ3 <br>
									Subject number 3 is SUBJ4 <br>
									Subject number 4 is SUBJ3 
									</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ SIZE=${#ARRAY[@]} <br>
									$ i=0 <br>
									$ while [ ${i} -lt ${SIZE} ] <br>
									&gt;  do <br>
									&gt;  echo "Subject number ${i} is ${ARRAY[$i]}" <br>
									&gt;  ((i++)) <br>
									&gt;  done <br>
									<font class="bashcommand-result">
									Subject number 0 is SUBJ0 <br>
									Subject number 1 is SUBJ9 <br>
									Subject number 2 is SUBJ3 <br>
									Subject number 3 is SUBJ4 <br>
									Subject number 4 is SUBJ3 
									</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">Printing the first five files in the current directory</font>
						Previously we learned that the following loop would echo the path of all the files in the current directory: 
					</p>
					
					<p>
						<font class="bashcommand">
						$ for f in $( ls ) <br>
						&gt; do <br>
						&gt; echo "Do something with this file: ${f}" <br>
						&gt; done 
						</font>
					</p>
					
					<p>In this case, it makes no sense to use the while loop. However, if instead of echoing all the files inside the current directory you wanted to echo only the first five files, then you must use the while loop.</p>
					
					<table>
						<tr>
							<th><b>Preferably use a for loop</b></th>
							<th><b>Preferably use a while loop</b></th>
						</tr>
						
						<tr>
							<td>
								<p>This loop will print <b>all</b> the files in the current directory:</p>
								<p>
									<font class="bashcommand">
										$ for f in $( ls ) <br>
										&gt; do <br>
										&gt; echo ${f} <br>
										&gt; done <br>
										<font class="bashcommand-result">
										Applications <br>
										Library <br>
										Network <br>
										System <br>
										Users <br>
										Volumes <br>
										cores <br>
										dev <br>
										net <br>
										opt <br>
										bin <br>
										tmp 
										</font>
									</font>
								</p>
							</td>
							<td>
								<p>This loop will print <b>the first five</b> files in the current directory:</p>
								<p>
									<font class="bashcommand">
										$ i=0 <br>
										$ ARRAY=($( ls )) <br>
										$ while [ ${i} -le 4 ] <br>
										&gt; do <br>
										&gt; echo ${ARRAY[${i}]} <br>
										&gt; ((i++)) <br>
										&gt; done <br>
										<font class="bashcommand-result">
										Applications <br>
										Library <br>
										Network <br>
										System <br>
										Users 
										</font>
									</font>
								</p>
							</td>
						</tr>
						
						<tr>
							<td>
								<p>This loop will rename <b>all</b> the files in the current directory that end in .nii.gz. Before and after the loop I am printing the content of the folder to visualize the change. Command ls prints the content of the current directory:  </p>
								<p>
									<font class="bashcommand">
										$ ls <br>
										<font class="bashcommand-result">
										10132423423.nii.gz <br> 
										25675756756.nii.gz <br>
										36787686767.nii.gz <br>
										37456456456.nii.gz <br>
										39756756756.nii.gz <br>
										41786786677.nii.gz <br>
										</font>
										$ i=1 <br>
										$ for f in ./*.nii.gz <br>
										&gt; do <br>
										&gt; mv ${f} Subject_${i}.nii.gz <br>
										&gt; ((i++)) <br>
										&gt; done <br>
										$ ls <br>
										<font class="bashcommand-result">
										Subject_1.nii.gz <br>
										Subject_2.nii.gz <br>
										Subject_3.nii.gz <br>
										Subject_4.nii.gz <br>
										Subject_5.nii.gz <br>
										Subject_6.nii.gz 
										</font>
									</font>
								</p>
							</td>
							<td>
								<p>This loop will rename <b>the first three</b> files in the current directory that end in .nii.gz. Before and after the loop I am printing the content of the folder to visualize the change. Command ls prints the content of the current directory:</p>
								<p>
									<font class="bashcommand">
										$ ls 
										<font class="bashcommand-result">
										10132423423.nii.gz <br>
										25675756756.nii.gz <br>
										36787686767.nii.gz <br>
										37456456456.nii.gz <br>
										39756756756.nii.gz <br>
										41786786677.nii.gz <br>
										</font>
										$ i=0 <br>
										$ ARRAY=($( ls ./*.nii.gz )) <br>
										$ while [ ${i} -le 2 ] <br>
										&gt; do <br>
										&gt; mv ${ARRAY[${i}]} ./Subject_$((++i)).nii.gz <br>
										&gt; done <br>
										$ ls <br>
										<font class="bashcommand-result">
										Subject_1.nii.gz <br>
										Subject_2.nii.gz <br>
										Subject_3.nii.gz <br>
										37456456456.nii.gz <br>
										39756756756.nii.gz <br>
										41786786677.nii.gz 
										</font>
									</font>
								</p>
							</td>
						</tr>
					</table>
					

		    	<h3>7.3. The while loop</h3>
					<h4>Using the while loop to iterate through more than one array</h4>
					
		    		<p>As previously mentioned, when you are iterating through more than one array you should use the while loop instead of the for loop.</p>
		    
					<p>
						<font class="example">Iterating through two arrays at the same time</font>
						In the following example there are two arrays (<font class="bashcommand">ID</font> and <font class="bashcommand">VISIT</font>), which contain a list of subject IDs and visit number respectively. The loop iterates through both arrays (until it reaches the end of one or the other) and saves the information extracted from both arrays into a text file. Then, it prints the content of the text file (test.txt) using the command cat, which will be explained in detail in the following chapter (File manipulation). 
					</p>
					
					<p>This while loop will run as long as the two conditions (<font class="bashcommand">[ ${i} -lt ${SIZE_ID} ]</font>, <font class="bashcommand">[ ${i} -lt ${SIZE_VISIT} ]</font>) that are being evaluated be true. This means, as long as variable <font class="bashcommand">i</font> have value less than (<font class="bashcommand">-lt</font>) the size of <font class="bashcommand">ID</font> and <font class="bashcommand">VISIT</font>. So, as soon as its value be greater than <font class="bashcommand">SIZE_ID</font> or <font class="bashcommand">SIZE_VISIT</font>, it will stop. In this case both arrays have the same size. Again, it is extremely important to not forget the line <font class="bashcommand">((i++))</font>, otherwise, it will loop forever (you can always break a loop with Control + C). </p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ID=('SUBJ0' 'SUBJ1' 'SUBJ2' 'SUBJ3' 'SUBJ4' 'SUBJ5' 'SUBJ6') <br>
							$ declare -a VISIT=('V1' 'V1' 'V2' 'V1' 'V2' 'V2' 'V3') <br>
							$ SIZE_ID=${#ID[@]} <br>
							$ SIZE_VISIT=${#VISIT[@]} <br>
							$ i=0 <br>
							$ while [ ${i} -lt ${SIZE_ID} ] && [ ${i} -lt ${SIZE_VISIT} ] <br>
							&gt; do <br>
							&gt; echo "${ID[${i}]}_${VISIT[${i}]}" &gt;&gt; test.txt <br>
							&gt; ((i++)) <br>
							&gt; done <br>
							$ cat test.txt <br>
							<font class="bashcommand-result">
							SUBJ0_V1 <br>
							SUBJ1_V1 <br>
							SUBJ2_V2 <br>
							SUBJ3_V1 <br>
							SUBJ4_V2 <br>
							SUBJ5_V2 <br>
							SUBJ6_V3 
							</font>
						</font>
					</p>
					
					<p>
						<font class="example">Inverting an array</font>
						In this example, initially there is only one array, but after the code is executed there will be two arrays. The second array will be the inversion of the first one. The code will iterate starting at the end of the array and finishing at the beginning. In each iteration it will copy the current value into the new array. It will start adding items at the beginning of the new array (in the index 0). For this purpose, there will be two variables. Variable <font class="bashcommand">i</font>, which will be initialized with value <font class="bashcommand">$(( ${#ARRAY[@]} â€“ 1 ))</font> (the size of the initial array minus one) and will represent the position in which the loop is iterating in the original array. In each loop <font class="bashcommand">i</font> will decrease its value in 1 until it reaches 0. And variable <font class="bashcommand">j</font>, which will be initialized with value 0 and will represent the position in which the loop is iterating in the inverted array. In each loop <font class="bashcommand">j</font> will increase its value until it reaches the size of the original array (when all the values would have finished being copied). So, the while will loop as long as variable <font class="bashcommand">i</font> have value greater or equal (<font class="bashcommand">-ge</font>) to 0. 
					</p>
					
					<p>Variable <font class="bashcommand">i</font> is initialized with value equal to the size of the array minus one instead of the size of the array because remember that the first index of an array is 0, so the last one is the size minus one.</p>
					
					<p>
						Order of values in the original array: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.<br>
						Order of values in the inverted array: 10, 9, 8, 7, 6, 5, 4, 3, 2, 1. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=('1' '2' '3' '4' '5' '6' '7' '8' '9' '10') <br>
							$ i=$(( ${#ARRAY[@]} - 1 )) <br>
							$ j=0 <br>
							$ while [ ${i} -ge 0 ] <br>
							&gt; do <br>
							&gt; echo "Copying element in position ${i} from the original array into position ${j} of the new array..." <br>
							&gt; INV_ARRAY[$((j++))]=${ARRAY[$((i--))]} <br>
							&gt; done <br>
							<font class="bashcommand-result">
							Copying element in position 9 from the original array into position 0 of the new array... <br>
							Copying element in position 8 from the original array into position 1 of the new array... <br>
							Copying element in position 7 from the original array into position 2 of the new array... <br>
							Copying element in position 6 from the original array into position 3 of the new array... <br>
							Copying element in position 5 from the original array into position 4 of the new array... <br>
							Copying element in position 4 from the original array into position 5 of the new array... <br>
							Copying element in position 3 from the original array into position 6 of the new array... <br>
							Copying element in position 2 from the original array into position 7 of the new array... <br>
							Copying element in position 1 from the original array into position 8 of the new array... <br>
							Copying element in position 0 from the original array into position 9 of the new array... <br>
							</font>
							$ echo ${INV_ARRAY[@]} <br>
							<font class="bashcommand-result">
							10 9 8 7 6 5 4 3 2 1 
							</font>
						</font>
					</p>
					
					<p>The command <font class="bashcommand">INV_ARRAY[$((j++))]=ARRAY[$((i--))]</font> is doing three things: assigning the element of <font class="bashcommand">ARRAY</font> in position <font class="bashcommand">i</font> to <font class="bashcommand">INV_ARRAY</font> in position <font class="bashcommand">j</font>, incrementing <font class="bashcommand">j</font> in one, and decreasing <font class="bashcommand">i</font> in one. It is equivalent to this set of instructions:</p>
					
					<p>
						<font class="bashcommand">
							INV_ARRAY[${j}]=ARRAY[${i}] <br>
							((j++)) <br>
							((i--)) 
						</font>
					</p>
					
					<h4>Using the while loop to iterate when several conditions should be met</h4>
					
					<p>In the following example there is an array of subject IDs (<font class="bashcommand">SUBJECTS</font>). Some of those subjects are controls and their ID starts with the letter C, other subjects are patients and their ID starts with the letter P. The array is organized so that the controls go before the patients. The loop will copy only the controls into a new array (<font class="bashcommand">CONTROLS</font>). So, there are two conditions to be met so that the loop continues to run: the index variable <font class="bashcommand">i</font> be less than the size of <font class="bashcommand">SUBJECTS</font> (<font class="bashcommand">${#SUBJECTS[@]}</font>), and the current element (<font class="bashcommand">SUBJECTS[${i}]</font>) start with the letter C. To get the first letter of the current element you must use the previously learned syntax to extract a sub-string: <font class="bashcommand">${STRING:START:NUM}</font>.</p>
					
					<p>
						The first condition (iterate while <font class="bashcommand">i</font> less than the size of the array <font class="bashcommand">SUBJECTS</font>) is written like this:<br>
						<font class="bashcommand">[ ${i} -lt ${#SUBJECTS[@]} ]</font>.
					</p>
					
					<p>
						The second condition (iterate while the current element in the loop starts with the letter C) is written like this:<br>
						<font class="bashcommand">
							$ declare -a SUBJECTS=('C01' 'C02' 'C03' 'C04' 'C05' 'C06' 'P07' 'P08' 'P09' 'P10') <br>
							$ i=0 <br>
							$ while [ ${i} -lt ${#SUBJECTS[@]} ] && [ "${SUBJECTS[${i}]:0:1}" == "C" ] <br>
							&gt; do <br>
							&gt; CONTROLS[${i}]=${SUBJECTS[$((i++))]} <br>
							&gt; done <br>
							$ echo ${CONTROLS[@]} <br>
							<font class="bashcommand-result">C01 C02 C03 C04 C05 C06</font>
						</font>
					</p>
    </body>
</html>

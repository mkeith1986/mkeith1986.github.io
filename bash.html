<!DOCTYPE html>
<html>
	<title>Bash Tutorial</title> 

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Bash programming tutorial">
		<meta name="keywords" content="bash, tutorial">
		<meta name="author" content="Monica Keith">	
		
		<link rel="stylesheet" type="text/css" href="styles.css">
		<script src="functions.js"></script>
		<noscript>Sorry, your browser does not support JavaScript. This page needs to have JavaScript enabled.</noscript>
	</head>
	
	<body>
		<header>
		  <h2>Bash Tutorial</h2>
		</header>
		
		<section>
		  <nav>
		    <ul>
		     	<li><a onclick="showContent(1);">1. Introduction to shell scripting</a></li>
		      	<li><a onclick="showContent(2);">2. Creating simple bash scripts</a></li>
		      	<li><a onclick="showContent(3);">3. Variables</a></li>
		      	<li><a onclick="showContent(4);">4. Arithmetic calculations</a></li>
		      	<li><a onclick="showContent(5);">5. Arrays</a></li>
		      	<li><a onclick="showContent(6);">6. Condition-testing</a></li>
		      	<li><a onclick="showContent(7);">7. Iteration</a></li>
		      	<li><a onclick="showContent(8);">8. General file manipulation</a></li>
		      	<li><a onclick="showContent(9);">9. Manipulating text and csv files</a></li>
		      	<li><a onclick="showContent(10);">10. Manipulating image and video files</a></li>
		      	<li><a onclick="showContent(11);">11. Writing more complex bash scripts</a></li>
				<li><a onclick="showContent(12);">12. Remote shell</a></li>
				<li><a onclick="showContent(13);">13. Cluster jobs</a></li>
				<li><a onclick="showContent(14);">14. Downloading files from the web</a></li>
				<li><a onclick="showContent(15);">15. Creating backups</a></li>
				<li><a onclick="showContent(16);">16. File permissions</a></li>
				<li><a onclick="showContent(17);">17. Using aliases</a></li>
				<li><a onclick="showContent(18);">18. Keyboard shortcuts</a></li>
				<li><a onclick="showContent(19);">19. MySQL</a></li>
				<li><a onclick="showContent(20);">20. Report an error in the tutorial</a></li>
		    </ul>
		  </nav>
		  
		  <article>
		  	<div id="content1">
				<iframe src="content1.html"></iframe>
			</div>
		    
		    <div id="content2" class="hidden">
			    <iframe src="content2.html"></iframe>
		    </div>
		    
		    <div id="content3" class="hidden">
		    	<iframe src="content3.html"></iframe>					
		    </div>
		    
		    <div id="content4" class="hidden">
		    	<iframe src="content4.html"></iframe>
		    </div>
		    
		    <div id="content5" class="hidden">
		    	<iframe src="content5.html"></iframe>
		    </div>
		    
		    <div id="content6" class="hidden">
		    	<iframe src="content6.html"></iframe>
		    </div>
		       
		    <div id="content7" class="hidden">
		    	<iframe src="content7.html"></iframe>
			</div>
		       
		    <div id="content8" class="hidden">
		    	<iframe src="content8.html"></iframe>
		    </div>
		       
		    <div id="content9" class="hidden">
		    	<h2>9. Manipulating text and csv files</h2>
			    
			<h3>9.1. Writing files</h3>
				<h4>echo</h4>
				<p>So far we have used echo to print text into the terminal. You can also use this utility to print text into a file (and create a new file if it doesn't exist):</p>
		    		
				<p>
				The following command will append <font class="bashcommand">"some text"</font> in a new line of <font class="bashcommand">someFile.txt</font> and add the new line character at the end. If someFile.txt didn’t exist, the file is created.<br>
				<font class="bashcommand">echo "some text" >> someFile.txt</font>
				</p>

				<p>
				If you add the flag <font class="bashcommand">-n</font>, bash won't print the trailing newline character:<br> 
				<font class="bashcommand">echo -n "some text" >> someFile.txt</font>
				</p>

				<p>If you add the flag <font class="bashcommand">-e</font> it will interpret the character scape sequences in the text (see table below in the <font class="bashcommand">printf</font> section for a list of scape sequences).</p>

				<p>If you use <font class="bashcommand">&gt;</font> instead of <font class="bashcommand">&gt;&gt;</font>, the previous contents of the file (if it existed) will be erased and replaced with the new text that you are echoing.</p>

				<h4>printf</h4>
				<p><font class="bashcommand">printf</font> is a powerful tool that allows you to format the information before printing it in a file, the command line or another variable. For example, you can specify the format of any number that you print and the number of decimal points you want to use. You could even use this tool to change the format of a variable (i.e. from scientific notation to float) and save the result in a new variable instead of a file. You can also add tab or any character scape sequence to your text.</p>

				<p>Syntax: <font class="bashcommand">printf &lt;format&gt; &lt;arguments&gt;</font></p>

				<p><font class="bashcommand">printf</font> uses the format specified in <font class="bashcommand">&lt;format&gt;</font> to print the objects (strings, numbers or variables) specified in <font class="bashcommand">&lt;arguments&gt;</font>. <font class="bashcommand">&lt;format&gt;</font> is a string that contains alphanumerical characters, character scape sequences and format specifications, each of which causes printing of the next successive argument. In contrast with the <font class="bashcommand">echo</font> command, <font class="bashcommand">printf</font> does not print the text in a new line by default, in order to add a new line the following character scape sequence should be added at the end of <font class="bashcommand">&lt;format&gt;</font>: <font class="bashcommand">\n</font>.</p>
		    	
				<table>
					<tr>
					<th>Character scape sequence</th>
					<th>Meaning</th>
					</tr>

					<tr>
					<td><font class="bashcommand">\b</font></td>
					<td>
						<p>Do not print the previous character (backspace).</p>
						<p><font class="bashcommand">
							$ printf "%b" "abcdef"<br>
							<font class="bashcommand-result">abcdef</font>
						</font></p>
						<p><font class="bashcommand">
							$ printf "%b" "abc\bdef"<br>
							<font class="bashcommand-result">abdef</font>
						</font></p>
					</td>
					</tr>

					<tr>
					<td><font class="bashcommand">\c</font></td>
					<td> </td>
					</tr>

					<tr>
					<td><font class="bashcommand">\n</font></td>
					<td> 
						<p>Write a new-line character.</p>
						<p><font class="bashcommand">
							$ printf "%b" "abc\ndef"<br>
							<font class="bashcommand-result">
							abc<br>
							def
							</font>
						</font></p>
					</td>
					</tr>

					<tr>
					<td><font class="bashcommand">\r</font></td>
					<td>Write a &lt;carriage return&gt; character.</td>
					</tr>

					<tr>
					<td><font class="bashcommand">\t</font></td>
					<td> 
						<p>Write a &lt;tab&gt; character.</p>
						<p><font class="bashcommand">
							$ printf "%b" "abc\tdef"<br>
							<font class="bashcommand-result">abc   def</font>
						</font></p>
					</td>
					</tr>

					<tr>
					<td><font class="bashcommand">\v</font></td>
					<td> 
						<p>Write a &lt;vertical tab&gt; character.</p>
						<p><font class="bashcommand">
							$ printf "%b" "abc\vdef"<br>
							<font class="bashcommand-result">
							abc<br>
							   def 
							</font>
						</font></p>
					</td>
					</tr>

					<tr>
					<td><font class="bashcommand">\'</font></td>
					<td>Write a single quote character.</td>
					</tr>

					<tr>
					<td><font class="bashcommand">\\</font></td>
					<td>Write a backslash character.</td>
					</tr>

					<tr>
					<td><font class="bashcommand">\num</font></td>
					<td>Write a byte whose value is the 1-, 2-, or 3-digit octal number <font class="bashcommand">num</font>. Multibyte characters can be constructed using multiple \num sequences.</td>
					</tr>
				</table>

				<p>Each format specification is introduced by the percent character (<font class="bashcommand">%</font>), followed by the following fields (in the exact order). You must use one format specification for each argument (in the same order):</p>
			
				<table>
					<tr>
						<th>Flag</th>
						<th>Meaning</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">#</font></td>
						<td> 
							<p>When printing an octal number: Inserts a 0 prefix.</p>
							<p>(234)<sub>10</sub> = (352)<sub>8</sub></p>
							<p><font class="bashcommand">
								$ printf "%o\n%#o\n" 234 234<br>
								<font class="bashcommand-result">
								352<br>
								0352 
								</font>
							</font></p>
							<p>When printing a hexadecimal number: Inserts a 0x prefix.</p>
							<p>Given that (234)<sub>10</sub> = (EA)<sub>16</sub></p>
							<p><font class="bashcommand">
								$ printf "%x\n%#x\n" 234 234<br>
								<font class="bashcommand-result">
								ea<br>
								0xea 
								</font>
							</font></p>
							<p>When printing numbers using formats e (E), f (F) or g (G): Show the decimal point.</p>
						</td>
					</tr>	
					
					<tr>
						<td><font class="bashcommand">-</font></td>
						<td>Left justify.</td>
					</tr>	
					
					<tr>
						<td><font class="bashcommand">+</font></td>
						<td>Place a sign before the number when using signed formats.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand"> </font></td>
						<td>&lt;blank space&ht; Positive values begin with a blank. </td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">0</font></td>
						<td>Field is padded with zeros instead of blanks.</td>
					</tr>
				</table>

				<p>Field width or precision: An integer number preceded by a period (<font class="bashcommand">.</font>) or an asterisk (<font class="bashcommand">*</font>). If a number is given, it will represent the number of characters or digits to print if the argument is a string or a number (respectively). If an asterisk is given instead of a number, the field width or precision will be specified as another argument.</p>

				<p><font class="bashcommand">
				$ printf "%s\n" "qwertyuiop"<br>
				<font class="bashcommand-result">qwertyuiop</font>
				</font></p>

				<p><font class="bashcommand">
				$ printf "%.4s\n" "qwertyuiop"<br>
				<font class="bashcommand-result">qwer</font>
				</font></p>

				<p><font class="bashcommand">
				$ printf "%.*s\n" 6 "qwertyuiop"<br>
				<font class="bashcommand-result">qwerty</font>
				</font></p>
				
				<p>Format: This is a character that indicates the type of format that should be used to print the arguments. The character options are listed in the following table.</p>

				<table>
					<tr>
						<th>Character</th>
						<th>Format</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">%</font></td>
						<td> 
							<p>Prints the symbol <font class="bashcommand">%</font>. No argument is used</p>
							<p><font class="bashcommand">
							$ printf "%%"<br>
							<font class="bashcommand-result">%</font>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%% %s" "Some string"<br>
							<font class="bashcommand-result">% Some string</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">a</font> or <font class="bashcommand">A</font></td>
						<td>Prints the argument in floating-point, hexadecimal form. The style used is <font class="bashcommand">[-h.hhh+-pd]</font>. Most probably you will never need to use this format other than for technical purposes.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">b</font></td>
						<td> 
							<p>Same as <font class="bashcommand">s</font>, but interprets the character scape sequences instead of reading them as literal strings.</p>
							<p><font class="bashcommand">
							$ printf "%s" "text\ntext"<br> 
							<font class="bashcommand-result">text\ntext</font><br>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%b" "text\ntext"<br>
							<font class="bashcommand-result">
							text<br>
							text 
							</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">c</font></td>
						<td>
							<p>The first byte of the argument is printed. Which will correspond to the first character if the argument is a string, or the first digit if it is a number.</p>
							<p><font class="bashcommand">
							$ printf "%c %c" "some string" 199<br>
							<font class="bashcommand-result">s 1</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">d</font> or <font class="bashcommand">i</font></td>
						<td> 
							<p>The argument must be a positive or negative integer. If no precision is specified, it just prints the number, otherwise it adds zeros before the integer to achieve the number of digits specified in the precision.</p>
							<p><font class="bashcommand">
							$ printf "%d\n%i\n" 2 -2<br>
							<font class="bashcommand-result">
							2<br>
							-2 
							</font>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%.3d\n%.5i\n" -2 2<br>
							<font class="bashcommand-result">
							-002<br>
							00002 
							</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">e</font> or <font class="bashcommand">E</font></td>
						<td> 
							<p>Writes the number in the argument in scientific notation, with format <font class="bashcommand">[-]d.ddde+-dd</font>. There will be one digit before the decimal point and six digits after the decimal point if no precision is specified (or the number of digits specified in the precision). Infinity is printed as <font class="bashcommand">inf</font> and <font class="bashcommand">NaN</font> as <font class="bashcommand">nan</font>. If the flag is in upper case, the <font class="bashcommand">e</font> of the output will be printed in capital letter.</p>
							<p>234.567 equals 2.34567 × 102 in scientific notation. So, <font class="bashcommand">printf</font> would print that number in the following way:</p>
							<p><font class="bashcommand">
							$ printf "%e" 234.567<br> 
							<font class="bashcommand-result">2.345670e+02</font>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%.1e" 234.567<br>
							<font class="bashcommand-result">2.3e+02</font>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%.1E" 234.567<br> 
							<font class="bashcommand-result">2.3E+02</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">f</font> or <font class="bashcommand">F</font></td>
						<td> 
							<p>Prints the argument as a floating-point number with the format <font class="bashcommand">[-]ddd.ddd</font>. The number of digits after the decimal point equals the precision specification for the argument or six digits if no precision was specified. Infinity is printed as <font class="bashcommand">inf</font> and <font class="bashcommand">NaN</font> as <font class="bashcommand">nan</font>.</p>
							<p><font class="bashcommand">
							$ printf "%f\n" 2.34567890123<br>
							<font class="bashcommand-result">2.345679</font>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%.3f\n" -2.34567890123<br>
							<font class="bashcommand-result">-2.346</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">g</font> or <font class="bashcommand">G</font></td>
						<td> 
							<p>The argument is printed in style <font class="bashcommand">f</font> (<font class="bashcommand">F</font>) or in style <font class="bashcommand">e</font> (<font class="bashcommand">E</font>) whichever gives full precision in minimum space.</p>
							<p><font class="bashcommand">
							$ printf "%g\n%g\n" 238.567 0.000001<br> 
							<font class="bashcommand-result">
							238.567<br> 
							1e-06 
							</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">o</font></td>
						<td> 
							<p>The argument must be a positive integer. Prints the octal value of the argument. it adds zeros before the octal to achieve the number of digits specified in the precision.</p>
							<p>Given that (234)<sub>10</sub> = (352)<sub>8</sub></p>
							<p><font class="bashcommand">
							$ printf "%o\n%.4o\n" 234 234<br> 
							<font class="bashcommand-result">
							352<br> 
							0352 
							</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">s</font></td>
						<td> 
							<p>Prints the string specified in the argument. It will stop when the number of characters specified in the precision is reached or at the end of the string if the precision is not specified (or if the string has less characters than the precision).</p>
							<p><font class="bashcommand">
							$ printf "%s" "example"<br> 
							<font class="bashcommand-result">example</font>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%.3s" "example"<br> 
							<font class="bashcommand-result">exa</font>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%.10s" "example"<br> 
							<font class="bashcommand-result">example</font> 
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">u</font></td>
						<td> 
							<p>The argument must be a positive integer. If no precision is specified, it just prints the number, otherwise it adds zeros before the integer to achieve the number of digits specified in the precision.</p>
							<p><font class="bashcommand">
							$ printf "%u\n%.5u\n" 2 2<br> 
							<font class="bashcommand-result">
							2<br> 
							00002
							</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">x</font> or <font class="bashcommand">X</font></td>
						<td> 
							<p>The argument should be a positive integer. Prints the hexadecimal value of the argument. If any precision is specified, it adds zeros before the hexadecimal to achieve the number of digits specified in the precision.</p>
							<p>Given that (234)<sub>10</sub> = (EA)<sub>16</sub></p>
							<p><font class="bashcommand">
							$ printf "%x\n%X\n%.4x\n" 234 234 234<br>
							<font class="bashcommand-result">
							ea<br>
							EA<br>
							00ea 
							</font>
							</font></p>
						</td>
					</tr>
				</table>

				<p>You can save the output of <font class="bashcommand">printf</font> into a variable instead of printing it. For example, if you have a number in scientific notation and you want to convert it to floating, you can type the following:</p>
			
				<p><font class="bashcommand">
				$ FLOAT=$(printf "%f" 2.345670e+02)<br>
				$ echo $FLOAT<br>
				<font class="bashcommand-result">234.567000</font> 
				</font></p>

			<h3>9.2. Reading files</h3>
		    		<p>
				<font class="example">Read line by line using the for loop and the cat command</font>
				The <font class="bashcommand">cat</font> command, followed by the path of a file, can be used to visualize the content of the file in the command line:
				</p>

				<p><font class="bashcommand">
				$ cat /Volumes/MylDrive/MRIdata/subjectList.txt<br>
				<font class="bashcommand-result">
				AA0083277<br> 
				AA0084999<br> 
				AC0208933<br> 
				AC0148099<br> 
				AD0190300<br> 
				BB0299033<br> 
				BC0345100<br> 
				BD0365666<br> 
				CA0372599<br> 
				CA0381677<br> 
				CB0384399<br> 
				CC0384433<br> 
				DD0385444<br>
				... 
				</font>
				</font></p>

				<p>Moreover, if you want to read line by line and run a set of instructions on each line, you can combine the <font class="bashcommand">cat</font> and <font class="bashcommand">for</font> commands.</p>
		    
				<p>
				<font class="example">Read line by line the previous file</font>
				Read line by line the previous file (<font class="bashcommand">subjectList.txt</font>), which contain a list of subject IDs. And copy into a new file (<font class="bashcommand">subjectInfo.txt</font>) the subject IDs plus the group they belong to (which can be obtained from the first two letters in the subject ID). 
				</p>

				<p><font class="bashcommand">
				$ FOLDER=/Volumes/MyExternalDrive/MRIdata<br>
				$ for line in $(cat $FOLDER/subjectList.txt)<br>
				&gt; do<br>
				&gt; echo "${line:0:2},${line}" &gt;&gt; $FOLDER/subjectInfo.txt<br>
				&gt; done 
				</font></p>

				<p>In this example, I am reading one line of <font class="bashcommand">subjectList.txt</font> on every loop and assigning that line of text to the variable line (the variable could have had any other name). Then, I am extracting the first two characters in <font class="bashcommand">$line</font> (which represent the subject group) and saving that information, together with the subject ID, into a new file (<font class="bashcommand">subjectInfo.txt</font>). I am using <font class="bashcommand">${line:0:2}</font> to extract the first two characters of <font class="bashcommand">$line</font>. If I now print the content of the new file, this is what it will contain:</p>
		    
				<p><font class="bashcommand">
				$ cat /Volumes/MyExternalDrive/MRIdata/subjectInfo.txt  
				<font class="bashcommand-result">
				AA,AA0083277<br> 
				AA,AA0084999<br>
				AC,AC0208933<br>
				AC,AC0148099<br>
				AD,AD0190300<br>
				BB,BB0299033<br>
				BC,BC0345100<br>
				BD,BD0365666<br>
				CA,CA0372599<br>
				CA,CA0381677<br>
				CB,CB0384399<br>
				CC,CC0384433<br>
				DD,DD0385444 
				</font>
				</font></p>

				<p>
					<font class="example">Do statistics on the numerical values of a column from a text file</font>
					infoFile.txt is a file that contains some information from a list of subjects. This is the content of the file: 
				</p>
					<table class="ghostTable">
						<tr>
							<td>SubjectID</td>
							<td>Group</td>
							<td>Gender</td>
							<td>Ethnicity</td>
							<td>Handedness</td>
							<td>Age</td>
							<td>Movement</td>
						</tr>
						
						<tr>
							<td>AA0083277</td>
							<td>Control</td>
							<td>M</td>
							<td>Hispanic</td>
							<td>R</td>
							<td>20</td>
							<td>0.23525</td>
						</tr>
						
						<tr>
							<td>AA0084999</td>
							<td>Patient</td>
							<td>M</td>
							<td>Hispanic</td>
							<td>R</td>
							<td>18</td>
							<td>0.14564</td>
						</tr>
						
						<tr>
							<td>AC0208933</td>
							<td>Control</td>
							<td>F</td>
							<td>Hispanic</td>
							<td>R</td>
							<td>17</td>
							<td>0.18698</td>
						</tr>
						
						<tr>
							<td>AC0148099</td>
							<td>Control</td>
							<td>M</td>
							<td>NonHispanic</td>
							<td>R</td>
							<td>21</td>
							<td>0.19789</td>
						</tr>
						
						<tr>
							<td>AD0190300</td>
							<td>Patient</td>
							<td>M</td>
							<td>NonHispanic</td>
							<td>R</td>
							<td>16</td>
							<td>0.23454</td>
						</tr>
						
						<tr>
							<td>BB0299033</td>
							<td>Control</td>
							<td>F</td>
							<td>NonHispanic</td>
							<td>R</td>
							<td>22</td>
							<td>0.19752</td>
						</tr>
						
						<tr>
							<td>BC0345100</td>
							<td>Control</td>
							<td>M</td>
							<td>NonHispanic</td>
							<td>R</td>
							<td>19</td>
							<td>0.18789</td>
						</tr>
						
						<tr>
							<td>BD0365666</td>
							<td>Patient</td>
							<td>F</td>
							<td>NonHispanic</td>
							<td>R</td>
							<td>17</td>
							<td>0.14386</td>
						</tr>
						
						<tr>
							<td>CA0372599</td>
							<td>Patient</td>
							<td>F</td>
							<td>NonHispanic</td>
							<td>R</td>
							<td>20</td>
							<td>0.12384</td>
						</tr>
						
						<tr>
							<td>CA0381677</td>
							<td>Control</td>
							<td>F</td>
							<td>NonHispanic</td>
							<td>L</td>
							<td>17</td>
							<td>0.13453</td>
						</tr>
						
						<tr>
							<td>CB0384399</td>
							<td>Control</td>
							<td>F</td>
							<td>Hispanic</td>
							<td>R</td>
							<td>18</td>
							<td>0.45655</td>
						</tr>
						
						<tr>
							<td>CC0384433</td>
							<td>Control</td>
							<td>M</td>
							<td>NonHispanic</td>
							<td>R</td>
							<td>15</td>
							<td>0.13465</td>
						</tr>
						
						<tr>
							<td>DD0385444</td>
							<td>Patient</td>
							<td>M</td>
							<td>Hispanic</td>
							<td>R</td>
							<td>16</td>
							<td>0.32433</td>
						</tr>
					</table>

				<p>In this example we will calculate the minimum, maximum and average movement in the MRI scanner for the subjects in each group and gender. These values should be shown with only three decimals. There are many ways to do that, some of them a lot more efficient than the one presented here, using functions that we have not learn yet. We will use in this case the cat command to read from the file, the <font class="bashcommand">for</font> loop, and some non-integer and array operations that have been learned from previous chapters.</p>
		    
				<p>The <font class="bashcommand">for</font> will read in each loop one line of the csv file and extract the gender, group and movement values from each line. Depending the group and gender, it will add the movement to one of the following arrays:</p>

				<p>
				CM: to save the movement of all male controls.<br>
				CF: to save the movement of all female controls.<br>
				PM: to save the movement of all male patients.<br>
				PF: to save the movement of all female patients. 
				</p>

				<p>In bash it is not necessary to initialize an array. Instead, you can start adding values and the first time you add a value to a non-existent array, it will be automatically initialized. When you ask bash the size of an array that hasn’t been initialized, it will return the value zero.</p>

				<p>These are the steps to follow in order to calculate the minimum, maximum and average movement from the file:</p>

				<dl>
				<dt>1. Create a loop that reads each line of the file (except the first one which is just a heather with column names).</dt>
				<dt>2. In each loop do the following:</dt>
					<dd>2.1. Split the line using the comma as a separator and save that in a variable called <font class="bashcommand">ARRAY</font>.</dd>
					<dd>2.2. Obtain the subject group, which is located in the 2<sup>nd</sup> column (position 1 of the array). Remember, bash arrays start in the position 0 (not the position 1).</dd>
					<dd>2.3. Obtain the subject gender, which is located in the 3<sup>rd</sup> column (position 2 of the array).</dd>
					<dd>2.4. Obtain the subject movement, which is located in the 7<sup>th</sup> column (position 6 of the array).</dd>
					<dd>
						<p style="margin-left: 40px">
						&bull; If group equals "Control" and gender equals "M" (Male):<br>
						Add the movement at the end of the array CM. If CM has zero values, the new item should be added to the position 0, if CM has one value, the new item should be added to the position 1 (because the existent item in the array will be in the position 0), and so on. So, every new item is added to the position that is equal to the current size of the array. As a reminder, the size of an array can be obtained with <font class="bashcommand">${#array[@]}</font>.
						</p>
					</dd>
					<dd>
						<p style="margin-left: 40px">
						&bull; If group equals "Control" and gender equals "F" (Female):<br>
						Add the movement at the end of the array CF.
						</p>
					</dd>
					<dd>
						<p style="margin-left: 40px">
						&bull; If group equals "Patient" and gender equals "M":<br>
						Add the movement at the end of the array PM.
						</p>
					</dd>
					<dd>
						<p style="margin-left: 40px">
						&bull; If group equals "Patient" and gender equals "F":<br>
						Add the movement at the end of the array PF. 
						</p>
					</dd>
				<dt>3. Sort the four arrays with the previously learned command: <font class="bashcommand">IFS=$'\n' sorted=($(sort <<<"${array[*]}"))</font></dt>
				<dt>4. Show the minimum, maximum and average value of each array. Use <font class="bashcommand">printf</font> instead of <font class="bashcommand">echo</font> in order to show only three decimals per number:</dt>
					<dd><u>Minimum value</u>: will be the first value in the sorted array.</dd>
					<dd><u>Maximum value</u>: will be the last value in the sorted array (in the position <font class="bashcommand">SIZE_ARRAY</font> – 1).</dd>
					<dd><u>Average value</u>: will equal to the sum of all values divided by the size of the array. As a reminder, this is the general command used to calculate the average of an array, as shown in previous chapters: <font class="bashcommand">IFS='+' avg=$(echo "scale=1;(${array[*]})/${#array[@]}"|bc)</font>.</dd>
				</dl>

				<p><font class="bashcommand">
				$ n=0<br>
				$ for line in $(cat infoFile.csv)<br>
				&gt; do<br>
				&gt; if [ $((n++)) -gt 0 ]<br>
				&gt; then<br>
				&gt; IFS=',' read -a ARRAY &lt;&lt;&lt; "${line}"<br>
				&gt; GRP=${ARRAY[1]}<br>
				&gt; GEN=${ARRAY[2]}<br>
				&gt; MOV=${ARRAY[6]}<br>
				&gt; if [ "$GRP" == "Control" ] && [ "$GEN" == "M" ]<br>
				&gt; then<br>
				&gt; CM[${#CM[@]}]=${MOV}<br>
				&gt; fi<br>
				&gt; if [ "$GRP" == "Control" ] && [ "$GEN" == "F" ]<br>
				&gt; then<br>
				&gt; CF[${#CF[@]}]=${MOV}<br>
				&gt; fi<br>
				&gt; if [ "$GRP" == "Patient" ] && [ "$GEN" == "M" ] 
				&gt; then<br>
				&gt; PM[${#PM[@]}]=${MOV}<br>
				&gt; fi<br>
				&gt; if [ "$GRP" == "Patient" ] && [ "$GEN" == "F" ]<br>
				&gt; then<br>
				&gt; PF[${#PF[@]}]=${MOV}<br>
				&gt; fi<br>
				&gt; fi<br>
				&gt; done 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedCM=($(sort &lt;&lt;&lt;"${CM[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${CM[*]})/${#CM[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedCM[0]} ${sortedCM[${#sortedCM[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedCF=($(sort &lt;&lt;&lt;"${CF[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${CF[*]})/${#CF[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedCF[0]} ${sortedCF[${#sortedCF[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedPM=($(sort &lt;&lt;&lt;"${PM[*]}"))<br> 
				$ IFS='+' avg=$(echo "scale=4;(${PM[*]})/${#PM[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedPM[0]} ${sortedPM[${#sortedPM[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedPF=($(sort &lt;&lt;&lt;"${PF[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${PF[*]})/${#PF[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedPF[0]} 
				</font></p>

				<p>The number of lines of the previous code could be reduced by simplifying the <font class="bashcommand">if</font> expressions. The code below is equivalent to the code above:</p>

				<p><font class="bashcommand">
				$ n=0<br>
				$ for line in $(cat infoFile.csv)<br>
				&gt; do<br>
				&gt; if [ $((n++)) -gt 0 ]<br>
				&gt; then<br>
				&gt; IFS=',' read -a ARRAY &lt;&lt;&lt; "${line}"<br>
				&gt; GRP=${ARRAY[1]}<br>
				&gt; GEN=${ARRAY[2]}<br>
				&gt; MOV=${ARRAY[6]}<br>
				&gt; [ "$GRP" == "Control" ] && [ "$GEN" == "M" ] && CM[${#CM[@]}]=${MOV}<br>
				&gt; [ "$GRP" == "Control" ] && [ "$GEN" == "F" ] && CF[${#CF[@]}]=${MOV}<br>
				&gt; [ "$GRP" == "Patient" ] && [ "$GEN" == "M" ] && PM[${#PM[@]}]=${MOV}<br>
				&gt; [ "$GRP" == "Patient" ] && [ "$GEN" == "F" ] && PF[${#PF[@]}]=${MOV}<br>
				&gt; fi<br>
				&gt; done 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedCM=($(sort &lt;&lt;&lt;"${CM[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${CM[*]})/${#CM[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedCM[0]} ${sortedCM[${#sortedCM[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedCF=($(sort &lt;&lt;&lt;"${CF[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${CF[*]})/${#CF[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedCF[0]} ${sortedCF[${#sortedCF[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedPM=($(sort &lt;&lt;&lt;"${PM[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${PM[*]})/${#PM[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedPM[0]} ${sortedPM[${#sortedPM[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedPF=($(sort &lt;&lt;&lt;"${PF[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${PF[*]})/${#PF[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedPF[0]} 
				</font></p>

				<p>You could reduce even more the number of lines in the code:</p>

				<p><font class="bashcommand">
				$ n=0<br>
				$ for line in $(cat infoFile.csv)<br>
				&gt; do<br>
				&gt; if [ $((n++)) -gt 0 ]<br>
				&gt; then<br>
				&gt; IFS=',' read -a ARRAY &lt;&lt;&lt; "${line}"<br>
				&gt; [ "${ARRAY[1]}" == "Control" ] && [ "${ARRAY[2]}" == "M" ] && CM[${#CM[@]}]=${ARRAY[6]}<br>
				&gt; [ "${ARRAY[1]}" == "Control" ] && [ "${ARRAY[2]}" == "F" ] && CF[${#CF[@]}]=${ARRAY[6]}<br>
				&gt; [ "${ARRAY[1]}" == "Patient" ] && [ "${ARRAY[2]}" == "M" ] && PM[${#PM[@]}]=${ARRAY[6]}<br>
				&gt; [ "${ARRAY[1]}" == "Patient" ] && [ "${ARRAY[2]}" == "F" ] && PF[${#PF[@]}]=${ARRAY[6]}<br>
				&gt; fi<br>
				&gt; done 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedCM=($(sort &lt;&lt;&lt;"${CM[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${CM[*]})/${#CM[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedCM[0]} ${sortedCM[${#sortedCM[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedCF=($(sort &lt;&lt;&lt;"${CF[*]}"))<br> 
				$ IFS='+' avg=$(echo "scale=4;(${CF[*]})/${#CF[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedCF[0]} ${sortedCF[${#sortedCF[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedPM=($(sort &lt;&lt;&lt;"${PM[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${PM[*]})/${#PM[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedPM[0]} ${sortedPM[${#sortedPM[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedPF=($(sort &lt;&lt;&lt;"${PF[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${PF[*]})/${#PF[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedPF[0]} 
				</font></p>

				<p>In the previous example we read line by line a file using a for loop and the cat utility. This works most of the times. However, if you try to read this way a file in which one or more of the lines contain a space, bash will read each word separated by a space as a separate line.</p>

				<p>
				For example, if file test.txt has the following content:<br>
				a b<br>
				c d<br>
				e f<br>
				g h<br>
				i j 
				</p>

				<p>When you try to read each line using a file, this is the result you will get:</p>

				<p><font class="bashcommand">
				$ for line in $(cat test.txt)<br>
				&gt; do<br>
				&gt; echo $((i++)) $line<br>
				&gt; done<br>
				<font class="bashcommand-result">
				0 a<br>
				1 b<br>
				2 c<br>
				3 d<br>
				4 e<br>
				5 f<br>
				6 g<br>
				7 h<br>
				8 i<br>
				9 j 
				</font>
				</font></p>

				<p>To fix this problem you have to tell bash that newline (<font class="bashcommand">\n</font>) is the only separator. You do this by declaring the system variable <font class="bashcommand">IFS=$'\n'</font>.</p>

				<p><font class="bashcommand">
				$ IFS=$'\n'<br>
				$ for line in $(cat test.txt)<br>
				&gt; do<br>
				&gt; echo $((i++)) $line<br>
				&gt; done<br>
				<font class="bashcommand-result">
				0 a b<br>
				1 c d<br>
				2 e f<br>
				3 g h<br>
				4 i j 
				</font>
				</font></p>
			    
			    	<p>
				<font class="example">Load the content of a file into an array and access a specific line separately</font>
				<font class="bashcommand">
				$ ARRAY=($(cat test.txt))<br>
				$ echo ${ARRAY[0]}<br>
				<font class="bashcommand-result">a b</font><br>
				$ echo ${ARRAY[1]}<br>
				<font class="bashcommand-result">c d</font><br>
				$ echo ${ARRAY[2]}<br>
				<font class="bashcommand-result">e f</font><br>
				$ echo ${ARRAY[3]}<br>
				<font class="bashcommand-result">g h</font><br>
				$ echo ${ARRAY[4]}<br>
				<font class="bashcommand-result">i j</font>
				</font>
			    	</p>
			    
			<h3>9.3. Using the read command for more complex csv files</h3>
			    	<p>So far, we have learned that using the <font class="bashcommand">for</font> loop and the cat utility you can read each line of a file and separate it into different fields using a separator. However, csv files can become very difficult to separate into fields if some of them contain a comma (the same character that is being used as a separator), a space, or both. </p>
			    
			    	<p>
				<font class="example">Example: Obtain the last field of <font class="bashcommand">$line</font> using the concepts learned before.</font>
				<font class="bashcommand">
				$ line="SUBJ20"," Age 22-30","VISIT1","1","DIAGN: Major Depressive Disorder, Single Episode, In Full Remission"<br>
				$ IFS=',' read -a ARRAY &gt;&gt;&gt; "$line"<br>
				$ echo "The last field of line is: "${ARRAY[4]}<br>
				<font class="bashcommand-result">The last field of line is: DIAGN: Major Depressive Disorder</font>
				</font>
			    	</p>
			    
			    	<p>However, this is not the correct result. The last field of <font class="bashcommand">$line</font> is <font class="bashcommand">"DIAGN: Major Depressive Disorder, Single Episode, In Full Remission"</font>. But because we are using a comma as a separator, bash is separating this field into separate columns. To solve this problem, you can read from the file descriptor and save each field in a separate variable using the <font class="bashcommand">read</font> utility.</p>
			    
			    	<p>
				The first step is to assign a file descriptor (which must be an integer number) to the input file:<br>
				<font class="bashcommand">$ exec 3&lt; $INPUT_FILE</font>
				</p>
			    
			    	<p>
				Then, to read each line of the file and save each field in a different variable:<br>
				<font class="bashcommand">$ read -u 3 a b</font>
			    	</p>
			    
			    	<p>
				The previous command will read the next line of the input file with descriptor 3 (the number following flag <font class="bashcommand">-u</font>) and save the first field in variable a and the rest of the line in variable <font class="bashcommand">b</font>.<br>
				<font class="bashcommand">$ read -u 3 a b c</font>
			    	</p>
			    
			    	<p>
				The previous command will read the next line of the input file with descriptor 3 and save the first field in variable <font class="bashcommand">a</font>, the second field in variable <font class="bashcommand">b</font>, and the rest of the line in variable <font class="bashcommand">c</font> (variable <font class="bashcommand">c</font> would be empty if there are no more fields to read). If you want to separate the fields using comma as a separator, you should use the following command instead:<br>
				<font class="bashcommand">$ IFS=',' read -u 3 a b c d</font>
			    	</p>
			    
			    	<p>
				If one of the columns contains a comma but is surrounded by quotation marks, then it will read the text inside the quotation marks as a single field. In the example before, it will read the following text as the last field: <font class="bashcommand">$ "DIAGN: Major Depressive Disorder, Single Episode, In Full Remission"</font>.<br>
				Each time you type the command <font class="bashcommand">$ FS=',' read -u 3 a b c d</font> it will read the following line. 
			    	</p>
			    
			    	<p>
				<font class="example">Read each line of a file and save the first and last fields into a new file</font>
				Given the file example.csv with the following content:<br>
				"SUBJ1","Age 22-30","VISIT1","DIAGN: Major Depressive Disorder, Single Episode"<br>
				"SUBJ2","Age 22-30","VISIT1","DIAGN: Bipolar, Schizophrenia"<br>
				"SUBJ3","Age 22-30","VISIT1","DIAGN: Major Depressive Disorder"<br>
				"SUBJ4","Age 22-30","VISIT1","DIAGN: Autism, Dyslexia, ADHD"<br>
				Read each line of the file and save the first and last fields into a new file called result.csv. 
			    	</p>
			    
			    	<p>
				<ol>
					<li>
					Assign the file descriptor 3 to example.csv for input<br>
					<font class="bashcommand">$ exec 3&lt; example.csv</font>
					</li>
					
					<li>
					Obtain the number of lines in the input file.<br>
					<font class="bashcommand">
					$ N=$(cat example.csv | wc -l)<br>
					$ echo $N 
					</font>
					</li>
					
					<li>
					Iterate through all the lines of the file saving each field in a different variable. Then, write the value of the first and last fields into the output file.<br> 
					<font class="bashcommand">
					$ i=0<br>
					$ while [ $((i++)) -lt $N ]<br> 
					&gt; do<br> 
					&gt; IFS=',' read -u 3 f1 f2 f3 f4<br> 
					&gt; echo  "$f1,$f4" &gt;&gt; result.csv<br> 
					&gt; done 
					</font>
					</li>
					
					<li>
					You must close the file descriptor using the following command (replace number 3 by the corresponding file descriptor):<br> 
					<font class="bashcommand">
					$ exec 3&lt;&- 
					</font>
					</li>
					
					<li>
					Read the content of the output file.<br> 
					<font class="bashcommand">
					$ cat result.csv<br> 
					<font class="bashcommand-result">
					"SUBJ1","Age 22-30","VISIT1","DIAGN: Major Depressive Disorder, Single Episode"<br> 
					"SUBJ2","Age 22-30","VISIT1","DIAGN: Bipolar, Schizophrenia"<br> 
					"SUBJ3","Age 22-30","VISIT1","DIAGN: Major Depressive Disorder"<br> 
					"SUBJ4","Age 22-30","VISIT1","DIAGN: Autism, Dyslexia, ADHD" 
					</font>
					</font>
					</li>
			    	</ol>
			    	</p>

			<h3>9.4 Reading comma-separated CSV files using the read utility but no file descriptor</h3>

			<p>In the following example we are going to read a csv file called example.csv. The file has five columns (five fields per line). We are going to use the <font class="bashcommand">while</font> loop to iterate through each line of the csv file and save the fields in variables <font class="bashcommand">f1</font>, <font class="bashcommand">f2</font>, <font class="bashcommand">f3</font>, <font class="bashcommand">f4</font>. Before starting to iterate, we have to tell bash that comma (<font class="bashcommand">,</font>) will be the separator in each line: <font class="bashcommand">IFS=','</font>.</p>

			<p><font class="bashcommand">
			$ IFS=','<br> 
				$ i=1<br>
				$ while read f1 f2 f3 f4<br> 
				&gt; do<br>  
				&gt; echo "Line $((i++)):"<br> 
				&gt; echo "Field 1: $f1"<br> 
				&gt; echo "Field 2: $f2"<br> 
				&gt; echo "Field 3: $f3"<br> 
				&gt; echo "Field 4: $f4"<br> 
				&gt; done &lt; example.csv<br> 
				<font class="bashcommand-result">
				Line 1:<br> 
				Field 1: "SUBJ1"<br> 
				Field 2: "Age 22-30"<br> 
				Field 3: "VISIT1"<br> 
				Field 4: "DIAGN: Major Depressive Disorder, Single Episode"<br> 
				Line 2:<br> 
				Field 1: "SUBJ2"<br> 
				Field 2: "Age 22-30"<br> 
				Field 3: "VISIT1"<br> 
				Field 4: "DIAGN: Bipolar, Schizophrenia"<br> 
				Line 3:<br> 
				Field 1: "SUBJ3"<br> 
				Field 2: "Age 22-30"<br> 
				Field 3: "VISIT1"<br> 
				Field 4: "DIAGN: Major Depressive Disorder"<br> 
				Line 4:<br> 
				Field 1: "SUBJ4"<br> 
				Field 2: "Age 22-30"<br> 
				Field 3: "VISIT1"<br> 
				Field 4: "DIAGN: Autism, Dyslexia, ADHD" 
				</font>
		    		</font></p>

		    	<h3>9.5. The awk command</h3>
		    		<p><font class="bashcommand">awk</font> is a bash program that scans files and process their content using patterns. It reads each line of a file or a group of files searching for the specified pattern and each time that it finds the pattern, it performs an associated action. This tool can extract specific lines or columns from files, merge files, search the content of one file in the other, etc.</p>
		    		
				<p>When reading each line of the specified files, <font class="bashcommand">awk</font> will separate it into fields (columns) using the blank space as a separator. If your file uses a different separator (i.e. a comma). Then you must specify your separator using the <font class="bashcommand">-F</font> flag (see syntax below). The different fields will be denoted <font class="bashcommand">$1</font>, <font class="bashcommand">$2</font>, <font class="bashcommand">$3</font>... etc. <font class="bashcommand">$0</font> will refer to the entire line. If the field separator (<font class="bashcommand">FS</font>) is null, each line will be split into one field per character.</p>

				<p>Syntax: <font class="bashcommand">awk [ -F fs ] [ -v var=value ] [ 'pattern {action}' ] [ files ] | [ other functions ]</font></p>

				<table>
					<tr>
						<th>Flag</th>
						<th>Meaning</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-F fs (optional)</font></td>
						<td>Defines the input field separator to be the regular expression <font class="bashcommand">fs</font>. Use this flag when the columns of your file use a separator other than a space. See examples below.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-v var=variableName (optional)</font></td>
						<td>When the value that is being search is stored in a variable, you should use this flag. See below for examples on how to use this flag.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">files</font></td>
						<td>List of files to be searched.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">other functions</font> (optional)</td>
						<td>You can apply to the output of <font class="bashcommand">awk</font> other functions such as <font class="bashcommand">head</font>, <font class="bashcommand">tail</font>, <font class="bashcommand">paste</font>, <font class="bashcommand">grep</font>, etc (some of them explained below and in the examples section)</td>
					</tr>
				</table>

		    	<h3>9.6. The grep command</h3>
		    		<p>Searches a given pattern or text in a file or list of files. <font class="bashcommand">grep</font> is is able to find simple patterns and basic regular expressions, <font class="bashcommand">egrep</font> can perform search of extended regular expressions. <font class="bashcommand">fgrep</font> is quicker than both tools but can only handle fixed patterns. <font class="bashcommand">zgrep</font>, <font class="bashcommand">zegrep</font>, and <font class="bashcommand">zfgrep</font> act like <font class="bashcommand">grep</font>, <font class="bashcommand">egrep</font>, and <font class="bashcommand">fgrep</font>, respectively, but accept compressed files as input.</p>
		    
				<p>Syntax: <font class="bashcommand">grep [flag] [pattern] [file(s)]</font></p>

				<p>
				<table>
					<tr>
						<th>grep format</th>
						<th>meaning</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep string files</font></td>
						<td>Searches the list of <font class="bashcommand">files</font> for lines that <u>contain</u> <font class="bashcommand">string</font>. See examples here.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep '^expression' files</font></td>
						<td> 
							<p>Search for any lines that <u>start with</u> <font class="bashcommand">expression</font> in the list of <font class="bashcommand">files</font>. If <font class="bashcommand">expression</font> contains a back slash (<font class="bashcommand">\</font>), the special meaning of the next special character is turned off. If <font class="bashcommand">expression</font> contains a dot (<font class="bashcommand">.</font>) that is not preceded by a black slash, it will match a single character of any value in the position of the dot.</p>
							
							<p>e.i. <font class="bashcommand">grep '^string' file.txt</font> will search for any lines in <font class="bashcommand">file.txt</font> that start with <font class="bashcommand">string</font>. See more examples here.</p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep 'expression$' files</font></td>
						<td> 
							<p>Search for any lines that <u>end with</u> <font class="bashcommand">expression</font> in the list of <font class="bashcommand">files</font>. If <font class="bashcommand">expression</font> contains a back slash (<font class="bashcommand">\</font>), the special meaning of the next special character is turned off. If <font class="bashcommand">expression</font> contains a dot (<font class="bashcommand">.</font>) that is not preceded by a black slash, it will match a single character of any value in the position of the dot.</p>
							
							<p>
							Examples:<br>
							<font class="bashcommand">grep 'string$' file</font> matches any lines in <font class="bashcommand">file</font> that end with <font class="bashcommand">string</font>. See more examples here. 
							</p>
							
							<p><font class="bashcommand">grep '^string$' files</font> matches any lines in <font class="bashcommand">file</font> that start and end with <font class="bashcommand">string</font> (lines containing only string).</p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep '[characters]' files</font></td>
						<td> 
							<p>Search for any lines that contain any of the characters enclosed between the brackets. Use a hyphen for a range of values.</p>
							
							<p>
							Examples:<br> 
							<font class="bashcommand">grep '[abcde]' files</font> matches any lines in <font class="bashcommand">file</font> that contain <font class="bashcommand">a</font>, <font class="bashcommand">b</font>, <font class="bashcommand">c</font>, <font class="bashcommand">d</font> or <font class="bashcommand">e</font>. 
							</p>
							
							<p><font class="bashcommand">grep '[Ss]tring' file</font> matches any lines in <font class="bashcommand">file</font> that contain the words <font class="bashcommand"><u>s</u>tring</font> or <font class="bashcommand"><u>S</u>tring</font>.</p>
							
							<p><font class="bashcommand">grep 'B[ai][dt]' file</font> matches any <font class="bashcommand">lines</font> in <font class="bashcommand">file</font> that contain the words <font class="bashcommand">Bad</font>, <font class="bashcommand">Bat</font>, <font class="bashcommand">Bid</font> or <font class="bashcommand">Bit</font> (the second character can be <font class="bashcommand">a</font> or <font class="bashcommand">i</font> and the third character <font class="bashcommand">d</font> or <font class="bashcommand">t</font>).</p>
							
							<p><font class="bashcommand">grep '[0-9][0-9]' file</font> matches any lines in <font class="bashcommand">file</font> that contain a pair of numeric digits.</p>
							
							<p><font class="bashcommand">grep '[a-zA-Z]' file</font> matches any lines in <font class="bashcommand">file</font> with at least one letter.</p>
							
							<p><font class="bashcommand">grep '^$' file</font> matches any empty lines.</p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep '[^characters]' files</font></td>
						<td> 
							<p>Search for any lines that <u>don't contain</u> any of the characters enclosed between he brackets. Use a hyphen for a range of values.</p>		
							<p>e.i. <font class="bashcommand">grep '[^a-zA-Z0-9]' file</font> matches any lines in file that don't contain any letter or number (any lines that contain only special characters).</p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep 'character*' files</font></td>
						<td> 
							<p>The character preceding the asterisk is optional when matching lines.</p>
							<p>e.i. <font class="bashcommand">grep '"*smug"*' file</font> matches any lines in file that contain <font class="bashcommand">smug</font> or <font class="bashcommand">"smug"</font> (with or without the quotes that precede the asterisks).</p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep 'expression\{n\}' files</font></td>
						<td> 
							<p>Match exactly <font class="bashcommand">n</font> occurrences of <font class="bashcommand">expression</font>.</p>
							<p>e.i. <font class="bashcommand">grep '[0-9]\{3\}-[0-9]\{4\}' file</font> matches any lines in <font class="bashcommand">file</font> that contain three digits, followed by a line and four digits.</p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep 'expression \{n,\}' files</font></td>
						<td> 
							<p>Matches n or more occurrences of <font class="bashcommand">expression</font>.</p>
							<p>e.i. <font class="bashcommand">grep '[0-9]\{3,\}' file</font> matches any lines in <font class="bashcommand">file</font> that contain three or more digits.</p>
						</td>
					</tr>
				</table>
				</p>

				<p>
				<table>
					<tr>
						<th>Flag</th>
						<th>Meaning</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-A num</font></td>
						<td>Print <font class="bashcommand">num</font> lines of trailing context after each match. See here for an example.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-B num</font></td>
						<td>Print <font class="bashcommand">num</font> lines of leading context before each match. See here for an example.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-C num</font></td>
						<td>Print <font class="bashcommand">num</font> lines of leading and trailing context surrounding each match. If <font class="bashcommand">num</font> is not specified, <font class="bashcommand">num=2</font>. See here for an example.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-c</font></td>
						<td>Print the number of matched lines per file instead of the actual lines.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--colour=when</font></td>
						<td>Mark up the matching text with the expression stored in <font class="bashcommand">GREP_COLOR</font> environment variable. The possible values of when can be: <font class="bashcommand">never</font>, <font class="bashcommand">always</font> or <font class="bashcommand">auto</font>.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-d action</font></td>
						<td>Specify the demanded action for directories. The possible values of action are: <font class="bashcommand">read</font> (default), which means that the directories are read in the same manner as normal files; <font class="bashcommand">skip</font> to silently ignore the directories, and <font class="bashcommand">recourse</font> to read them recursively, which has the same effect as the <font class="bashcommand">-R</font> and <font class="bashcommand">-r</font> option.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-e pattern</font></td>
						<td>To search for more than one pattern/expression, add the flag <font class="bashcommand">-e</font> in front of each expression.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--exclude</font></td>
						<td>If specified, it excludes files matching the given filename pattern from the search. Note that <font class="bashcommand">--exclude</font> patterns take priority over <font class="bashcommand">--include</font> patterns. Patterns are matched to the full path specified, not only to the filename component.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--exclude-dir filename_pattern</font></td>
						<td>If <font class="bashcommand">-R</font> is specified, it excludes directories matching the given <font class="bashcommand">filename_pattern</font> from the search.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-f file</font></td>
						<td>Read one or more newline separated patterns from <font class="bashcommand">file</font>. Empty pattern lines match every input line. Newlines are not considered part of a pattern. If <font class="bashcommand">file</font> is empty, nothing is matched.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-h</font></td>
						<td>Omit the filename headers with output lines.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--help</font></td>
						<td>Print a brief help message.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--include</font></td>
						<td>If specified, only files matching the given filename pattern are searched. Note that <font class="bashcommand">--exclude</font> patterns take priority over <font class="bashcommand">--include</font> patterns. Patterns are matched to the full path specified, not only to the filename component.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--include-dir filename_pattern</font></td>
						<td>If <font class="bashcommand">-R</font> is specified, only directories matching the given <font class="bashcommand">filename_pattern</font> are searched. Note that <font class="bashcommand">--exclude-dir</font> patterns take priority over <font class="bashcommand">--include-dir</font> patterns.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-L</font></td>
						<td>Only the names of files not containing selected lines are listed.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-l</font></td>
						<td>Only the names of files containing selected lines are listed.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-m num</font></td>
						<td>Stop reading the file after <font class="bashcommand">num</font> matches.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-n</font></td>
						<td>Each output line is preceded by its relative line number in the file, <u>starting at line 1</u>. The line number counter is reset for each file processed. This option is ignored if <font class="bashcommand">-c</font>, <font class="bashcommand">-L</font>, <font class="bashcommand">-l</font>, or <font class="bashcommand">-q</font> is specified.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--null</font></td>
						<td>Prints a zero-byte after the file name.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-O</font></td>
						<td>If <font class="bashcommand">-R</font> is specified, follow symbolic links only if they were explicitly listed on the command line. The default is not to follow symbolic links.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-o</font></td>
						<td>Prints only the matching part of the lines.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-q</font></td>
						<td>Suppress normal output.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-R</font> or <font class="bashcommand">-r</font></td>
						<td>Recursively search subdirectories listed.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-S</font></td>
						<td>If <font class="bashcommand">-R</font> is specified, all symbolic links are followed. The default is not to follow symbolic links.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-s</font></td>
						<td>Suppress error messages from nonexistent or unreadable files.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-V</font></td>
						<td>Display version information and exit.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-v</font></td>
						<td>Selected lines are those <u>not</u> matching any of the specified patterns.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-w</font></td>
						<td>The expression is searched for as a whole word.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-x</font></td>
						<td>Show only the cases where the whole line equals the expression.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-Z</font> or <font class="bashcommand">-z</font></td>
						<td>Accepts compressed input files.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--line-buffered</font></td>
						<td>Force output to be line buffered. By default, output is line buffered when standard output is a terminal and block buffered otherwise.</td>
					</tr>
				</table>
				</p>

				<p>The following examples will show how to read and manipulate files using different command line tools. Each example will read one or more of the following files. file1.csv and file3.csv use comma as the separator between columns. On the other hand, file2.txt and file file4.txt use a space as the separator between columns.</p>

				<p>
				Content of file1.csv:<br>
				"Anonymized ID","Subject Group","HASCONDITION","CONDITION"<br>
				"B33199522","Group1","0",""<br>
				"B33199603","Group3","0",""<br>
				"B11137879","Group1","0",""<br>
				"B11144410","Group2 b","0",""<br>
				"B11110455","Group2 b","0",""<br>
				"B11135291","Group3","0",""<br>
				"B11153927","Group1","0",""<br>
				"B11177579","Group2 b","0",""<br>
				"B11177806","Group1","MD",""<br>
				"B11157958","Group3","0",""<br>
				"B11110690","Group3","0",""<br>
				"B11152799","Group1","0",""<br>
				"B11154358","Group1","0",""<br>
				"B11110925","Group1","0",""<br>
				"B11135291","Group3","9","mTBI"<br> 
				"B11135072","MISSING","0",""<br>
				"B33199603","Group3","0",""<br>
				"B11137879","Group1","0",""<br>
				"B11110603","Group1","0",""<br>
				"B11110927","Group1","0",""<br>
				"B11147712","Group1","0",""<br>
				"B33191224","Group2 b","0",""<br>
				"B11131290","Group2 b","0",""<br>
				"B11157974","Group1","0",""<br>
				"B33191224","Group2 b","0",""<br>
				"B11141503","Group3","0",""<br>
				"C11137159","Group3","9","mTBI"<br> 
				"B33199522","Group1","0","" 
				</p>

				<p>
				Content of file2.txt:<br> 
				"AnonymizedID" "SubjectGroup" "TEST1" "TEST2"<br> 
				"B11130912" "Group2b" "900" "MissingData"<br> 
				"B11137244" "Group1" "450" "555"<br> 
				"B11154534" "Group1" "456" "456"<br> 
				"B11144100" "Group1" "450" "886"<br> 
				"B11137244" "Group1" "450" "456"<br> 
				"B12226566" "Group2b" "450" "MissingData"<br> 
				"B11134987" "Group1" "900" "MissingData"<br> 
				"B11144345" "Group1" "900" "776"<br> 
				"C11137159" "Group3" "MissingData" "MissingData"<br> 
				"B11156453" "Group4" "456" "2"<br> 
				"B11110676" "Group1" "900" "10"<br> 
				"C11138929" "Group2b" "2" "MissingData"<br> 
				"B11154532" "Group1" "456" "886"<br> 
				"B11155267" "Group3" "900" "10"<br> 
				"B11137120" "Group2b" "450" "456"<br> 
				"B33191224" "Group2b" "450" "776"<br> 
				"B11155267" "Group3" "900" "10"<br> 
				"C11138999" "Group2b" "900" "MissingData"<br> 
				"B11131605" "Group1" "456" "MissingData"<br> 
				"B11137784" "Group1" "900" "436"<br> 
				"B11156098" "Group1" "500" "886"<br> 
				"B11133232" "Group1" "500" "MissingData"<br> 
				"B11135292" "Group3" "MissingData" "MissingData"<br> 
				"C11138912" "Group2b" "900" "MissingData"<br> 
				"B11150911" "Group2b" "900" "117"<br> 
				"B11152577" "Group1" "900" "756"<br> 
				"B11156098" "Group1" "456" "886"<br> 
				"B11133232" "Group1" "456" "MissingData" 
				</p>

				<p>
				Content of file3.csv:<br> 
				Anonymized ID,Subject Group,AGE<br> 
				C11138122,MISSING,21<br> 
				C11138192,Group1,54<br> 
				B12226507,Group1,68<br> 
				B12226546,Group1,67<br> 
				C11138122,Group1,24<br> 
				C11138184,Group1,59<br> 
				C11138797,Group1,22<br> 
				C11138152,Group1,53<br> 
				C11138150,Group1,41<br> 
				C11137167,Group3,14<br> 
				C11137159,Group3,13<br> 
				C11137167,Group3,16<br> 
				C11137159,Group3,13<br> 
				C11131039,Group2 b,67<br> 
				C11135566,Group2 b,73<br> 
				B11119903,Group2 b,83<br> 
				C11137544,Group1,21<br> 
				C11137443,Group3,11<br> 
				C11137123,Group2 b,69<br> 
				C11137439,Group3,79<br> 
				C11137439,Group3,15<br> 
				C11133100,Group1,23<br> 
				D11144030,Group3,13<br> 
				B11108399,Group1,23<br> 
				B11108326,Group1,59<br> 
				B11119909,Group2 b,61<br> 
				B11110893,Group1,28
				</p>

				<p>
				Content of file4.txt:<br>
				AnonymizedID SubjectGroup AGE<br> 
				B11108326 Group1 59<br> 
				B11108399 Group1 23<br> 
				B11110893 Group1 28<br> 
				B11119909 Group2 61<br> 
				D11144030 Group3 11<br> 
				D11144030 Group3 13<br> 
				B11119903 Group2 84<br> 
				C11131039 Group2 67<br> 
				C11133100 Group1 23<br> 
				C11135566 Group2 72<br> 
				C11137159 Group3 11<br> 
				C11137159 Group3 12<br> 
				C11137167 Group3 14<br> 
				C11137167 Group3 16<br> 
				C11137439 Group3 15<br> 
				C11137439 Group3 79<br> 
				C11137443 Group3 15<br> 
				C11137544 Group1 22<br> 
				C11137123 Group2 68<br> 
				C11138150 Group1 44<br> 
				C11138152 Group1 10<br> 
				C11138797 Group1 24<br> 
				C11138184 Group1 57<br> 
				C11138122 Group1 23<br> 
				C11138122 MISSING 25<br> 
				C11138192 Group1 45<br> 
				B12226507 Group1 26<br> 
				B12226546 Group1 55 
				</p>

			<h3>9.7. Examples: Reading specific columns from a file or a list of files</h3>
				<p>
					<font class="example">Print the first column of each file</font>
					In order to print the first column of these files, we will use <font class="bashcommand">awk</font> utility. As it was shown before, the command for this utility consists on some optional flags followed by an action statement and then the list of files. In this case the action statement is <font class="bashcommand">'{print $1}'</font>, because we want to print only the first column (<font class="bashcommand">$1</font>). Files file2.txt and file4.txt use a space as a column separator (which is the separator for default). So, to access the first column of these files we don't need the <font class="bashcommand">-F</font> flag. However, files file1.csv and file3.csv use a comma as a separator. So, in order for <font class="bashcommand">awk</font> to distinguish the different columns we have to use the <font class="bashcommand">-F</font> flag. In this case, the parameter of the <font class="bashcommand">-F</font> flag is a comma (<font class="bashcommand">-F','</font>). If you are trying to read a file which has the columns separated by a different character, then use that character instead of <font class="bashcommand">','</font>. 
				</p>

				<p>
				<table class="ghostTable">
					<tr>
						<th>Space-separated files</th>
						<th>Comma-separated files</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">$ awk '{print $1}' file2.txt</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print $1}' file1.csv</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"AnonymizedID"</font></td>
						<td><font class="bashcommand-result">"Anonymized ID"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11130912"</font></td>
						<td><font class="bashcommand-result">"B33199522"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137244"</font></td>
						<td><font class="bashcommand-result">"B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11154534"</font></td>
						<td><font class="bashcommand-result">"B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11144100"</font></td>
						<td><font class="bashcommand-result">"B11144410"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137244"</font></td>
						<td><font class="bashcommand-result">"B11110455"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B12226566"</font></td>
						<td><font class="bashcommand-result">"B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11134987"</font></td>
						<td><font class="bashcommand-result">"B11153927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11144345"</font></td>
						<td><font class="bashcommand-result">"B11177579"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11137159"</font></td>
						<td><font class="bashcommand-result">"B11177806"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11156453"</font></td>
						<td><font class="bashcommand-result">"B11157958"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11110676"</font></td>
						<td><font class="bashcommand-result">"B11110690"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11138929"</font></td>
						<td><font class="bashcommand-result">"B11152799"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11154532"</font></td>
						<td><font class="bashcommand-result">"B11154358"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11155267"</font></td>
						<td><font class="bashcommand-result">"B11110925"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137120"</font></td>
						<td><font class="bashcommand-result">"B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33191224"</font></td>
						<td><font class="bashcommand-result">"B11135072"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11155267"</font></td>
						<td><font class="bashcommand-result">"B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11138999"</font></td>
						<td><font class="bashcommand-result">"B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11131605"</font></td>
						<td><font class="bashcommand-result">"B11131605"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137784"</font></td>
						<td><font class="bashcommand-result">"B11110927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11156098"</font></td>
						<td><font class="bashcommand-result">"B11147712"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11133232"</font></td>
						<td><font class="bashcommand-result">"B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11135292"</font></td>
						<td><font class="bashcommand-result">"B11131290"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11138912"</font></td>
						<td><font class="bashcommand-result">"B11157974"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11150911"</font></td>
						<td><font class="bashcommand-result">"B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11152577"</font></td>
						<td><font class="bashcommand-result">"B11141503"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11156098"</font></td>
						<td><font class="bashcommand-result">"C11137159"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11133232"</font></td>
						<td><font class="bashcommand-result">"B33199522"</font></td>
					</tr>
				</table>
				</p>

				<p>
				<table class="ghostTable">
					<tr>
						<td><font class="bashcommand">$ awk '{print $1}' file4.txt</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print $1}' file3.csv</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">AnonymizedID</font></td>
						<td><font class="bashcommand-result">Anonymized ID</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">B11108326</font></td>
						<td><font class="bashcommand-result">C11138122</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">B11110893</font></td>
						<td><font class="bashcommand-result">C11138192</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">B11119909</font></td>
						<td><font class="bashcommand-result">B12226507</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">D11144030</font></td>
						<td><font class="bashcommand-result">B12226546</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">D11144030</font></td>
						<td><font class="bashcommand-result">C11138122</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">B11119903</font></td>
						<td><font class="bashcommand-result">C11138184</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11131039</font></td>
						<td><font class="bashcommand-result">C11138797</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11133100</font></td>
						<td><font class="bashcommand-result">C11138152</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11135566</font></td>
						<td><font class="bashcommand-result">C11138150</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137159</font></td>
						<td><font class="bashcommand-result">C11137167</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137159</font></td>
						<td><font class="bashcommand-result">C11137159</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137167</font></td>
						<td><font class="bashcommand-result">C11137167</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137167</font></td>
						<td><font class="bashcommand-result">C11137159</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137439</font></td>
						<td><font class="bashcommand-result">C11131039</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137439</font></td>
						<td><font class="bashcommand-result">C11135566</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137443</font></td>
						<td><font class="bashcommand-result">B11119903</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137544</font></td>
						<td><font class="bashcommand-result">C11137544</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137123</font></td>
						<td><font class="bashcommand-result">C11137443</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11138150</font></td>
						<td><font class="bashcommand-result">C11137123</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11138152</font></td>
						<td><font class="bashcommand-result">C11137439</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11138797</font></td>
						<td><font class="bashcommand-result">C11137439</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11138184</font></td>
						<td><font class="bashcommand-result">C11133100</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11138122</font></td>
						<td><font class="bashcommand-result">D11144030</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11138122</font></td>
						<td><font class="bashcommand-result">B11108399</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11138192</font></td>
						<td><font class="bashcommand-result">B11108326</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">B12226507</font></td>
						<td><font class="bashcommand-result">B11119909</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">B12226546</font></td>
						<td><font class="bashcommand-result">B11110893</font></td>
					</tr>
				</table>
				</p>

				<p>To precede each line by the line number, add <font class="bashcommand">NR</font>, after the string <font class="bashcommand">print</font> in the <font class="bashcommand">awk</font> command to indicate that you want to print the Number Row before the column 1 (<font class="bashcommand">$1</font>):</p>

				<p>
				<table class="ghostTable">
					<tr>
						<th>Space-separated files</th>
						<th>Comma-separated files</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">$ awk '{print NR,$1}' file2.txt</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print NR, $1}' file1.csv</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">1 "AnonymizedID"</font></td>
						<td><font class="bashcommand-result">1 "Anonymized ID"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">2 "B11130912"</font></td>
						<td><font class="bashcommand-result">2 "B33199522"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">3 "B11137244"</font></td>
						<td><font class="bashcommand-result">3 "B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">4 "B11154534"</font></td>
						<td><font class="bashcommand-result">4 "B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">5 "B11144100"</font></td>
						<td><font class="bashcommand-result">5 "B11144410"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">6 "B11137244"</font></td>
						<td><font class="bashcommand-result">6 "B11110455"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">7 "B12226566"</font></td>
						<td><font class="bashcommand-result">7 "B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">8 "B11134987"</font></td>
						<td><font class="bashcommand-result">8 "B11153927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">9 "B11144345"</font></td>
						<td><font class="bashcommand-result">9 "B11177579"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">10 "C11137159"</font></td>
						<td><font class="bashcommand-result">10 "B11177806"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">11 "B11156453"</font></td>
						<td><font class="bashcommand-result">11 "B11157958"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">12 "B11110676"</font></td>
						<td><font class="bashcommand-result">12 "B11110690"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">13 "C11138929"</font></td>
						<td><font class="bashcommand-result">13 "B11152799"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">14 "B11154532"</font></td>
						<td><font class="bashcommand-result">14 "B11154358"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">15 "B11155267"</font></td>
						<td><font class="bashcommand-result">15 "B11110925"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">16 "B11137120"</font></td>
						<td><font class="bashcommand-result">16 "B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">17 "B33191224"</font></td>
						<td><font class="bashcommand-result">17 "B11135072"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">18 "B11155267"</font></td>
						<td><font class="bashcommand-result">18 "B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">19 "C11138999"</font></td>
						<td><font class="bashcommand-result">19 "B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">20 "B11131605"</font></td>
						<td><font class="bashcommand-result">20 "B11131605"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">21 "B11137784"</font></td>
						<td><font class="bashcommand-result">21 "B11110927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">22 "B11156098"</font></td>
						<td><font class="bashcommand-result">22 "B11147712"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">23 "B11133232"</font></td>
						<td><font class="bashcommand-result">23 "B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">24 "B11135292"</font></td>
						<td><font class="bashcommand-result">24 "B11131290"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">25 "C11138912"</font></td>
						<td><font class="bashcommand-result">25 "B11157974"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">26 "B11150911"</font></td>
						<td><font class="bashcommand-result">26 "B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">27 "B11152577"</font></td>
						<td><font class="bashcommand-result">27 "B11141503"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">28 "B11156098"</font></td>
						<td><font class="bashcommand-result">28 "C11137159"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">29 "B11133232"</font></td>
						<td><font class="bashcommand-result">29 "B33199522"</font></td>
					</tr>
				</table>
				</p>

				<p>
				<table class="ghostTable">
					<tr>
						<td><font class="bashcommand">$ awk '{print NR, $1}' file4.txt</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print NR, $1}' file3.csv</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">1 AnonymizedID</font></td>
						<td><font class="bashcommand-result">1 Anonymized ID</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">2 B11108326</font></td>
						<td><font class="bashcommand-result">2 C11138122</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">3 B11110893</font></td>
						<td><font class="bashcommand-result">3 C11138192</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">4 B11119909</font></td>
						<td><font class="bashcommand-result">4 B12226507</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">5 D11144030</font></td>
						<td><font class="bashcommand-result">5 B12226546</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">6 D11144030</font></td>
						<td><font class="bashcommand-result">6 C11138122</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">7 B11119903</font></td>
						<td><font class="bashcommand-result">7 C11138184</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">8 C11131039</font></td>
						<td><font class="bashcommand-result">8 C11138797</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">9 C11133100</font></td>
						<td><font class="bashcommand-result">9 C11138152</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">10 C11135566</font></td>
						<td><font class="bashcommand-result">10 C11138150</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">11 C11137159</font></td>
						<td><font class="bashcommand-result">11 C11137167</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">12 C11137159</font></td>
						<td><font class="bashcommand-result">12 C11137159</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">13 C11137167</font></td>
						<td><font class="bashcommand-result">13 C11137167</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">14 C11137167</font></td>
						<td><font class="bashcommand-result">14 C11137159</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">15 C11137439</font></td>
						<td><font class="bashcommand-result">15 C11131039</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">16 C11137439</font></td>
						<td><font class="bashcommand-result">16 C11135566</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">17 C11137443</font></td>
						<td><font class="bashcommand-result">17 B11119903</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">18 C11137544</font></td>
						<td><font class="bashcommand-result">18 C11137544</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">19 C11137123</font></td>
						<td><font class="bashcommand-result">19 C11137443</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">20 C11138150</font></td>
						<td><font class="bashcommand-result">20 C11137123</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">21 C11138152</font></td>
						<td><font class="bashcommand-result">21 C11137439</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">22 C11138797</font></td>
						<td><font class="bashcommand-result">22 C11137439</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">23 C11138184</font></td>
						<td><font class="bashcommand-result">23 C11133100</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">24 C11138122</font></td>
						<td><font class="bashcommand-result">24 D11144030</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">25 C11138122</font></td>
						<td><font class="bashcommand-result">25 B11108399</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">26 C11138192</font></td>
						<td><font class="bashcommand-result">26 B11108326</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">27 B12226507</font></td>
						<td><font class="bashcommand-result">27 B11119909</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">28 B12226546</font></td>
						<td><font class="bashcommand-result">28 B11110893</font></td>
					</tr>
				</table>
				</p>

				<p>
					<font class="example">Print the first column of file1.csv and file2.txt in reverse order</font>
					In order to print from the last line to the first line, you can use the command <font class="bashcommand">tail</font> with the flag <font class="bashcommand">-r</font> (for reverse) after the command <font class="bashcommand">awk</font>. The command line will first execute the <font class="bashcommand">awk</font> command which is written before the <font class="bashcommand">|</font> symbol, and then it will run the <font class="bashcommand">tail</font> command which inverts the order of the previous output. Remember that for file1.csv you need to use <font class="bashcommand">-F','</font> to indicate that the columns are separated by commas and not spaces.
				</p>

				<p>
				<table class="ghostTable">
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">$ awk '{print $1}' file2.txt | tail -r</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print $1}' file1.csv | tail -r</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11133232"</font></td>
						<td><font class="bashcommand-result">"B33199522"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11156098"</font></td>
						<td><font class="bashcommand-result">"C11137159"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11152577"</font></td>
						<td><font class="bashcommand-result">"B11141503"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11150911"</font></td>
						<td><font class="bashcommand-result">"B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11138912"</font></td>
						<td><font class="bashcommand-result">"B11157974"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11135292"</font></td>
						<td><font class="bashcommand-result">"B11131290"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11133232"</font></td>
						<td><font class="bashcommand-result">"B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11156098"</font></td>
						<td><font class="bashcommand-result">"B11147712"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137784"</font></td>
						<td><font class="bashcommand-result">"B11110927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11131605"</font></td>
						<td><font class="bashcommand-result">"B11110603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11138999"</font></td>
						<td><font class="bashcommand-result">"B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11155267"</font></td>
						<td><font class="bashcommand-result">"B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33191224"</font></td>
						<td><font class="bashcommand-result">"B11135072"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137120"</font></td>
						<td><font class="bashcommand-result">"B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11155267"</font></td>
						<td><font class="bashcommand-result">"B11110925"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11154532"</font></td>
						<td><font class="bashcommand-result">"B11154358"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11138929"</font></td>
						<td><font class="bashcommand-result">"B11152799"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11110676"</font></td>
						<td><font class="bashcommand-result">"B11110690"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11156453"</font></td>
						<td><font class="bashcommand-result">"B11157958"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11137159"</font></td>
						<td><font class="bashcommand-result">"B11177806"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11144345"</font></td>
						<td><font class="bashcommand-result">"B11177579"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11134987"</font></td>
						<td><font class="bashcommand-result">"B11153927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B12226566"</font></td>
						<td><font class="bashcommand-result">"B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137244"</font></td>
						<td><font class="bashcommand-result">"B11110455"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11144100"</font></td>
						<td><font class="bashcommand-result">"B11144410"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11154534"</font></td>
						<td><font class="bashcommand-result">"B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137244"</font></td>
						<td><font class="bashcommand-result">"B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11130912"</font></td>
						<td><font class="bashcommand-result">"B33199522"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"AnonymizedID"</font></td>
						<td><font class="bashcommand-result">"Anonymized ID"</font></td>
					</tr>
				</table>
				</p>

				<p>The same as in example 1, to precede each line by the line number, add <font class="bashcommand">NR</font>, after the string <font class="bashcommand">print</font> in the <font class="bashcommand">awk</font> command to indicate that you want to print the Number Row before the column 1 (<font class="bashcommand">$1</font>):</p>

				<p>
				<table class="ghostTable">
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">$ awk '{print NR, $1}' file2.txt | tail -r</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print NR, $1}' file1.csv | tail -r</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">29 "B11133232"</font></td>
						<td><font class="bashcommand-result">29 "B33199522"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">28 "B11156098"</font></td>
						<td><font class="bashcommand-result">28 "C11137159"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">27 "B11152577"</font></td>
						<td><font class="bashcommand-result">27 "B11141503"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">26 "B11150911"</font></td>
						<td><font class="bashcommand-result">26 "B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">25 "C11138912"</font></td>
						<td><font class="bashcommand-result">25 "B11157974"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">24 "B11135292"</font></td>
						<td><font class="bashcommand-result">24 "B11131290"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">23 "B11133232"</font></td>
						<td><font class="bashcommand-result">23 "B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">22 "B11156098"</font></td>
						<td><font class="bashcommand-result">22 "B11147712"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">21 "B11137784"</font></td>
						<td><font class="bashcommand-result">21 "B11110927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">20 "B11131605"</font></td>
						<td><font class="bashcommand-result">20 "B11110603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">19 "C11138999"</font></td>
						<td><font class="bashcommand-result">19 "B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">18 "B11155267"</font></td>
						<td><font class="bashcommand-result">18 "B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">17 "B33191224"</font></td>
						<td><font class="bashcommand-result">17 "B11135072"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">16 "B11137120"</font></td>
						<td><font class="bashcommand-result">16 "B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">15 "B11155267"</font></td>
						<td><font class="bashcommand-result">15 "B11110925"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">14 "B11154532"</font></td>
						<td><font class="bashcommand-result">14 "B11154358"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">13 "C11138929"</font></td>
						<td><font class="bashcommand-result">13 "B11152799"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">12 "B11110676"</font></td>
						<td><font class="bashcommand-result">12 "B11110690"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">11 "B11156453"</font></td>
						<td><font class="bashcommand-result">11 "B11157958"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">10 "C11137159"</font></td>
						<td><font class="bashcommand-result">10 "B11177806"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">9 "B11144345"</font></td>
						<td><font class="bashcommand-result">9 "B11177579"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">8 "B11134987"</font></td>
						<td><font class="bashcommand-result">8 "B11153927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">7 "B12226566"</font></td>
						<td><font class="bashcommand-result">7 "B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">6 "B11137244"</font></td>
						<td><font class="bashcommand-result">6 "B11110455"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">5 "B11144100"</font></td>
						<td><font class="bashcommand-result">5 "B11144410"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">4 "B11154534"</font></td>
						<td><font class="bashcommand-result">4 "B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">3 "B11137244"</font></td>
						<td><font class="bashcommand-result">3 "B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">2 "B11130912"</font></td>
						<td><font class="bashcommand-result">2 "B33199522"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">1 "AnonymizedID"</font></td>
						<td><font class="bashcommand-result">1 "Anonymized ID"</font></td>
					</tr>
				</table>
				</p>

				<p>
				<font class="example">Print the second and third columns of file1.csv and file2.txt. Show the lines of file2.txt in <b>reverse order</b>.</font>
				In the previous examples we used the action statement <font class="bashcommand">'{print $1}'</font> to print the first column. Since we now want to print the second and third columns instead of the first one, we replace  <font class="bashcommand">$1</font> by  <font class="bashcommand">$2</font>, <font class="bashcommand">$3</font>. If you wanted to print column 4 and 5 instead, then you would simply use <font class="bashcommand">$4</font>,<font class="bashcommand">$5</font>, etc. In order to print the output in reverse order for file2.txt, use the <font class="bashcommand">tail -r</font> command after the <font class="bashcommand">awk</font>. 
				</p>

				<p>
				<table class="ghostTable">
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">$ awk '{print $2,$3}' file2.txt</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print $2,$3}' file1.csv | tail -r</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"SubjectGroup" "TEST1"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "900"</font></td>
						<td><font class="bashcommand-result">"Group3" "9"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "450"</font></td>
						<td><font class="bashcommand-result">"Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "456"</font></td>
						<td><font class="bashcommand-result">"Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "450"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "450"</font></td>
						<td><font class="bashcommand-result">"Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "450"</font></td>
						<td><font class="bashcommand-result">"Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "900"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "900"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group3" "MissingData"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group4" "456"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "900"</font></td>
						<td><font class="bashcommand-result">"Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "2"</font></td>
						<td><font class="bashcommand-result">"MISSING" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "456"</font></td>
						<td><font class="bashcommand-result">"Group3" "9"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group3" "900"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "450"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "450"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group3" "900"</font></td>
						<td><font class="bashcommand-result">"Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "900"</font></td>
						<td><font class="bashcommand-result">"Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "456"</font></td>
						<td><font class="bashcommand-result">"Group1" "MD"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "900"</font></td>
						<td><font class="bashcommand-result">"Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "500"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "500"</font></td>
						<td><font class="bashcommand-result">"Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group3" "MissingData"</td>
						<td><font class="bashcommand-result">"Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "900"</font></td>
						<td><font class="bashcommand-result">"Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "900"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "900"</font></td>
						<td><font class="bashcommand-result">"Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "456"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "456"</font></td>
						<td><font class="bashcommand-result">"Subject Group" "HASCONDITION"</font></td>
					</tr>
				</table>
				</p>

				<p>To precede each line by the line number, add <font class="bashcommand">NR</font>, after the string <font class="bashcommand">print</font> in the <font class="bashcommand">awk</font> command to indicate that you want to print the Number Row before the column 1 (<font class="bashcommand">$1</font>):</p>

				<p>
				<table class="ghostTable">
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">$ awk '{print NR,$2,$3}' file2.txt</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print NR,$2,$3}' file1.csv | tail -r</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">1 "SubjectGroup" "TEST1"</font></td>
						<td><font class="bashcommand-result">29 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">2 "Group2b" "900"</font></td>
						<td><font class="bashcommand-result">28 "Group3" "9"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">3 "Group1" "450"</font></td>
						<td><font class="bashcommand-result">27 "Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">4 "Group1" "456"</font></td>
						<td><font class="bashcommand-result">26 "Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">5 "Group1" "450"</font></td>
						<td><font class="bashcommand-result">25 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">6 "Group1" "450"</font></td>
						<td><font class="bashcommand-result">24 "Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">7 "Group2b" "450"</font></td>
						<td><font class="bashcommand-result">23 "Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">8 "Group1" "900"</font></td>
						<td><font class="bashcommand-result">22 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">9 "Group1" "900"</font></td>
						<td><font class="bashcommand-result">21 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">10 "Group3" "MissingData"</font></td>
						<td><font class="bashcommand-result">20 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">11 "Group4" "456"</font></td>
						<td><font class="bashcommand-result">19 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">12 "Group1" "900"</font></td>
						<td><font class="bashcommand-result">18 "Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">13 "Group2b" "2"</font></td>
						<td><font class="bashcommand-result">17 "MISSING" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">14 "Group1" "456"</font></td>
						<td><font class="bashcommand-result">16 "Group3" "9"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">15 "Group3" "900"</font></td>
						<td><font class="bashcommand-result">15 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">16 "Group2b" "450"</font></td>
						<td><font class="bashcommand-result">14 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">17 "Group2b" "450"</font></td>
						<td><font class="bashcommand-result">13 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">18 "Group3" "900"</font></td>
						<td><font class="bashcommand-result">12 "Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">19 "Group2b" "900"</font></td>
						<td><font class="bashcommand-result">11 "Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">20 "Group1" "456"</font></td>
						<td><font class="bashcommand-result">10 "Group1" "MD"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">21 "Group1" "900"</font></td>
						<td><font class="bashcommand-result">9 "Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">22 "Group1" "500"</font></td>
						<td><font class="bashcommand-result">8 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">23 "Group1" "500"</font></td>
						<td><font class="bashcommand-result">7 "Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">24 "Group3" "MissingData"</font></td>
						<td><font class="bashcommand-result">6 "Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">25 "Group2b" "900"</font></td>
						<td><font class="bashcommand-result">5 "Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">26 "Group2b" "900"</font></td>
						<td><font class="bashcommand-result">4 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">27 "Group1" "900"</font></td>
						<td><font class="bashcommand-result">3 "Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">28 "Group1" "456"</font></td>
						<td><font class="bashcommand-result">2 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">29 "Group1" "456"</font></td>
						<td><font class="bashcommand-result">1 "Subject Group" "HASCONDITION"</font></td>
					</tr>
				</table>
				</p>

				<p>
					<font class="example">Print all the columns of file1.csv showing the lines in <b>reverse order</b>.</font>
					To print all the columns of a file using <font class="bashcommand">awk</font> simply use <font class="bashcommand">$0</font> (instead of a column number). Or use the command <font class="bashcommand">cat</font>.
				</p>

				<p>
				<table class="ghostTable">
					<tr>
						<th>Using <font class="bashcommand">awk</font></th>
						<th>Using <font class="bashcommand">cat</font></th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">$ awk -F',' '{print $0}' file1.csv | tail -r</font></td>
						<td><font class="bashcommand">$ cat file1.csv | tail -r</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33199522","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B33199522","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11137159","Group3","9","mTBI"</font></td>
						<td><font class="bashcommand-result">"C11137159","Group3","9","mTBI"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11141503","Group3","0",""</font></td>
						<td><font class="bashcommand-result">"B11141503","Group3","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33191224","Group2 b","0",""</font></td>
						<td><font class="bashcommand-result">"B33191224","Group2 b","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11157974","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11157974","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11131290","Group2 b","0",""</font></td>
						<td><font class="bashcommand-result">"B11131290","Group2 b","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33191224","Group2 b","0",""</font></td>
						<td><font class="bashcommand-result">"B33191224","Group2 b","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11147712","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11147712","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11110927","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11110927","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11110603","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11110603","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137879","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11137879","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33199603","Group3","0",""</font></td>
						<td><font class="bashcommand-result">"B33199603","Group3","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11135072","MISSING","0",""</font></td>
						<td><font class="bashcommand-result">"B11135072","MISSING","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11135291","Group3","9","mTBI"</font></td>
						<td><font class="bashcommand-result">"B11135291","Group3","9","mTBI"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11110925","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11110925","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11154358","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11154358","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11152799","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11152799","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11110690","Group3","0",""</font></td>
						<td><font class="bashcommand-result">"B11110690","Group3","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11157958","Group3","0",""</font></td>
						<td><font class="bashcommand-result">"B11157958","Group3","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11177806","Group1","MD",""</font></td>
						<td><font class="bashcommand-result">"B11177806","Group1","MD",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11177579","Group2 b","0",""</font></td>
						<td><font class="bashcommand-result">"B11177579","Group2 b","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11153927","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11153927","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11135291","Group3","0",""</font></td>
						<td><font class="bashcommand-result">"B11135291","Group3","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11110455","Group2 b","0",""</font></td>
						<td><font class="bashcommand-result">"B11110455","Group2 b","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11144410","Group2 b","0",""</font></td>
						<td><font class="bashcommand-result">"B11144410","Group2 b","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137879","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11137879","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33199603","Group3","0",""</font></td>
						<td><font class="bashcommand-result">"B33199603","Group3","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33199522","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B33199522","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Anonymized ID","Subject Group","HASCONDITION","CONDITION"</font></td>
						<td><font class="bashcommand-result">"Anonymized ID","Subject Group","HASCONDITION","CONDITION"</font></td>
					</tr>
				</table>
				</p>
	
				<p>
					<font class="example">Print all the columns of file1.csv in <b>reversed order</b> (first the third column, then the second and finally the first one), and save the re-ordered columns in a new file called file1_reordered.csv.</font>
					If you were going to print the columns one to three in normal order, you would use <font class="bashcommand">'{print $1,$2,$3}'</font>. To print them in reverse order, you just reverse the order of the columns in <font class="bashcommand">print</font>: <font class="bashcommand">'{print $3,$2,$1}'</font>.<br>
					To save the output to a file instead of showing it in the terminal, use <font class="bashcommand">&gt;&gt; file</font> as explained in previous sections.<br>
					Remember to use the <font class="bashcommand">-F','</font> flag to indicate that the columns are separated by commas and not the default space.
				</p>

				<p><font class="bashcommand">
				$ awk -F',' '{print $3,$2,$1}' file1.csv &gt;&gt; file1_reordered.csv<br>
				$ cat file1_reordered.csv<br>
				<font class="bashcommand-result"><br>
				"HASCONDITION" "Subject Group" "Anonymized ID"<br>
				"0" "Group1" "B33199522"<br>
				"0" "Group3" "B33199603"<br>
				"0" "Group1" "B11137879"<br>
				"0" "Group2 b" "B11144410"<br>
				"0" "Group2 b" "B11110455"<br>
				"0" "Group3" "B11135291"<br>
				"0" "Group1" "B11153927"<br>
				"0" "Group2 b" "B11177579"<br>
				"MD" "Group1" "B11177806"<br>
				"0" "Group3" "B11157958"<br>
				"0" "Group3" "B11110690"<br>
				"0" "Group1" "B11152799"<br>
				"0" "Group1" "B11154358"<br>
				"0" "Group1" "B11110925"<br>
				"9" "Group3" "B11135291"<br>
				"0" "MISSING" "B11135072"<br>
				"0" "Group3" "B33199603"<br>
				"0" "Group1" "B11137879"<br>
				"0" "Group1" "B11110603"<br>
				"0" "Group1" "B11110927"<br>
				"0" "Group1" "B11147712"<br>
				"0" "Group2 b" "B33191224"<br>
				"0" "Group2 b" "B11131290"<br>
				"0" "Group1" "B11157974"<br>
				"0" "Group2 b" "B33191224"<br>
				"0" "Group3" "B11141503"<br>
				"9" "Group3" "C11137159"<br>
				"0" "Group1" "B33199522"
				</font>
				</font></p>

				<p>
				<font class="example">Print all the columns of file1.csv in <b>reversed order</b> (first the third column, then the second and finally the first one). Print the lines also in reverse order (from the last line to the first one).</font><br>
				Use the same command as before, adding <font class="bashcommand">| tail -r</font> at the end to invert also the lines. 
				</p>

				<p><font class="bashcommand">
				$ awk -F',' '{print $3,$2,$1}' file1.csv | tail -r<br>
				<font class="bashcommand-result">
				"0" "Group1" "B33199522"<br>
				"9" "Group3" "C11137159"<br>
				"0" "Group3" "B11141503"<br>
				"0" "Group2 b" "B33191224"<br>
				"0" "Group1" "B11157974"<br>
				"0" "Group2 b" "B11131290"<br>
				"0" "Group2 b" "B33191224"<br>
				"0" "Group1" "B11147712"<br>
				"0" "Group1" "B11110927"<br>
				"0" "Group1" "B11110603"<br>
				"0" "Group1" "B11137879"<br>
				"0" "Group3" "B33199603"<br>
				"0" "MISSING" "B11135072"<br>
				"9" "Group3" "B11135291"<br>
				"0" "Group1" "B11110925"<br>
				"0" "Group1" "B11154358"<br>
				"0" "Group1" "B11152799"<br>
				"0" "Group3" "B11110690"<br>
				"0" "Group3" "B11157958"<br>
				"MD" "Group1" "B11177806"<br>
				"0" "Group2 b" "B11177579"<br>
				"0" "Group1" "B11153927"<br>
				"0" "Group3" "B11135291"<br>
				"0" "Group2 b" "B11110455"<br>
				"0" "Group2 b" "B11144410"<br>
				"0" "Group1" "B11137879"<br>
				"0" "Group3" "B33199603"<br>
				"0" "Group1" "B33199522"<br>
				"HASCONDITION" "Subject Group" "Anonymized ID" 
				</font>
				</font></p>

				<p>
				<font class="example">Read the second column of file1.csv and file2.txt and save it into an array.</font> 
				When saving a column of a file into an array, you must specify that the elements of the array are separated by new lines (<font class="bashcommand">'\n'</font>). You do this using the command <font class="bashcommand">IFS=$'\n'</font>.<br> 
				The elements of the array will be saved in the variable <font class="bashcommand">ARRAY</font>. As it was learned in previous chapters, to access the individual elements of <font class="bashcommand">ARRAY</font> you use the syntax <font class="bashcommand">${ARRAY[index]}</font>. With <font class="bashcommand">index</font> starting at <font class="bashcommand">0</font>. So, to access the first element the command is <font class="bashcommand">echo ${ARRAY[0]}</font>, to access the second element <font class="bashcommand">echo ${ARRAY[1]}</font>, etc. Type <font class="bashcommand">echo ${ARRAY[@]}</font> to view all elements and to obtain the number of elements (size of <font class="bashcommand">ARRAY</font>).<br>
				Remember, the system variable <font class="bashcommand">IFS</font> contains the separator that is being used to separate each feld within the lines of a file. You can change the value of this variable at any time: <font class="bashcommand">IFS='character'</font>
				</p>

				<table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ IFS=$'\n'<br>
						$ ARRAY=($(awk '{print $2}' file2.txt))<br>
						$ echo ${ARRAY[0]}<br> 
						<font class="bashcommand-result">"SubjectGroup"</font><br>
						$ echo ${ARRAY[1]}<br>
						<font class="bashcommand-result">"Group2b"</font><br>
						$ echo ${ARRAY[@]}<br>
						<font class="bashcommand-result">"SubjectGroup" "Group2b" "Group1" "Group1" "Group1" "Group1" "Group2b" "Group1" "Group1" "Group3" "Group4" "Group1" "Group2b" "Group1" "Group3" "Group2b" "Group2b" "Group3" "Group2b" "Group1" "Group1" "Group1" "Group1" "Group3" "Group2b" "Group2b" "Group1" "Group1" "Group1"</font><br>
						$ echo ${#ARRAY[@]}<br>
						<font class="bashcommand-result">29</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ IFS=$'\n'<br>
						$ ARRAY=($(awk -F',' '{print $2}' file1.csv))<br>
						$ echo ${ARRAY[0]}<br>
						<font class="bashcommand-result">"Subject Group"</font><br>
						$ echo ${ARRAY[1]}<br>
						<font class="bashcommand-result">"Group1"</font><br>
						$ echo ${ARRAY[@]}<br>
						<font class="bashcommand-result">"Subject Group" "Group1" "Group3" "Group1" "Group2 b" "Group2 b" "Group3" "Group1" "Group2 b" "Group1" "Group3" "Group3" "Group1" "Group1" "Group1" "Group3" "MISSING" "Group3" "Group1" "Group1" "Group1" "Group1" "Group2 b" "Group2 b" "Group1" "Group2 b" "Group3" "Group3" "Group1"</font><br>
						$ echo ${#ARRAY[@]}<br>
						<font class="bashcommand-result">29</font>
						</font></td>
					</tr>
				</table>

				<p>
				<font class="example">Print the first column of file2.txt followed by the first column of file4.txt.</font>
				To print a specific column for more than one file, you use the same command, adding the list of files you want to print after the first one. However, all the files in the list must use the same column separator (in this case is a space). Since the column separator for this list of files is a space (the default), you don't need to use the <font class="bashcommand">-F</font> flag.
				</p>

				<p>
				<font class="bashcommand">
				$ awk '{print $1}' file2.txt file4.txt<br>
				<font class="bashcommand-result">
				"AnonymizedID"<br>
				"B11130912"<br>
				"B11137244"<br>
				"B11154534"<br>
				"B11144100"<br>
				"B11137244"<br>
				"B12226566"<br>
				"B11134987"<br>
				"B11144345"<br>
				"C11137159"<br>
				"B11156453"<br>
				"B11110676"<br>
				"C11138929"<br>
				"B11154532"<br>
				"B11155267"<br>
				"B11137120"<br>
				"B33191224"<br>
				"B11155267"<br>
				"C11138999"<br>
				"B11131605"<br>
				"B11137784"<br>
				"B11156098"<br>
				"B11133232"<br>
				"B11135292"<br>
				"C11138912"<br>
				"B11150911"<br>
				"B11152577"<br>
				"B11156098"<br>
				"B11133232"<br>
				AnonymizedID<br>
				B11108326<br>
				B11110893<br>
				B11119909<br>
				D11144030<br>
				D11144030<br>
				B11119903<br>
				C11131039<br>
				C11133100<br>
				C11135566<br>
				C11137159<br>
				C11137159<br>
				C11137167<br>
				C11137167<br>
				C11137439<br>
				C11137439<br>
				C11137443<br>
				C11137544<br>
				C11137123<br>
				C11138150<br>
				C11138152<br>
				C11138797<br>
				C11138184<br>
				C11138122<br>
				C11138122<br>
				C11138192<br>
				B12226507<br>
				B12226546
				</font>
				</font>
				</p>

				<p>
				<font class="example">Print the first column of file3.csv followed by the first column of file1.csv.</font> 
				Since the column separator for this list of files is a comma, you need to use the <font class="bashcommand">-F','</font> flag.
				</p>

				<p>
				<font class="bashcommand">
				$ awk -F',' '{print $1}' file3.csv file1.csv<br>
				<font class="bashcommand-result">
				Anonymized ID<br>
				C11138122<br>
				C11138192<br>
				B12226507<br>
				B12226546<br>
				C11138122<br>
				C11138184<br>
				C11138797<br>
				C11138152<br>
				C11138150<br>
				C11137167<br>
				C11137159<br>
				C11137167<br>
				C11137159<br>
				C11131039<br>
				C11135566<br>
				B11119903<br>
				C11137544<br>
				C11137443<br>
				C11137123<br>
				C11137439<br>
				C11137439<br>
				C11133100<br>
				D11144030<br>
				B11108399<br>
				B11108326<br>
				B11119909<br>
				B11110893<br>
				"Anonymized ID"<br>
				"B33199522"<br>
				"B33199603"<br>
				"B11137879"<br>
				"B11144410"<br>
				"B11110455"<br>
				"B11135291"<br>
				"B11153927"<br>
				"B11177579"<br>
				"B11177806"<br>
				"B11157958"<br>
				"B11110690"<br>
				"B11152799"<br>
				"B11154358"<br>
				"B11110925"<br>
				"B11135291"<br>
				"B11135072"<br>
				"B33199603"<br>
				"B11137879"<br>
				"B11110603"<br>
				"B11110927"<br>
				"B11147712"<br>
				"B33191224"<br>
				"B11131290"<br>
				"B11157974"<br>
				"B33191224"<br>
				"B11141503"<br>
				"C11137159"<br>
				"B33199522" 
				</font>
				</font>
				</p>

			<h3>9.8. Examples: Reading specific columns from a file or a list of files and sorting the result in alphabetical order and/or removing duplicate values</h3>
				<p>
				<font class="example">Print the first column of file1.csv and file2.txt <b>in alphabetical order</b>.</font>
				In order to do this, you sort the result after printing the first column. First, use <font class="bashcommand">awk</font> to print the desired column, followed by <font class="bashcommand">| sort</font> to sort it in alphabetical order. 
				</p>

				<p><table class="ghostTable">
				<tr>
					<th>Space-separated file</th>
					<th>Comma-separated file</th>
				</tr>
					
				<tr>
					<td><font class="bashcommand">
					$ awk '{print $1}' file2.txt | sort<br>
					<font class="bashcommand-result">
					"AnonymizedID"<br>
					"B11110676"<br>
					"B11130912"<br>
					"B11131605"<br>
					"B11133232"<br>
					"B11133232"<br>
					"B11134987"<br>
					"B11135292"<br>
					"B11137120"<br>
					"B11137244"<br>
					"B11137244"<br>
					"B11137784"<br>
					"B11144100"<br>
					"B11144345"<br>
					"B11150911"<br>
					"B11152577"<br>
					"B11154532"<br>
					"B11154534"<br>
					"B11155267"<br>
					"B11155267"<br>
					"B11156098"<br>
					"B11156098"<br>
					"B11156453"<br>
					"B12226566"<br>
					"B33191224"<br>
					"C11137159"<br>
					"C11138912"<br>
					"C11138929"<br>
					"C11138999"
					</font>
					</font></td>
					
					<td><font class="bashcommand">
					$ awk -F ',' '{print $1}' file1.csv | sort<br>
					<font class="bashcommand-result">
					"Anonymized ID"<br>
					"B11110455"<br>
					"B11110603"<br>
					"B11110690"<br>
					"B11110925"<br>
					"B11110927"<br>
					"B11131290"<br>
					"B11135072"<br>
					"B11135291"<br>
					"B11135291"<br>
					"B11137879"<br>
					"B11137879"<br>
					"B11141503"<br>
					"B11144410"<br>
					"B11147712"<br>
					"B11152799"<br>
					"B11153927"<br>
					"B11154358"<br>
					"B11157958"<br>
					"B11157974"<br>
					"B11177579"<br>
					"B11177806"<br>
					"B33191224"<br>
					"B33191224"<br>
					"B33199522"<br>
					"B33199522"<br>
					"B33199603"<br>
					"B33199603"<br>
					"C11137159"
					</font>
					</font></td>
				</tr>
				</table></p>

				<p>
				<font class="example">Print the first column of file1.csv and file2.txt <b>in alphabetical removing any duplicate values</b>.</font>
				In order to do this, you remove the duplicates after printing and sorting the first column. First, use <font class="bashcommand">awk</font> to print the desired column, followed by <font class="bashcommand">sort | uniq</font> to sort and remove the duplicates on the result.
				</p>

				<p><table class="ghostTable">
				<tr>
					<th>Space-separated file</th>
					<th>Comma-separated file</th>
				</tr>
					
				<tr>
					<td><font class="bashcommand">
					$ awk '{print $1}' file2.txt | sort | uniq<br>
					<font class="bashcommand-result">
					"AnonymizedID"<br>
					"B11130912"<br>
					"B11137244"<br>
					"B11154534"<br>
					"B11144100"<br>
					"B11137244"<br>
					"B12226566"<br>
					"B11134987"<br>
					"B11144345"<br>
					"C11137159"<br>
					"B11156453"<br>
					"B11110676"<br>
					"C11138929"<br>
					"B11154532"<br>
					"B11155267"<br>
					"B11137120"<br>
					"B33191224"<br>
					"B11155267"<br>
					"C11138999"<br>
					"B11131605"<br>
					"B11137784"<br>
					"B11156098"<br>
					"B11133232"<br>
					"B11135292"<br>
					"C11138912"<br>
					"B11150911"<br>
					"B11152577"<br>
					"B11156098"<br>
					"B11133232"
					</font>
					</font></td>	
					
					<td><font class="bashcommand">
					$ awk -F ',' '{print $1}' file1.csv | sort | uniq<br>
					<font class="bashcommand-result">
					"Anonymized ID"<br>
					"B33199522"<br>
					"B33199603"<br>
					"B11137879"<br>
					"B11144410"<br>
					"B11110455"<br>
					"B11135291"<br>
					"B11153927"<br>
					"B11177579"<br>
					"B11177806"<br>
					"B11157958"<br>
					"B11110690"<br>
					"B11152799"<br>
					"B11154358"<br>
					"B11110925"<br>
					"B11135291"<br>
					"B11135072"<br>
					"B33199603"<br>
					"B11137879"<br>
					"B11110603"<br>
					"B11110927"<br>
					"B11147712"<br>
					"B33191224"<br>
					"B11131290"<br>
					"B11157974"<br>
					"B33191224"<br>
					"B11141503"<br>
					"C11137159"<br>
					"B33199522"
					</font>
					</font></td>
				</tr>
				</table></p>

				<p>
				Print the first column of file1.csv and file3.csv combined, in alphabetical order and with no duplicates.<br>
				As explained in a previous example, to print the first column of file1.csv and file3.csv combined just use the command <font class="bashcommand">awk</font> with the list of files to be read (file1.csv file3.csv) at the end of the command. Then, use <font class="bashcommand">| sort</font> to organize the output in alphabetical order, and finally use <font class="bashcommand">| uniq</font> to remove the duplicates. 
				</p>

				<p>In this case, because the strings in file1.csv all start by colons (<font class="bashcommand">"</font>), while the values in file3.csv don't, then all the values of file1.csv will be printed before those of file3.csv (because alphabetically, special characters such as <font class="bashcommand">"</font> go before any letter (including <font class="bashcommand">A</font>). So, for bash <font class="bashcommand">"B11110455"</font> goes before <font class="bashcommand">Anonymized ID</font>.</p>

				<p><font class="bashcommand">
				$ awk -F ',' '{print $1}' file1.csv file3.csv | sort | uniq<br>
				<font class="bashcommand-result">
				"Anonymized ID"<br>
				"B11110455"<br>
				"B11110603"<br>
				"B11110690"<br>
				"B11110925"<br>
				"B11110927"<br>
				"B11131290"<br>
				"B11135072"<br>
				"B11135291"<br>
				"B11137879"<br>
				"B11141503"<br>
				"B11144410"<br>
				"B11147712"<br>
				"B11152799"<br>
				"B11153927"<br>
				"B11154358"<br>
				"B11157958"<br>
				"B11157974"<br>
				"B11177579"<br>
				"B11177806"<br>
				"B33191224"<br>
				"B33199522"<br>
				"B33199603"<br>
				"C11137159"<br>
				Anonymized ID<br>
				B11108326<br>
				B11108399<br>
				B11110893<br>
				B11119903<br>
				B11119909<br>
				B12226507<br>
				B12226546<br>
				C11131039<br>
				C11133100<br>
				C11135566<br>
				C11137123<br>
				C11137159<br>
				C11137167<br>
				C11137439<br>
				C11137443<br>
				C11137544<br>
				C11138122<br>
				C11138150<br>
				C11138152<br>
				C11138184<br>
				C11138192<br>
				C11138797<br>
				D11144030
				</font>
				</font></p>

			<h3>9.9. Examples: Reading all the columns from multiple files and concatenating them horizontally</h3>
				<p>
				<font class="example">Concatenate all the columns of file2.txt and file4.txt horizontally</font>
				Print the columns of one file next to the columns of the previous one, using a space as separator between the columns of one file and the other.
				</p>

				<p><font class="bashcommand">
				$ paste -d ' ' file2.txt file4.txt<br>
				<font class="bashcommand-result">
				"AnonymizedID" "SubjectGroup" "TEST1" "TEST2" AnonymizedID SubjectGroup AGE<br>
				B11108399 Group1 23b" "900" "MissingData" B11108326 Group1 59<br>
				"B11137244" "Group1" "450" "555" B11110893 Group1 28<br>
				"B11154534" "Group1" "456" "456" B11119909 Group2 61<br>
				"B11144100" "Group1" "450" "886" D11144030 Group3 11<br>
				"B11137244" "Group1" "450" "456" D11144030 Group3 13<br>
				"B12226566" "Group2b" "450" "MissingData" B11119903 Group2 84<br>
				"B11134987" "Group1" "900" "MissingData" C11131039 Group2 67<br>
				"B11144345" "Group1" "900" "776" C11133100 Group1 23<br>
				"C11137159" "Group3" "MissingData" "MissingData" C11135566 Group2 72<br>
				"B11156453" "Group4" "456" "2" C11137159 Group3 11<br>
				"B11110676" "Group1" "900" "10" C11137159 Group3 12<br>
				"C11138929" "Group2b" "2" "MissingData" C11137167 Group3 14<br>
				"B11154532" "Group1" "456" "886" C11137167 Group3 16<br>
				"B11155267" "Group3" "900" "10" C11137439 Group3 15<br>
				"B11137120" "Group2b" "450" "456" C11137439 Group3 79<br>
				"B33191224" "Group2b" "450" "776" C11137443 Group3 15<br>
				"B11155267" "Group3" "900" "10" C11137544 Group1 22<br>
				"C11138999" "Group2b" "900" "MissingData" C11137123 Group2 68<br>
				"B11131605" "Group1" "456" "MissingData" C11138150 Group1 44<br>
				"B11137784" "Group1" "900" "436" C11138152 Group1 10<br>
				"B11156098" "Group1" "500" "886" C11138797 Group1 24<br>
				"B11133232" "Group1" "500" "MissingData" C11138184 Group1 57<br>
				"B11135292" "Group3" "MissingData" "MissingData" C11138122 Group1 23<br>
				"C11138912" "Group2b" "900" "MissingData" C11138122 MISSING 25<br>
				"B11150911" "Group2b" "900" "117" C11138192 Group1 45<br>
				"B11152577" "Group1" "900" "756" B12226507 Group1 26<br>
				"B11156098" "Group1" "456" "886" B12226546 Group1 55<br>
				"B11133232" "Group1" "456" "MissingData" 
				</font>
				</font></p>

				<p>
				<font class="example">Concatenate all the columns of file2.txt and file4.txt horizontally.</font>
				Use a semicolon (<font class="bashcommand">;</font>) as separator between the columns of one file and the other.
				</p>

				<p><font class="bashcommand">
				$ paste -d ';' file2.txt file4.txt<br>
				<font class="bashcommand-result">
				"AnonymizedID" "SubjectGroup" "TEST1" "TEST2";AnonymizedID SubjectGroup AGE<br>
				B11108399 Group1 23b" "900" "MissingData";B11108326 Group1 59<br>
				"B11137244" "Group1" "450" "555";B11110893 Group1 28<br>
				"B11154534" "Group1" "456" "456";B11119909 Group2 61<br>
				"B11144100" "Group1" "450" "886";D11144030 Group3 11<br>
				"B11137244" "Group1" "450" "456";D11144030 Group3 13<br>
				"B12226566" "Group2b" "450" "MissingData";B11119903 Group2 84<br>
				"B11134987" "Group1" "900" "MissingData";C11131039 Group2 67<br>
				"B11144345" "Group1" "900" "776";C11133100 Group1 23<br>
				"C11137159" "Group3" "MissingData" "MissingData";C11135566 Group2 72<br>
				"B11156453" "Group4" "456" "2";C11137159 Group3 11<br>
				"B11110676" "Group1" "900" "10";C11137159 Group3 12<br>
				"C11138929" "Group2b" "2" "MissingData";C11137167 Group3 14<br>
				"B11154532" "Group1" "456" "886";C11137167 Group3 16<br>
				"B11155267" "Group3" "900" "10";C11137439 Group3 15<br>
				"B11137120" "Group2b" "450" "456";C11137439 Group3 79<br>
				"B33191224" "Group2b" "450" "776";C11137443 Group3 15<br>
				"B11155267" "Group3" "900" "10";C11137544 Group1 22<br>
				"C11138999" "Group2b" "900" "MissingData";C11137123 Group2 68<br>
				"B11131605" "Group1" "456" "MissingData";C11138150 Group1 44<br>
				"B11137784" "Group1" "900" "436";C11138152 Group1 10<br>
				"B11156098" "Group1" "500" "886";C11138797 Group1 24<br>
				"B11133232" "Group1" "500" "MissingData";C11138184 Group1 57<br>
				"B11135292" "Group3" "MissingData" "MissingData";C11138122 Group1 23<br>
				"C11138912" "Group2b" "900" "MissingData";C11138122 MISSING 25<br>
				"B11150911" "Group2b" "900" "117";C11138192 Group1 45<br>
				"B11152577" "Group1" "900" "756";B12226507 Group1 26<br>
				"B11156098" "Group1" "456" "886";B12226546 Group1 55<br>
				"B11133232" "Group1" "456" "MissingData"; 
				</font>
				</font></p>

				<p>
				<font class="example">Concatenate all the columns of file2.txt and file4.txt horizontally.</font>
				Use a tab (<font class="bashcommand">\t</font>) as separator between the columns of one file and the other.
				</p>

				<p><font class="bashcommand">
				$ paste -d '\t' file2.txt file4.txt<br>
				<font class="bashcommand-result">
				"AnonymizedID" "SubjectGroup" "TEST1" "TEST2"&emsp;AnonymizedID SubjectGroup AGE<br>
				"B11108399" "Group1" "23b" "900" "MissingData"&emsp;B11108326 Group1 59<br>
				"B11137244" "Group1" "450" "555"&emsp;B11110893 Group1 28<br>
				"B11154534" "Group1" "456" "456"&emsp;B11119909 Group2 61<br>
				"B11144100" "Group1" "450" "886"&emsp;D11144030 Group3 11<br>
				"B11137244" "Group1" "450" "456"&emsp;D11144030 Group3 13<br>
				"B12226566" "Group2b" "450" "MissingData"&emsp;B11119903 Group2 84<br>
				"B11134987" "Group1" "900" "MissingData"&emsp;C11131039 Group2 67<br>
				"B11144345" "Group1" "900" "776"&emsp;C11133100 Group1 23<br>
				"C11137159" "Group3" "MissingData" "MissingData"&emsp;C11135566 Group2 72<br>
				"B11156453" "Group4" "456" "2"&emsp;C11137159 Group3 11<br>
				"B11110676" "Group1" "900" "10"&emsp;C11137159 Group3 12<br>
				"C11138929" "Group2b" "2" "MissingData"&emsp;C11137167 Group3 14<br>
				"B11154532" "Group1" "456" "886"&emsp;C11137167 Group3 16<br>
				"B11155267" "Group3" "900" "10"&emsp;C11137439 Group3 15<br>
				"B11137120" "Group2b" "450" "456"&emsp;C11137439 Group3 79<br>
				"B33191224" "Group2b" "450" "776"&emsp;C11137443 Group3 15<br>
				"B11155267" "Group3" "900" "10"&emsp;C11137544 Group1 22<br>
				"C11138999" "Group2b" "900" "MissingData"&emsp;C11137123 Group2 68<br>
				"B11131605" "Group1" "456" "MissingData"&emsp;C11138150 Group1 44<br>
				"B11137784" "Group1" "900" "436"&emsp;C11138152 Group1 10<br>
				"B11156098" "Group1" "500" "886"&emsp;C11138797 Group1 24<br>
				"B11133232" "Group1" "500" "MissingData"&emsp;C11138184 Group1 57<br>
				"B11135292" "Group3" "MissingData" "MissingData"&emsp;C11138122 Group1 23<br>
				"C11138912" "Group2b" "900" "MissingData"&emsp;C11138122 MISSING 25<br>
				"B11150911" "Group2b" "900" "117"&emsp;C11138192 Group1 45<br>
				"B11152577" "Group1" "900" "756"&emsp;B12226507 Group1 26<br>
				"B11156098" "Group1" "456" "886"&emsp;B12226546 Group1 55<br>
				"B11133232" "Group1" "456" "MissingData" 
				</font>
				</font></p>

				<p>
				<font class="example">Concatenate all the columns of file2.txt and file4.txt horizontally</font>
				Use an empty string as separator between the columns of one file and the other.
				</p>

				<p><font class="bashcommand">
				$ paste -d '\0' file2.txt file4.txt<br>
				<font class="bashcommand-result">
				"AnonymizedID" "SubjectGroup" "TEST1" "TEST2"AnonymizedID SubjectGroup AGE<br>
				B11108399 Group1 23b" "900" "MissingData"B11108326 Group1 59<br>
				"B11137244" "Group1" "450" "555"B11110893 Group1 28<br>
				"B11154534" "Group1" "456" "456"B11119909 Group2 61<br>
				"B11144100" "Group1" "450" "886"D11144030 Group3 11<br>
				"B11137244" "Group1" "450" "456"D11144030 Group3 13<br>
				"B12226566" "Group2b" "450" "MissingData"B11119903 Group2 84<br>
				"B11134987" "Group1" "900" "MissingData"C11131039 Group2 67<br>
				"B11144345" "Group1" "900" "776"C11133100 Group1 23<br>
				"C11137159" "Group3" "MissingData" "MissingData"C11135566 Group2 72<br>
				"B11156453" "Group4" "456" "2"C11137159 Group3 11<br>
				"B11110676" "Group1" "900" "10"C11137159 Group3 12<br>
				"C11138929" "Group2b" "2" "MissingData"C11137167 Group3 14<br>
				"B11154532" "Group1" "456" "886"C11137167 Group3 16<br>
				"B11155267" "Group3" "900" "10"C11137439 Group3 15<br>
				"B11137120" "Group2b" "450" "456"C11137439 Group3 79<br>
				"B33191224" "Group2b" "450" "776"C11137443 Group3 15<br>
				"B11155267" "Group3" "900" "10"C11137544 Group1 22<br>
				"C11138999" "Group2b" "900" "MissingData"C11137123 Group2 68<br>
				"B11131605" "Group1" "456" "MissingData"C11138150 Group1 44<br>
				"B11137784" "Group1" "900" "436"C11138152 Group1 10<br>
				"B11156098" "Group1" "500" "886"C11138797 Group1 24<br>
				"B11133232" "Group1" "500" "MissingData"C11138184 Group1 57<br>
				"B11135292" "Group3" "MissingData" "MissingData"C11138122 Group1 23<br>
				"C11138912" "Group2b" "900" "MissingData"C11138122 MISSING 25<br>
				"B11150911" "Group2b" "900" "117"C11138192 Group1 45<br>
				"B11152577" "Group1" "900" "756"B12226507 Group1 26<br>
				"B11156098" "Group1" "456" "886"B12226546 Group1 55<br>
				"B11133232" "Group1" "456" "MissingData"
				</font>
				</font></p>

				<p>
				<font class="example">Concatenate all the columns of file2.txt and file4.txt horizontally</font>
				Use a backslash character (<font class="bashcommand">\</font>) as separator between the columns of one file and the other.
				</p>

				<p><font class="bashcommand">
				$ paste -d '\\' file2.txt file4.txt<br>
				<font class="bashcommand-result">
				"AnonymizedID" "SubjectGroup" "TEST1" "TEST2"\AnonymizedID SubjectGroup AGE<br>
				B11108399 Group1 23b" "900" "MissingData"\B11108326 Group1 59<br>
				"B11137244" "Group1" "450" "555"\B11110893 Group1 28<br>
				"B11154534" "Group1" "456" "456"\B11119909 Group2 61<br>
				"B11144100" "Group1" "450" "886"\D11144030 Group3 11<br>
				"B11137244" "Group1" "450" "456"\D11144030 Group3 13<br>
				"B12226566" "Group2b" "450" "MissingData"\B11119903 Group2 84<br>
				"B11134987" "Group1" "900" "MissingData"\C11131039 Group2 67<br>
				"B11144345" "Group1" "900" "776"\C11133100 Group1 23<br>
				"C11137159" "Group3" "MissingData" "MissingData"\C11135566 Group2 72<br>
				"B11156453" "Group4" "456" "2"\C11137159 Group3 11<br>
				"B11110676" "Group1" "900" "10"\C11137159 Group3 12<br>
				"C11138929" "Group2b" "2" "MissingData"\C11137167 Group3 14<br>
				"B11154532" "Group1" "456" "886"\C11137167 Group3 16<br>
				"B11155267" "Group3" "900" "10"\C11137439 Group3 15<br>
				"B11137120" "Group2b" "450" "456"\C11137439 Group3 79<br>
				"B33191224" "Group2b" "450" "776"\C11137443 Group3 15<br>
				"B11155267" "Group3" "900" "10"\C11137544 Group1 22<br>
				"C11138999" "Group2b" "900" "MissingData"\C11137123 Group2 68<br>
				"B11131605" "Group1" "456" "MissingData"\C11138150 Group1 44<br>
				"B11137784" "Group1" "900" "436"\C11138152 Group1 10<br>
				"B11156098" "Group1" "500" "886"\C11138797 Group1 24<br>
				"B11133232" "Group1" "500" "MissingData"\C11138184 Group1 57<br>
				"B11135292" "Group3" "MissingData" "MissingData"\C11138122 Group1 23<br>
				"C11138912" "Group2b" "900" "MissingData"\C11138122 MISSING 25<br>
				"B11150911" "Group2b" "900" "117"\C11138192 Group1 45<br>
				"B11152577" "Group1" "900" "756"\B12226507 Group1 26<br>
				"B11156098" "Group1" "456" "886"\B12226546 Group1 55<br>
				"B11133232" "Group1" "456" "MissingData"\ 
				</font>
				</font></p>

				<p>
				<font class="example">Concatenate all the columns of file2.txt and file4.txt</font>
				Use a newline character (<font class="bashcommand">\n</font>) as separator between the columns of one file and the other. As a result, the two files will be interlined. In the output you will have the first line of file2.txt followed by the first line of file4.txt, followed by the second line of file2.txt, then the second line of file4.txt. etc.
				</p>

				<p><font class="bashcommand">
				$ paste -d '\n' file2.txt file4.txt<br>
				<font class="bashcommand-result">
				"AnonymizedID" "SubjectGroup" "TEST1" "TEST2"<br>
				AnonymizedID SubjectGroup AGE<br>
				"B11130912" "Group2b" "900" "MissingData"<br>
				B11108399 Group1 23<br>
				"B11137244" "Group1" "450" "555"<br>
				B11110893 Group1 28<br>
				"B11154534" "Group1" "456" "456"<br>
				B11119909 Group2 61<br>
				"B11144100" "Group1" "450" "886"<br>
				D11144030 Group3 11<br>
				"B11137244" "Group1" "450" "456"<br>
				D11144030 Group3 13<br>
				"B12226566" "Group2b" "450" "MissingData"<br>
				B11119903 Group2 84<br>
				"B11134987" "Group1" "900" "MissingData"<br>
				C11131039 Group2 67<br>
				"B11144345" "Group1" "900" "776"<br>
				C11133100 Group1 23<br>
				"C11137159" "Group3" "MissingData" "MissingData"<br>
				C11135566 Group2 72<br>
				"B11156453" "Group4" "456" "2"<br>
				C11137159 Group3 11<br>
				"B11110676" "Group1" "900" "10"<br>
				C11137159 Group3 12<br>
				"C11138929" "Group2b" "2" "MissingData"<br>
				C11137167 Group3 14<br>
				"B11154532" "Group1" "456" "886"<br>
				C11137167 Group3 16<br>
				"B11155267" "Group3" "900" "10"<br>
				C11137439 Group3 15<br>
				"B11137120" "Group2b" "450" "456"<br>
				C11137439 Group3 79<br>
				"B33191224" "Group2b" "450" "776"<br>
				C11137443 Group3 15<br>
				"B11155267" "Group3" "900" "10"<br>
				C11137544 Group1 22<br>
				"C11138999" "Group2b" "900" "MissingData"<br>
				C11137123 Group2 68<br>
				"B11131605" "Group1" "456" "MissingData"<br>
				C11138150 Group1 44<br>
				"B11137784" "Group1" "900" "436"<br>
				C11138152 Group1 10<br>
				"B11156098" "Group1" "500" "886"<br>
				C11138797 Group1 24<br>
				"B11133232" "Group1" "500" "MissingData"<br>
				C11138184 Group1 57<br>
				"B11135292" "Group3" "MissingData" "MissingData"<br>
				C11138122 Group1 23<br>
				"C11138912" "Group2b" "900" "MissingData"<br>
				C11138122 MISSING 25<br>
				"B11150911" "Group2b" "900" "117"<br>
				C11138192 Group1 45<br>
				"B11152577" "Group1" "900" "756"<br>
				B12226507 Group1 26<br>
				"B11156098" "Group1" "456" "886"<br>
				B12226546 Group1 55<br>
				"B11133232" "Group1" "456" "MissingData"
				</font>
				</font></p>

				<p>
				<font class="example">Concatenate all the columns of file1.csv and file3.csv horizontally</font>
				Use a comma as separator between the columns of one file and the other.
				</p>

				<p><font class="bashcommand">
				$ paste -d ' ' test1.csv test2.csv test6.csv<br>
				<font class="bashcommand-result">
				"Anonymized ID","Subject Group","HASCONDITION","CONDITION",Anonymized ID,Subject Group,AGE<br>
				"B33199522","Group1","0","",C11138122,MISSING,21<br>
				"B33199603","Group3","0","",C11138192,Group1,54<br>
				"B11137879","Group1","0","",B12226507,Group1,68<br>
				"B11144410","Group2 b","0","",B12226546,Group1,67<br>
				"B11110455","Group2 b","0","",C11138122,Group1,24<br>
				"B11135291","Group3","0","",C11138184,Group1,59<br>
				"B11153927","Group1","0","",C11138797,Group1,22<br>
				"B11177579","Group2 b","0","",C11138152,Group1,53<br>
				"B11177806","Group1","MD","",C11138150,Group1,41<br>
				"B11157958","Group3","0","",C11137167,Group3,14<br>
				"B11110690","Group3","0","",C11137159,Group3,13<br>
				"B11152799","Group1","0","",C11137167,Group3,16<br>
				"B11154358","Group1","0","",C11137159,Group3,13<br>
				"B11110925","Group1","0","",C11131039,Group2 b,67<br>
				"B11135291","Group3","9","mTBI",C11135566,Group2 b,73<br>
				"B11135072","MISSING","0","",B11119903,Group2 b,83<br>
				"B33199603","Group3","0","",C11137544,Group1,21<br>
				"B11137879","Group1","0","",C11137443,Group3,11<br>
				"B11110603","Group1","0","",C11137123,Group2 b,69<br>
				"B11110927","Group1","0","",C11137439,Group3,79<br>
				"B11147712","Group1","0","",C11137439,Group3,15<br>
				"B33191224","Group2 b","0","",C11133100,Group1,23<br>
				"B11131290","Group2 b","0","",D11144030,Group3,13<br>
				"B11157974","Group1","0","",B11108399,Group1,23<br>
				"B33191224","Group2 b","0","",B11108326,Group1,59<br>
				"B11141503","Group3","0","",B11119909,Group2 b,61<br>
				"C11137159","Group3","9","mTBI",B11110893,Group1,28<br>
				"B33199522","Group1","0","",
				</font>
				</font></p>

				<h3>9.10. Examples: Reading specific columns from multiple files and concatenating them horizontally (in different columns).</h3>

				<p>
				<font class="example">Print the first column of file2.txt followed (horizontally) by the second column of file4.txt.</font>
				As we learned in previous examples, the command <font class="bashcommand">awk '{print $1}' file2.txt</font> will read and print the first column of file2.txt. Conversely, <font class="bashcommand">awk '{print $2}' file4.txt</font> will read and print the second column of file4.txt.<br>
				You must use the following syntax to concatenate these two results horizontally:
				</p>

				<p><font class="bashcommand">
				$ paste <(awk '{print $1}' file2.txt) <(awk '{print $2}' file4.txt)<br>
				<font class="bashcommand-result">
				"AnonymizedID"&emsp;SubjectGroup<br>
				"B11130912"&emsp;Group1<br>
				"B11137244"&emsp;Group1<br>
				"B11154534"&emsp;Group2<br>
				"B11144100"&emsp;Group3<br>
				"B11137244"&emsp;Group3<br>
				"B12226566"&emsp;Group2<br>
				"B11134987"&emsp;Group2<br>
				"B11144345"&emsp;Group1<br>
				"C11137159"&emsp;Group2<br>
				"B11156453"&emsp;Group3<br>
				"B11110676"&emsp;Group3<br>
				"C11138929"&emsp;Group3<br>
				"B11154532"&emsp;Group3<br>
				"B11155267"&emsp;Group3<br>
				"B11137120"&emsp;Group3<br>
				"B33191224"&emsp;Group3<br>
				"B11155267"&emsp;Group1<br>
				"C11138999"&emsp;Group2<br>
				"B11131605"&emsp;Group1<br>
				"B11137784"&emsp;Group1<br>
				"B11156098"&emsp;Group1<br>
				"B11133232"&emsp;Group1<br>
				"B11135292"&emsp;Group1<br>
				"C11138912"&emsp;MISSING<br>
				"B11150911"&emsp;Group1<br>
				"B11152577"&emsp;Group1<br>
				"B11156098"&emsp;Group1<br>
				"B11133232" 	
				</font>
				</font></p>

				<p>
				<font class="example">Print the first column of file1.csv followed (horizontally) by the second column of file3.csv. Separate the columns with a comma.</font>
				In this example, we use the same syntax as the example before, but remember that files file1.csv and file3.csv use comma as the column separator and you have to use the <font class="bashcommand">-F','</font> flag in the <font class="bashcommand">awk</font> commands. Additionally, remember to use the flag <font class="bashcommand">-d ','</font> for the paste command in order to separate the pasted columns with a comma.
				</p>

				<p><font class="bashcommand">
				$ paste -d ',' <(awk -F',' '{print $1}' file1.csv) <(awk -F',' '{print $2}' file3.csv)<br>
				<font class="bashcommand-result">
				"Anonymized ID",Subject Group<br>
				"B33199522",MISSING<br>
				"B33199603",Group1<br>
				"B11137879",Group1<br>
				"B11144410",Group1<br>
				"B11110455",Group1<br>
				"B11135291",Group1<br>
				"B11153927",Group1<br>
				"B11177579",Group1<br>
				"B11177806",Group1<br>
				"B11157958",Group3<br>
				"B11110690",Group3<br>
				"B11152799",Group3<br>
				"B11154358",Group3<br>
				"B11110925",Group2 b<br>
				"B11135291",Group2 b<br>
				"B11135072",Group2 b<br>
				"B33199603",Group1<br>
				"B11137879",Group3<br>
				"B11110603",Group2 b<br>
				"B11110927",Group3<br>
				"B11147712",Group3<br>
				"B33191224",Group1<br>
				"B11131290",Group3<br>
				"B11157974",Group1<br>
				"B33191224",Group1<br>
				"B11141503",Group2 b<br>
				"C11137159",Group1<br>
				"B33199522",
				</font>
				</font></p>

				<h3>9.11. Reading specific lines from one or more files.</h3>

				<p>
				<font class="example">Print the <b>first</b> line of file1.csv</font>
				In order to print the first line of the file we first read it using the <font class="bashcommand">cat</font> command, and then we select the first line from the previous output using <font class="bashcommand">head -n 1</font>.
				</p>

				<p><font class="bashcommand">
				$ cat file1.csv | head -n 1<br>
				<font class="bashcommand-result">
				"Anonymized ID","Subject Group","HASCONDITION","CONDITION" 
				</font>
				</font></p>

				<p>
				<font class="example">Print the <b>first two</b> lines of file1.csv</font>
				In order to print the first two lines of the file we first read it using the <font class="bashcommand">cat</font> command, and then we select those lines from the previous output using <font class="bashcommand">head -n 2</font>.
				</p>

				<p><font class="bashcommand">
				$ cat file1.csv | head -n 2<br>
				<font class="bashcommand-result">
				"Anonymized ID","Subject Group","HASCONDITION","CONDITION"<br>
				"B33199522","Group1","0","" 
				</font>
				</font></p>

				<font class="example">Print the <b>first three</b> lines of file1.csv</font>

				<p><font class="bashcommand">
				$ cat file1.csv | head -n 3<br>
				<font class="bashcommand-result">
				"Anonymized ID","Subject Group","HASCONDITION","CONDITION"<br>
				"B33199522","Group1","0",""<br>
				"B33199603","Group3","0","" 
				</font>
				</font></p>

				<p>
				<font class="example">Print the <b>last</b> line of file1.csv</font>
				In order to print the last line of the file we first read it using the <font class="bashcommand">cat</font> command, and then we select the last line from the previous output using <font class="bashcommand">tail -n 1</font>. 
				</p>

				<p><font class="bashcommand">
				$ cat file1.csv | tail -n 1<br>
				<font class="bashcommand-result">
				"B33199522","Group1","0","" 
				</font>
				</font></p>
			
				<font class="example">Print the <b>last two</b> lines of file1.csv</font>

				<p><font class="bashcommand">
				$ cat file1.csv | tail -n 2<br>
				<font class="bashcommand-result">
				"C11137159","Group3","9","mTBI"<br>
				"B33199522","Group1","0","" 
				</font>
				</font></p>

				<font class="example">Print the <b>last three</b> lines of file1.csv</font>

				<p><font class="bashcommand">
				$ cat file1.csv | tail -n 3<br>
				<font class="bashcommand-result">
				"B11141503","Group3","0",""<br>
				"C11137159","Group3","9","mTBI"<br>
				"B33199522","Group1","0",""
				</font>
				</font></p>

				<p>
				<font class="example">Print the <b>last three</b> lines of file1.csv in <b>reverse</b></font>
				As we learned previously, the flag <font class="bashcommand">-r</font> of <font class="bashcommand">tail</font> command can be used to print things in reversed order. 
				</p>

				<p><font class="bashcommand">
				$ cat file1.csv | tail -r -n 3<br>
				<font class="bashcommand-result">
				"B33199522","Group1","0",""<br>
				"C11137159","Group3","9","mTBI"<br>
				"B11141503","Group3","0","" 
				</font>
				</font></p>

				<font class="example">Print <b>from the beginning until the second line</b> of file1.csv (same result as printing the first two lines)</font>
				
				<p><font class="bashcommand">
				$ cat file1.csv | head -n+2<br>
				<font class="bashcommand-result">
				"Anonymized ID","Subject Group","HASCONDITION","CONDITION"<br>
				"B33199522","Group1","0","" 
				</font>
				</font></p>

				<font class="example">Print <b>from the beginning until the third line</b> of file1.csv (same result as printing the first three lines)</font>

				<p><font class="bashcommand">
				$ cat file1.csv | head -n+3<br>
				<font class="bashcommand-result">
				"Anonymized ID","Subject Group","HASCONDITION","CONDITION"<br>
				"B33199522","Group1","0",""<br>
				"B33199603","Group3","0","" 
				</font>
				</font></p>
					
				<font class="example">Print <b>from the second line until the last line</b> of file1.csv</font>

				<p><font class="bashcommand">
				$ cat file1.csv | tail -n+2<br>
				<font class="bashcommand-result">
				"B33199522","Group1","0",""<br>
				"B33199603","Group3","0",""<br>
				"B11137879","Group1","0",""<br>
				"B11144410","Group2 b","0",""<br>
				"B11110455","Group2 b","0",""<br>
				"B11135291","Group3","0",""<br>
				"B11153927","Group1","0",""<br>
				"B11177579","Group2 b","0",""<br>
				"B11177806","Group1","MD",""<br>
				"B11157958","Group3","0",""<br>
				"B11110690","Group3","0",""<br>
				"B11152799","Group1","0",""<br>
				"B11154358","Group1","0",""<br>
				"B11110925","Group1","0",""<br>
				"B11135291","Group3","9","mTBI"<br>
				"B11135072","MISSING","0",""<br>
				"B33199603","Group3","0",""<br>
				"B11137879","Group1","0",""<br>
				"B11110603","Group1","0",""<br>
				"B11110927","Group1","0",""<br>
				"B11147712","Group1","0",""<br>
				"B33191224","Group2 b","0",""<br>
				"B11131290","Group2 b","0",""<br>
				"B11157974","Group1","0",""<br>
				"B33191224","Group2 b","0",""<br>
				"B11141503","Group3","0",""<br>
				"C11137159","Group3","9","mTBI"<br>
				"B33199522","Group1","0","" 
				</font>
				</font></p>

				<font class="example">Print <b>from the third line until the last line</b> of file1.csv</font>

				<p><font class="bashcommand">
				$ cat file1.csv | tail -n+3<br>
				<font class="bashcommand-result">
				"B33199603","Group3","0",""<br>
				"B11137879","Group1","0",""<br>
				"B11144410","Group2 b","0",""<br>
				"B11110455","Group2 b","0",""<br>
				"B11135291","Group3","0",""<br>
				"B11153927","Group1","0",""<br>
				"B11177579","Group2 b","0",""<br>
				"B11177806","Group1","MD",""<br>
				"B11157958","Group3","0",""<br>
				"B11110690","Group3","0",""<br>
				"B11152799","Group1","0",""<br>
				"B11154358","Group1","0",""<br>
				"B11110925","Group1","0",""<br>
				"B11135291","Group3","9","mTBI"<br>
				"B11135072","MISSING","0",""<br>
				"B33199603","Group3","0",""<br>
				"B11137879","Group1","0",""<br>
				"B11110603","Group1","0",""<br>
				"B11110927","Group1","0",""<br>
				"B11147712","Group1","0",""<br>
				"B33191224","Group2 b","0",""<br>
				"B11131290","Group2 b","0",""<br>
				"B11157974","Group1","0",""<br>
				"B33191224","Group2 b","0",""<br>
				"B11141503","Group3","0",""<br>
				"C11137159","Group3","9","mTBI"<br>
				"B33199522","Group1","0","" 
				</font>
				</font></p>

				<h3>9.12. Examples: Reading specific columns or lines in a file or a list of files, that contain a searched value</h3>

				<font class="example">Print the line(s) of file3.csv that contain the string C11137439</font>

				<p>
				Using <font class="bashcommand">awk</font>:<br>
				<font class="bashcommand">
				$ awk '/C11137439/' file3.csv<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15 
				</font>
				</font>
				</p>

				<p>
				Using <font class="bashcommand">grep</font>:<br>
				<font class="bashcommand">
				$ grep C11137439 file3.csv<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15 
				</font>
				</font>
				</p>

				<p>
				<font class="example">Print the line(s) of file3.csv that contain the string AAA (which is <b>stored in a variable</b>)</font>
				<font class="bashcommand">$ VAR=C11137439</font>
				</p>

				<p>
				Using <font class="bashcommand">awk</font>:<br>
				<font class="bashcommand">
				$ awk -v var=$VAR '$0~var' file3.csv<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15 
				</font>
				</font>
				</p>

				<p>
				Using <font class="bashcommand">grep</font>:<br>
				<font class="bashcommand">
				$ grep $VAR file3.csv<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15 
				</font>
				</font>
				</p>

				<p>
				<font class="example">Print the line(s) of file3.csv that contain the strings C11137439 <b>or</b> B11119909</font>
				To search for more than one expression, add the flag <font class="bashcommand">-e</font> in front of each expression.
				</p>

				<p><font class="bashcommand">
				$ grep -e "C11137439" -e "B11119909" file3.csv<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				B11119909,Group2 b,61 
				</font>
				</font></p>

				<font class="example">Print the line(s) of file3.csv that contain the strings C11137439, B11119909 or B11110893</font>

				<p><font class="bashcommand">
				$ grep -e "C11137439" -e "B11119909" -e "B11110893" file3.csv<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				B11119909,Group2 b,61<br>
				B11110893,Group1,28 
				</font>
				</font></p>

				<font class="example">Print the line(s) of file3.csv that contain the strings C11137439 or B11119909 (which are <b>stored in a file</b> called patterns.txt)</font>

				<p><font class="bashcommand">
				$ cat patterns.txt<br>
				<font class="bashcommand-result">
				C11137439<br>
				B11119909 
				</font>
				</font></p>

				<p><font class="bashcommand">
				$ grep -f patterns.txt file3.csv<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				B11119909,Group2 b,61 
				</font>
				</font></p>

				<font class="example">Print the line(s) of file3.csv that <b>do not contain</b> the string C11137439</font>

				<p><font class="bashcommand">
				$ grep -v "C11137439" file3.csv<br>
				<font class="bashcommand-result">
				Anonymized ID,Subject Group,AGE<br>
				C11138122,MISSING,21<br>
				C11138192,Group1,54<br>
				B12226507,Group1,68<br>
				B12226546,Group1,67<br>
				C11138122,Group1,24<br>
				C11138184,Group1,59<br>
				C11138797,Group1,22<br>
				C11138152,Group1,53<br>
				C11138150,Group1,41<br>
				C11137167,Group3,14<br>
				C11137159,Group3,13<br>
				C11137167,Group3,16<br>
				C11137159,Group3,13<br>
				C11131039,Group2 b,67<br>
				C11135566,Group2 b,73<br>
				B11119903,Group2 b,83<br>
				C11137544,Group1,21<br>
				C11137443,Group3,11<br>
				C11137123,Group2 b,69<br>
				C11133100,Group1,23<br>
				D11144030,Group3,13<br>
				B11108399,Group1,23<br>
				B11108326,Group1,59<br>
				B11119909,Group2 b,61<br>
				B11110893,Group1,28 
				</font>
				</font></p>

				<font class="example">Print the line(s) of any file in the current directory that contain the string C11137439</font>

				<p><font class="bashcommand">
				$ awk '/C11137439/' *<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				C11137439 Group3 15<br>
				C11137439 Group3 79<br>
				C11137439 
				</font>
				</font></p>

				<p><font class="bashcommand">
				$ grep C11137439 *<br>
				<font class="bashcommand-result">
				file3.csv:C11137439,Group3,79<br>
				file3.csv:C11137439,Group3,15<br>
				file4.txt:C11137439 Group3 15<br>
				file4.txt:C11137439 Group3 79<br>
				patterns.txt:C11137439 
				</font>
				</font></p>

				<p>
				To omit the file names in the grep option, use the flag <font class="bashcommand">-h</font>:<br> 
				<font class="bashcommand">
				$ grep -h C11137439 *<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				C11137439 Group3 15<br>
				C11137439 Group3 79<br>
				C11137439 
				</font>
				</font>
				</p>

				<p>
				If you wanted to include the line number for each match, you can add the flag <font class="bashcommand">-n</font>:<br>
				<font class="bashcommand">
				$ grep -n "C11137439" *<br>
				<font class="bashcommand-result">
				file3.csv:21:C11137439,Group3,79<br>
				file3.csv:22:C11137439,Group3,15<br>
				file4.txt:15:C11137439 Group3 15<br>
				file4.txt:16:C11137439 Group3 79<br>
				patterns.txt:1:C11137439 
				</font>
				</font>
				</p>

				<p><font class="bashcommand">
				$ grep -h -n "C11137439" *<br>
				<font class="bashcommand-result">
				<b>21</b>:C11137439,Group3,79<br>
				<b>22</b>:C11137439,Group3,15<br>
				<b>15</b>:C11137439 Group3 15<br>
				<b>16</b>:C11137439 Group3 79<br>
				<b>1</b>:C11137439 
				</font>
				</font></p>

				<p>
				If you want to show only the first three matches, you can add the flag <font class="bashcommand">-m</font> with the parameter <font class="bashcommand">3</font> (to print only three lines):<br>
				<font class="bashcommand">
				$ grep -m 3 "C11137439" *<br>
				<font class="bashcommand-result">
				file3.csv:C11137439,Group3,79<br>
				file3.csv:C11137439,Group3,15<br>
				file4.txt:C11137439 Group3 15 
				</font>
				</font>
				</p>

				<p><font class="bashcommand">
				$ grep -m 3 "C11137439" * -h<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				C11137439 Group3 15 
				</font>
				</font></p>

				<font class="example">Print the number of lines in each file of the current directory that contain the string C11137439.</font>

				<p><font class="bashcommand">
				$ grep -c "C11137439" *<br>
				<font class="bashcommand-result">
				file1.csv:0<br>
				file1_reordered.csv:0<br>
				file2.txt:0<br>
				file3.csv:2<br>
				file4.txt:2<br>
				patterns.txt:1<br>
				patterns2.txt:0
				</font>
				</font></p>

				<font class="example">Print only the name of the files in the current directory that contain the string C11137439.</font>

				<p><font class="bashcommand">
				$ grep -l "C11137439" *<br>
				<font class="bashcommand-result">
				file3.csv<br>
				file4.txt<br>
				patterns.txt 
				</font>
				</font></p>

				<font class="example">Print the line(s) of any file in the current directory that contain the string C11137439, each line followed by the next three lines in the corresponding file (if there is three or more lines after the matched one).</font>
				
				<p><font class="bashcommand">
				$ grep -A 3 "C11137439" *<br>
				<font class="bashcommand-result">
				<b>file3.csv:C11137439,Group3,79<br>
				file3.csv:C11137439,Group3,15</b><br>
				file3.csv-C11133100,Group1,23<br>
				file3.csv-D11144030,Group3,13<br>
				file3.csv-B11108399,Group1,23<br> 
				<b>--<br>
				file4.txt:C11137439 Group3 15<br>
				file4.txt:C11137439 Group3 79</b><br>
				file4.txt-C11137443 Group3 15<br>
				file4.txt-C11137544 Group1 22<br>
				file4.txt-C11137123 Group2 68<br>
				<b>--<br>
				patterns.txt:C11137439</b><br>
				patterns.txt-B11119909 
				</font>
				</font></p>

				<font class="example">Print the line(s) of any file in the current directory that contain the string C11137439, each line preceded by the previous three lines in the corresponding file (if there is three or more lines before the matched one).</font>

				<p><font class="bashcommand">
				$ grep -B 3 "C11137439" *<br>
				<font class="bashcommand-result">
				file3.csv-C11137544,Group1,21<br>
				file3.csv-C11137443,Group3,11<br>
				file3.csv-C11137123,Group2 b,69<br>
				<b>file3.csv:C11137439,Group3,79<br>
				file3.csv:C11137439,Group3,15</b><br>
				--<br>
				file4.txt-C11137159 Group3 12<br>
				file4.txt-C11137167 Group3 14<br>
				file4.txt-C11137167 Group3 16<br>
				<b>file4.txt:C11137439 Group3 15<br> 
				file4.txt:C11137439 Group3 79</b><br>
				--<br>
				<b>patterns.txt:C11137439</b>
				</font>
				</font></p>

				<font class="example">Print the line(s) of any file in the current directory that contain the string C11137439, each line preceded by the previous three lines and followed by the next three lines in the corresponding file (if there is three or more lines before/after the matched one).</font>

				<p><font class="bashcommand">
				$ grep -C 3 "C11137439" *<br>
				<font class="bashcommand-result">
				file3.csv-C11137544,Group1,21<br>
				file3.csv-C11137443,Group3,11<br>
				file3.csv-C11137123,Group2 b,69<br>
				<b>file3.csv:C11137439,Group3,79<br>
				file3.csv:C11137439,Group3,15</b><br>
				file3.csv-C11133100,Group1,23<br>
				file3.csv-D11144030,Group3,13<br>
				file3.csv-B11108399,Group1,23<br>
				--<br>
				--<br>
				file4.txt-C11137159 Group3 12<br>
				file4.txt-C11137167 Group3 14<br>
				file4.txt-C11137167 Group3 16<br>
				<b>file4.txt:C11137439 Group3 15<br>
				file4.txt:C11137439 Group3 79</b><br>
				file4.txt-C11137443 Group3 15<br>
				file4.txt-C11137544 Group1 22<br>
				file4.txt-C11137123 Group2 68<br>
				--<br>
				--<br>
				<b>patterns.txt:C11137439</b><br>
				patterns.txt-B11119909 
				</font>
				</font></p>

				<p><font class="bashcommand">
				$ grep -A 3 -B 3 "C11137439" *<br>
				<font class="bashcommand-result">
				file3.csv-C11137544,Group1,21<br>
				file3.csv-C11137443,Group3,11<br>
				file3.csv-C11137123,Group2 b,69<br>
				<b>file3.csv:C11137439,Group3,79<br>
				file3.csv:C11137439,Group3,15</b><br>
				file3.csv-C11133100,Group1,23<br>
				file3.csv-D11144030,Group3,13<br>
				file3.csv-B11108399,Group1,23<br>
				--<br>
				--<br>
				file4.txt-C11137159 Group3 12<br>
				file4.txt-C11137167 Group3 14<br>
				file4.txt-C11137167 Group3 16<br>
				<b>file4.txt:C11137439 Group3 15<br>
				file4.txt:C11137439 Group3 79</b><br>
				file4.txt-C11137443 Group3 15<br>
				file4.txt-C11137544 Group1 22<br>
				file4.txt-C11137123 Group2 68<br>
				--<br>
				--<br>
				<b>patterns.txt:C11137439</b><br>
				patterns.txt-B11119909 
				</font>
				</font></p>

				<font class="example">Print the line(s) of any file in the current directory that contain the string "B11133232" (including the quotation marks ").</font>

				<p><font class="bashcommand">
				$ awk '/"B11133232"/' *<br>
				<font class="bashcommand-result">
				"B11133232" "Group1" "500" "MissingData"<br>
				"B11133232" "Group1" "456" "MissingData" 
				</font>
				</font></p>

				<p><font class="bashcommand">
				$ grep \"B11133232\" *<br>
				<font class="bashcommand-result"> 
				file2.txt:"B11133232" "Group1" "500" "MissingData"<br>
				file2.txt:"B11133232" "Group1" "456" "MissingData" 
				</font>
				</font></p>

				<p>With the <font class="bashcommand">grep</font> command, you must include the backslash (<font class="bashcommand">\</font>) before the quotation marks (<font class="bashcommand">\"</font>) if you want to search only those lines that contain the string that includes the quotation marks. Otherwise, it will interpret the search value as <font class="bashcommand">B11133232</font> and not <font class="bashcommand">"B11133232"</font>.</p>
		    
				<p>
				<font class="example">Print the line(s) of file3.csv that contain the values B11108399 or B11108326.</font>
				This search has the following rules: We're looking for words that start with the following seven characters: <font class="bashcommand">B111083</font>, the 8<sup>th</sup> character can be a <font class="bashcommand">9</font> or a <font class="bashcommand">2</font>, and the last character can be a <font class="bashcommand">9</font> or a <font class="bashcommand">6</font>. So, in the <font class="bashcommand">grep</font> command, we replace the 8<sup>th</sup> character by <font class="bashcommand">[92]</font> to indicate that it can have any of those two values, and the last character by <font class="bashcommand">[96]</font> to indicate that it can have value <font class="bashcommand">9</font> or <font class="bashcommand">6</font>.
				</p>

				<p><font class="bashcommand">
				$ grep B111083[92][96] file3.csv<br>
				<font class="bashcommand-result">
				B11108399,Group1,23<br>
				B11108326,Group1,59 
				</font>
				</font></p>

				<font class="example">Print the line(s) of file3.csv that contain the values <font class="bashcommand">Group1</font> or <font class="bashcommand">Group2</font>.</font>

				<p><font class="bashcommand">
				$ grep Group[12] file3.csv<br>
				<font class="bashcommand-result">
				C11138192,Group1,54<br>
				B12226507,Group1,68<br>
				B12226546,Group1,67<br>
				C11138122,Group1,24<br>
				C11138184,Group1,59<br>
				C11138797,Group1,22<br>
				C11138152,Group1,53<br>
				C11138150,Group1,41<br>
				C11131039,Group2 b,67<br>
				C11135566,Group2 b,73<br>
				B11119903,Group2 b,83<br>
				C11137544,Group1,21<br>
				C11137123,Group2 b,69<br>
				C11133100,Group1,23<br>
				B11108399,Group1,23<br>
				B11108326,Group1,59<br>
				B11119909,Group2 b,61<br>
				B11110893,Group1,28 
				</font>
				</font></p>

				<p>With the <font class="bashcommand">grep</font> command, you must include the backslash (<font class="bashcommand">\</font>) before the quotation marks (<font class="bashcommand">\"</font>) if you want to search only those lines that contain the string that includes the quotation marks. Otherwise, it will interpret the search value as <font class="bashcommand">B11133232</font> and not <font class="bashcommand">"B11133232"</font>.</p>
		    
				<p>
				<font class="example">Print the first column of file2.txt and file3.csv for those lines that contain the values <font class="bashcommand">Group1</font> or <font class="bashcommand">Group2</font>.</font>
				Remember that you have to use the flag <font class="bashcommand">-F','</font> with the command <font class="bashcommand">awk</font> when the columns of the file are separated by commas and not spaces. 
				</p>

				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ grep Group[12] file2.txt | awk '{print $1}'<br>
						<font class="bashcommand-result">
						"B11130912"<br>
						"B11137244"<br>
						"B11154534"<br>
						"B11144100"<br>
						"B11137244"<br>
						"B12226566"<br>
						"B11134987"<br>
						"B11144345"<br>
						"B11110676"<br>
						"C11138929"<br>
						"B11154532"<br>
						"B11137120"<br>
						"B33191224"<br>
						"C11138999"<br>
						"B11131605"<br>
						"B11137784"<br>
						"B11156098"<br>
						"B11133232"<br>
						"C11138912"<br>
						"B11150911"<br>
						"B11152577"<br>
						"B11156098"<br>
						"B11133232" 
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ grep Group[12] file3.csv | awk -F',' '{print $1}'<br>
						<font class="bashcommand-result">
						C11138192<br>
						B12226507<br>
						B12226546<br>
						C11138122<br>
						C11138184<br>
						C11138797<br>
						C11138152<br>
						C11138150<br>
						C11131039<br>
						C11135566<br>
						B11119903<br>
						C11137544<br>
						C11137123<br>
						C11133100<br>
						B11108399<br>
						B11108326<br>
						B11119909<br>
						B11110893
						</font>
						</font></td>
					</tr>
				</table></p>

				<font class="example">Print the first and second columns of file2.txt and file3.csv for those lines that contain the values <font class="bashcommand">Group1</font> or <font class="bashcommand">Group2</font>.</font>
		    
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ grep Group[12] file2.txt | awk '{print $1,$2}'<br>
						<font class="bashcommand-result">
						"B11130912" "Group2b"<br>
						"B11137244" "Group1"<br>
						"B11154534" "Group1"<br>
						"B11144100" "Group1"<br>
						"B11137244" "Group1"<br>
						"B12226566" "Group2b"<br>
						"B11134987" "Group1"<br>
						"B11144345" "Group1"<br>
						"B11110676" "Group1"<br>
						"C11138929" "Group2b"<br>
						"B11154532" "Group1"<br>
						"B11137120" "Group2b"<br>
						"B33191224" "Group2b"<br>
						"C11138999" "Group2b"<br>
						"B11131605" "Group1"<br>
						"B11137784" "Group1"<br>
						"B11156098" "Group1"<br>
						"B11133232" "Group1"<br>
						"C11138912" "Group2b"<br>
						"B11150911" "Group2b"<br>
						"B11152577" "Group1"<br>
						"B11156098" "Group1"<br>
						"B11133232" "Group1"
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ grep Group[12] file3.csv | awk -F',' '{print $1,$2}'<br>
						<font class="bashcommand-result">
						C11138192 Group1<br>
						B12226507 Group1<br>
						B12226546 Group1<br>
						C11138122 Group1<br>
						C11138184 Group1<br>
						C11138797 Group1<br>
						C11138152 Group1<br>
						C11138150 Group1<br>
						C11131039 Group2 b<br>
						C11135566 Group2 b<br>
						B11119903 Group2 b<br>
						C11137544 Group1<br>
						C11137123 Group2 b<br>
						C11133100 Group1<br>
						B11108399 Group1<br>
						B11108326 Group1<br>
						B11119909 Group2 b<br>
						B11110893 Group1
						</font>
						</font></td>
					</tr>
				</table></p>

				<h3>9.13. Examples: Reading lines of a file that contain the searched value in a specific column</h3>

				<font class="example">Print the line(s) of file3.csv and file4.txt that have value <font class="bashcommand">11</font> <u>in the third column</u>.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$3 == "11" {print $1,$2}' file4.txt<br>
						<font class="bashcommand-result">
						D11144030 Group3<br>
						C11137159 Group3 
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$3 == "11" {print $1,$2}' file3.csv<br>
						<font class="bashcommand-result">
						C11137443 Group3 
						</font>
						</font></td>
					</tr>
				</table></p>

				<font class="example">Print the first and second columns of those lines in file3.csv and file4.txt that have value <font class="bashcommand">11</font> <u>in the third column</u>.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$3 == "11" {print $1,$2}' file4.txt<br>
						<font class="bashcommand-result">
						D11144030 Group3<br>
						C11137159 Group3 
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$3 == "11" {print $1,$2}' file3.csv<br>
						<font class="bashcommand-result">
						C11137443 Group3 
						</font>
						</font></td>
					</tr>
				</table></p>

				<font class="example">Print the line(s) of file1.csv and file2.txt that have value <font class="bashcommand">"Group1"</font> (including the colons <font class="bashcommand">""</font>) <u>in the second column</u>.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$2 == "\"Group1\""' file2.txt<br>
						<font class="bashcommand-result">
						"B11137244" "Group1" "450" "555"<br>
						"B11154534" "Group1" "456" "456"<br>
						"B11144100" "Group1" "450" "886"<br>
						"B11137244" "Group1" "450" "456"<br>
						"B11134987" "Group1" "900" "MissingData"<br>
						"B11144345" "Group1" "900" "776"<br>
						"B11110676" "Group1" "900" "10"<br>
						"B11154532" "Group1" "456" "886"<br>
						"B11131605" "Group1" "456" "MissingData"<br>
						"B11137784" "Group1" "900" "436"<br>
						"B11156098" "Group1" "500" "886"<br>
						"B11133232" "Group1" "500" "MissingData"<br>
						"B11152577" "Group1" "900" "756"<br>
						"B11156098" "Group1" "456" "886"<br>
						"B11133232" "Group1" "456" "MissingData" 
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$2 == "\"Group1\""' file1.csv<br>
						<font class="bashcommand-result">
						"B33199522","Group1","0",""<br>
						"B11137879","Group1","0",""<br>
						"B11153927","Group1","0",""<br>
						"B11177806","Group1","MD",""<br>
						"B11152799","Group1","0",""<br>
						"B11154358","Group1","0",""<br>
						"B11110925","Group1","0",""<br>
						"B11137879","Group1","0",""<br>
						"B11110603","Group1","0",""<br>
						"B11110927","Group1","0",""<br>
						"B11147712","Group1","0",""<br>
						"B11157974","Group1","0",""<br>
						"B33199522","Group1","0","" 
						</font>
						</font></td>
					</tr>
				</table></p>

				<font class="example">Print the first column of those lines in file1.csv and file2.txt that have value <font class="bashcommand">"Group1"</font> (including the colons <font class="bashcommand">""</font>) <u>in the second column</u>.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$2 == "\"Group1\"" {print $1}' file2.txt<br>
						<font class="bashcommand-result">
						"B11137244"<br>
						"B11154534"<br>
						"B11144100"<br>
						"B11137244"<br>
						"B11134987"<br>
						"B11144345"<br>
						"B11110676"<br>
						"B11154532"<br>
						"B11131605"<br>
						"B11137784"<br>
						"B11156098"<br>
						"B11133232"<br>
						"B11152577"<br>
						"B11156098"<br>
						"B11133232" 
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$2 == "\"Group1\"" {print $1}' file1.csv<br>
						<font class="bashcommand-result">
						"B33199522"<br>
						"B11137879"<br>
						"B11153927"<br>
						"B11177806"<br>
						"B11152799"<br>
						"B11154358"<br>
						"B11110925"<br>
						"B11137879"<br>
						"B11110603"<br>
						"B11110927"<br>
						"B11147712"<br>
						"B11157974"<br>
						"B33199522" 
						</font>
						</font></td>
					</tr>
				</table></p>

			<font class="example">Print the line(s) of file1.csv and file2.txt that <u>do not have</u> value <font class="bashcommand">"Group1"</font> (including the colons <font class="bashcommand">""</font>) <u>in the second column</u>.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$2 != "\"Group1\""' file2.txt<br>
						<font class="bashcommand-result">
						"AnonymizedID" "SubjectGroup" "TEST1" "TEST2"<br>
						"B11130912" "Group2b" "900" "MissingData"<br>
						"B12226566" "Group2b" "450" "MissingData"<br>
						"C11137159" "Group3" "MissingData" "MissingData"<br>
						"B11156453" "Group4" "456" "2"<br>
						"C11138929" "Group2b" "2" "MissingData"<br>
						"B11155267" "Group3" "900" "10"<br>
						"B11137120" "Group2b" "450" "456"<br>
						"B33191224" "Group2b" "450" "776"<br>
						"B11155267" "Group3" "900" "10"<br>
						"C11138999" "Group2b" "900" "MissingData"<br>
						"B11135292" "Group3" "MissingData" "MissingData"<br>
						"C11138912" "Group2b" "900" "MissingData"<br>
						"B11150911" "Group2b" "900" "117" 
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$2 != "\"Group1\""' file1.csv<br>
						<font class="bashcommand-result">
						"Anonymized ID","Subject Group","HASCONDITION","CONDITION"<br>
						"B33199603","Group3","0",""<br>
						"B11144410","Group2 b","0",""<br>
						"B11110455","Group2 b","0",""<br>
						"B11135291","Group3","0",""<br>
						"B11177579","Group2 b","0",""<br>
						"B11157958","Group3","0",""<br>
						"B11110690","Group3","0",""<br>
						"B11135291","Group3","9","mTBI"<br>
						"B11135072","MISSING","0",""<br>
						"B33199603","Group3","0",""<br>
						"B33191224","Group2 b","0",""<br>
						"B11131290","Group2 b","0",""<br>
						"B33191224","Group2 b","0",""<br>
						"B11141503","Group3","0",""<br>
						"C11137159","Group3","9","mTBI" 
						</font>
						</font></td>
					</tr>
				</table></p>

				<font class="example">Print the first column of those lines in file1.csv and file2.txt that <u>do not have value</u> <font class="bashcommand">"Group1"</font> (including the colons <font class="bashcommand">""</font>) <u>in the second column</u>.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$2 != "\"Group1\"" {print $1}' file2.txt<br>
						<font class="bashcommand-result">
						"AnonymizedID"<br>
						"B11130912"<br>
						"B12226566"<br>
						"C11137159"<br>
						"B11156453"<br>
						"C11138929"<br>
						"B11155267"<br>
						"B11137120"<br>
						"B33191224"<br>
						"B11155267"<br>
						"C11138999"<br>
						"B11135292"<br>
						"C11138912"<br>
						"B11150911"  
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$2 != "\"Group1\"" {print $1}' file1.csv<br>
						<font class="bashcommand-result">
						"Anonymized ID"<br>
						"B33199603"<br>
						"B11144410"<br>
						"B11110455"<br>
						"B11135291"<br>
						"B11177579"<br>
						"B11157958"<br>
						"B11110690"<br>
						"B11135291"<br>
						"B11135072"<br>
						"B33199603"<br>
						"B33191224"<br>
						"B11131290"<br>
						"B33191224"<br>
						"B11141503"<br>
						"C11137159" 
						</font>
						</font></td>
					</tr>
				</table></p>

				<font class="example">Print the ID (first column) of those subjects in file3.csv and file4.txt that have age (third column) <u>greater than</u> 20.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$3 > "20" {print $1}' file4.txt<br>
						<font class="bashcommand-result">
						AnonymizedID<br>
						B11108326<br>
						B11110893<br>
						B11119909<br>
						B11119903<br>
						C11131039<br>
						C11133100<br>
						C11135566<br>
						C11137439<br>
						C11137544<br>
						C11137123<br>
						C11138150<br>
						C11138797<br>
						C11138184<br>
						C11138122<br>
						C11138122<br>
						C11138192<br>
						B12226507<br>
						B12226546 
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$3 > "20" {print $1}' file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID<br>
						C11138122<br>
						C11138192<br>
						B12226507<br>
						B12226546<br>
						C11138122<br>
						C11138184<br>
						C11138797<br>
						C11138152<br>
						C11138150<br>
						C11131039<br>
						C11135566<br>
						B11119903<br>
						C11137544<br>
						C11137123<br>
						C11137439<br>
						C11133100<br>
						B11108399<br>
						B11108326<br>
						B11119909<br>
						B11110893 
						</font>
						</font></td>
					</tr>
				</table></p>

				<font class="example">Print the ID (first column) of those subjects in file3.csv and file4.txt that have age (third column) <u>less than</u> 20.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$3 < "20" {print $1}' file4.txt<br>
						<font class="bashcommand-result">
						D11144030<br>
						D11144030<br>
						C11137159<br>
						C11137159<br>
						C11137167<br>
						C11137167<br>
						C11137439<br>
						C11137443<br>
						C11138152 
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$3 < "20" {print $1}' file3.csv<br>
						<font class="bashcommand-result">
						C11137167<br>
						C11137159<br>
						C11137167<br>
						C11137159<br>
						C11137443<br>
						C11137439<br>
						D11144030 
						</font>
						</font></td>
					</tr>
				</table></p>

				<p>
				<font class="example">Print the line(s) of file3.csv that have value <font class="bashcommand">"Group1"</font> <u>or</u> <font class="bashcommand">"Group3"</font> <u>in the second column</u>.</font>
				When there is more than one rule, the easiest and more organized way to run the command is to put all the rules in a text file and call that text file using the flag <font class="bashcommand">-f</font>. In the following example, patterns3.txt contains the rules to filter the lines that are to be printed (<font class="bashcommand">$2 == "Group1"</font> and <font class="bashcommand">$2 == "Group3"</font>). 
				</p>

				<font class="bashcommand">
					
				<p>
				$ cat patterns3.txt<br>
				<font class="bashcommand-result">
				$2 == "Group1"<br>
				$2 == "Group3" 
				</font>
				</p>
					
				<p>
				$ awk -F',' -f patterns3.txt file3.csv<br>
				<font class="bashcommand-result">
				C11138192,Group1,54<br>
				B12226507,Group1,68<br>
				B12226546,Group1,67<br>
				C11138122,Group1,24<br>
				C11138184,Group1,59<br>
				C11138797,Group1,22<br>
				C11138152,Group1,53<br>
				C11138150,Group1,41<br>
				C11137167,Group3,14<br>
				C11137159,Group3,13<br>
				C11137167,Group3,16<br>
				C11137159,Group3,13<br>
				C11137544,Group1,21<br>
				C11137443,Group3,11<br>
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				C11133100,Group1,23<br>
				D11144030,Group3,13<br>
				B11108399,Group1,23<br>
				B11108326,Group1,59<br>
				B11110893,Group1,28 
				</font>
				</p>
					
				<p>
				$ cat patterns4.txt<br>
				<font class="bashcommand-result">
				$2 == "Group1" || $2 == "Group3" 
				</font>
				</p>
					
				<p>
				$ awk -F',' -f test.txt file3.csv<br>
				<font class="bashcommand-result">
				C11138192,Group1,54<br>
				B12226507,Group1,68<br>
				B12226546,Group1,67<br>
				C11138122,Group1,24<br>
				C11138184,Group1,59<br>
				C11138797,Group1,22<br>
				C11138152,Group1,53<br>
				C11138150,Group1,41<br>
				C11137167,Group3,14<br>
				C11137159,Group3,13<br>
				C11137167,Group3,16<br>
				C11137159,Group3,13<br>
				C11137544,Group1,21<br>
				C11137443,Group3,11<br>
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				C11133100,Group1,23<br>
				D11144030,Group3,13<br>
				B11108399,Group1,23<br>
				B11108326,Group1,59<br>
				B11110893,Group1,28  
				</font>
				</p>
					
				</font>

				<p>In this example, we obtained the same result using either patterns3.txt or patterns4.txt. When you want to select any line that contains any pattern in a list of patterns, you can either put each pattern in a different line of the text file or use the or (||) symbol to concatenate all the patterns or rules.</p>

				<p>
				<font class="example">Print the value of one column for those lines that have specific values in other columns</font>
				Print the ID (first column) of those subjects in file3.csv that belong to <font class="bashcommand">"Group1"</font> (second column), and have age (third column) <u>greater than</u> 60, or that belong to <font class="bashcommand">"Group3"</font> (second column) and have age (third column) <u>less than</u> 20.
				</p>

				<p>
				In this example, we want to print any line that contains one of the following rules:
				<ul>
					<li>Second column equals <font class="bashcommand">Group1</font> and third greater than 60: <font class="bashcommand">$2 == "Group1" && $3 > 60</font></li>
					<li>Second column equals and <font class="bashcommand">Group3</font> third less than 20: <font class="bashcommand">$2 == "Group3" && $3 < 20</font></li>
				</ul>
				</p>

				<p>
				So, the content of our pattern file must be:<br>
				<font class="bashcommand">
				$ cat patterns5.txt<br>
				<font class="bashcommand-result">
				$2 == "Group1" && $3 > 60<br>
				$2 == "Group3" && $3 < 20 
				</font>
				</font>
				</p>

				<p>
				To print all the columns from the selected lines:<br>
				<font class="bashcommand">
				$ awk -F',' -f patterns5.txt file3.csv<br>
				<font class="bashcommand-result">
				B12226507,Group1,68<br>
				B12226546,Group1,67<br>
				C11137167,Group3,14<br>
				C11137159,Group3,13<br>
				C11137167,Group3,16<br>
				C11137159,Group3,13<br>
				C11137443,Group3,11<br>
				C11137439,Group3,15<br>
				D11144030,Group3,13 
				</font>
				</font>
				</p>

				<p>
				To print the first column:<br>
				<font class="bashcommand">
				$ awk -F',' -f patterns5.txt file3.csv | awk -F',' '{print $1}'<br>
				<font class="bashcommand-result">
				B12226507<br>
				B12226546<br>
				C11137167<br>
				C11137159<br>
				C11137167<br>
				C11137159<br>
				C11137443<br>
				C11137439<br>
				D11144030 
				</font>
				</font>
				</p>

				<p>
				The following page contains a summary of other patterns that can be included in a pattern file: <a href="https://ss64.com/bash/awk.html" target="_blank">https://ss64.com/bash/awk.html</a>
				</p>

				<h3>9.14. Examples: Reading the lines of a file that contain a pattern (instead of a specific word).</h3>

				<p>
				<font class="example">Print the line(s) of file3.csv that start with B.</font>
				<font class="bashcommand">
				$ grep '^B' file3.csv<br>
				<font class="bashcommand-result">
				B12226507,Group1,68<br>
				B12226546,Group1,67<br>
				B11119903,Group2 b,83<br>
				B11108399,Group1,23<br>
				B11108326,Group1,59<br>
				B11119909,Group2 b,61<br>
				B11110893,Group1,28 
				</font>
				</font>
				</p>
				
				<p>
				<font class="example">Print the line(s) of test7.csv that end with 13.</font>
				<font class="bashcommand">
				$ grep '13$' file3.csv<br>
				<font class="bashcommand-result">
				C11137159,Group3,13<br>
				C11137159,Group3,13<br>
				D11144030,Group3,13 
				</font>
				</font>
				</p>
				
				<p>
				<font class="example">Print the line(s) of test7.csv that end with 13 (when this pattern is stored in a file called patterns2.txt).</font>
				<font class="bashcommand">
				$ cat patterns2.txt<br>
				<font class="bashcommand-result">
				13$ 
				</font>
				</font>
				</p>

				<p>
				<font class="bashcommand">
				$ grep -f patterns2.txt file3.csv<br>
				<font class="bashcommand-result">
				C11137159,Group3,13<br>
				C11137159,Group3,13<br>
				D11144030,Group3,13 
				</font>
				</font>
				</p>

				<p><font class="example">Print all the non-empty lines (lines with more than 0 fields NF > 0) in file3.csv and file4.txt.</font></p>

				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk 'NF > 0' file4.txt<br>
						<font class="bashcommand-result">
						AnonymizedID SubjectGroup AGE<br>
						B11108326 Group1 59<br>
						B11108399 Group1 23<br>
						B11110893 Group1 28<br>
						B11119909 Group2 61<br>
						D11144030 Group3 11<br>
						D11144030 Group3 13<br>
						B11119903 Group2 84<br>
						C11131039 Group2 67<br>
						C11133100 Group1 23<br>
						C11135566 Group2 72<br>
						C11137159 Group3 11<br>
						C11137159 Group3 12<br>
						C11137167 Group3 14<br>
						C11137167 Group3 16<br>
						C11137439 Group3 15<br>
						C11137439 Group3 79<br>
						C11137443 Group3 15<br>
						C11137544 Group1 22<br>
						C11137123 Group2 68<br>
						C11138150 Group1 44<br>
						C11138152 Group1 10<br>
						C11138797 Group1 24<br>
						C11138184 Group1 57<br>
						C11138122 Group1 23<br>
						C11138122 MISSING 25<br>
						C11138192 Group1 45<br>
						B12226507 Group1 26<br>
						B12226546 Group1 55 
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ awk -F',' 'NF > 0' file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28 
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Print all the lines that have more than two fields (NF > 2) in file3.csv and file4.txt.</font></p>
			
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk 'NF > 2' file4.txt<br>
						<font class="bashcommand-result">
						AnonymizedID SubjectGroup AGE<br>
						B11108326 Group1 59<br>
						B11108399 Group1 23<br>
						B11110893 Group1 28<br>
						B11119909 Group2 61<br>
						D11144030 Group3 11<br>
						D11144030 Group3 13<br>
						B11119903 Group2 84<br>
						C11131039 Group2 67<br>
						C11133100 Group1 23<br>
						C11135566 Group2 72<br>
						C11137159 Group3 11<br>
						C11137159 Group3 12<br>
						C11137167 Group3 14<br>
						C11137167 Group3 16<br>
						C11137439 Group3 15<br>
						C11137439 Group3 79<br>
						C11137443 Group3 15<br>
						C11137544 Group1 22<br>
						C11137123 Group2 68<br>
						C11138150 Group1 44<br>
						C11138152 Group1 10<br>
						C11138797 Group1 24<br>
						C11138184 Group1 57<br>
						C11138122 Group1 23<br>
						C11138122 MISSING 25<br>
						C11138192 Group1 45<br>
						B12226507 Group1 26<br>
						B12226546 Group1 55 
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ awk -F',' 'NF > 2' file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28 
						</font>
						</font></td>
					</tr>
				</table></p>

				<h3>9.15. Find and replace text</h3>
	
				<p><font class="example">Replace all occurrences of C11137159 in file3.csv with XXXXXXXXX and save the modified content in file3_mod.csv.</font></p>
		
				<p>
				Command to execute the substitution:<br>
				<font class="bashcommand">$ sed 's/C11137159/XXXXXXXXX/' file3.csv > file3_mod.csv</font>
				</p>

				<p><table>
					<tr>
						<th>Content of file3.csv before the substitution:</th>
						<th>Content of the file after the substitution:</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3_mod.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						XXXXXXXXX,Group3,13<br>
						C11137167,Group3,16<br>
						XXXXXXXXX,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28 	
						</font>
						</font></td>
					</tr>
				</table></p>

				<p>In the following example, instead of replacing a fix string as we did in example 1, we will replace a group of characters (i.e. all upper-case characters in the file) by a single character or another group of characters (i.e. replace with lower-case characters). The groups of characters that can be used are listed in the following table:</p>

				<p><table>
					<tr>
						<th>Expression</th>
						<th>Group of characters</th>
					</tr>
					<tr>
						<td><font class="bashcommand">[:alnum:]</font></td>
						<td>Letters and digits</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:alpha:]</font></td>
						<td>Letters</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:blank:]</font></td>
						<td>Horizontal white space</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:cntrl:]</font></td>
						<td>Control characters</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:digit:]</font></td>
						<td>Digits</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:graph:]</font></td>
						<td>Printable characters, excluding space</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:lower:]</font></td>
						<td>Lower-case letters</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:print:]</font></td>
						<td>Printable characters, including space</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:punct:]</font></td>
						<td>Punctuation characters</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:space:]</font></td>
						<td>Horizontal or vertical white space</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:upper:]</font></td>
						<td>Upper-case letters</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:xdigit:]</font></td>
						<td>Hexadecimal digits</td>
					</tr>
				</table></p>

				<p><font class="example">Replace all upper-case letters in file3.csv by lower-case.</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr '[:upper:]' '[:lower:]'<br>
						<font class="bashcommand-result">
						anonymized id,subject group,age<br>
						c11138122,missing,21<br>
						c11138192,group1,54<br>
						b12226507,group1,68<br>
						b12226546,group1,67<br>
						c11138122,group1,24<br>
						c11138184,group1,59<br>
						c11138797,group1,22<br>
						c11138152,group1,53<br>
						c11138150,group1,41<br>
						c11137167,group3,14<br>
						c11137159,group3,13<br>
						c11137167,group3,16<br>
						c11137159,group3,13<br>
						c11131039,group2 b,67<br>
						c11135566,group2 b,73<br>
						b11119903,group2 b,83<br>
						c11137544,group1,21<br>
						c11137443,group3,11<br>
						c11137123,group2 b,69<br>
						c11137439,group3,79<br>
						c11137439,group3,15<br>
						c11133100,group1,23<br>
						d11144030,group3,13<br>
						b11108399,group1,23<br>
						b11108326,group1,59<br>
						b11119909,group2 b,61<br>
						b11110893,group1,28 
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Replace all lower-case letters in file3.csv by upper-case.</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr '[:lower:]' '[:upper:]'<br>
						<font class="bashcommand-result">
						ANONYMIZED ID,SUBJECT GROUP,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,GROUP1,54<br>
						B12226507,GROUP1,68<br>
						B12226546,GROUP1,67<br>
						C11138122,GROUP1,24<br>
						C11138184,GROUP1,59<br>
						C11138797,GROUP1,22<br>
						C11138152,GROUP1,53<br>
						C11138150,GROUP1,41<br>
						C11137167,GROUP3,14<br>
						C11137159,GROUP3,13<br>
						C11137167,GROUP3,16<br>
						C11137159,GROUP3,13<br>
						C11131039,GROUP2 B,67<br>
						C11135566,GROUP2 B,73<br>
						B11119903,GROUP2 B,83<br>
						C11137544,GROUP1,21<br>
						C11137443,GROUP3,11<br>
						C11137123,GROUP2 B,69<br>
						C11137439,GROUP3,79<br>
						C11137439,GROUP3,15<br>
						C11133100,GROUP1,23<br>
						D11144030,GROUP3,13<br>
						B11108399,GROUP1,23<br>
						B11108326,GROUP1,59<br>
						B11119909,GROUP2 B,61<br>
						B11110893,GROUP1,28
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Replace all alphabetical characters in file3.csv by the number 0</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr '[:alpha:]' 0<br>
						<font class="bashcommand-result">
						0000000000 00,0000000 00000,000<br>
						011138122,0000000,21<br>
						011138192,000001,54<br>
						012226507,000001,68<br>
						012226546,000001,67<br>
						011138122,000001,24<br>
						011138184,000001,59<br>
						011138797,000001,22<br>
						011138152,000001,53<br>
						011138150,000001,41<br>
						011137167,000003,14<br>
						011137159,000003,13<br>
						011137167,000003,16<br>
						011137159,000003,13<br>
						011131039,000002 0,67<br>
						011135566,000002 0,73<br>
						011119903,000002 0,83<br>
						011137544,000001,21<br>
						011137443,000003,11<br>
						011137123,000002 0,69<br>
						011137439,000003,79<br>
						011137439,000003,15<br>
						011133100,000001,23<br>
						011144030,000003,13<br>
						011108399,000001,23<br>
						011108326,000001,59<br>
						011119909,000002 0,61<br>
						011110893,000001,28
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Replace all digits in file3.csv by the letter X.</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr '[:digit:]' X<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						CXXXXXXXX,MISSING,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						BXXXXXXXX,GroupX,XX<br>
						BXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX b,XX<br>
						CXXXXXXXX,GroupX b,XX<br>
						BXXXXXXXX,GroupX b,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX b,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						DXXXXXXXX,GroupX,XX<br>
						BXXXXXXXX,GroupX,XX<br>
						BXXXXXXXX,GroupX,XX<br>
						BXXXXXXXX,GroupX b,XX<br>
						BXXXXXXXX,GroupX,XX
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Replace all punctuation characters in file3.csv by a space (<font class="bashcommand">' '</font>)</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr '[:punct:]' ' '<br>
						<font class="bashcommand-result">
						Anonymized ID Subject Group AGE<br>
						C11138122 MISSING 21<br>
						C11138192 Group1 54<br>
						B12226507 Group1 68<br>
						B12226546 Group1 67<br>
						C11138122 Group1 24<br>
						C11138184 Group1 59<br>
						C11138797 Group1 22<br>
						C11138152 Group1 53<br>
						C11138150 Group1 41<br>
						C11137167 Group3 14<br>
						C11137159 Group3 13<br>
						C11137167 Group3 16<br>
						C11137159 Group3 13<br>
						C11131039 Group2 b 67<br>
						C11135566 Group2 b 73<br>
						B11119903 Group2 b 83<br>
						C11137544 Group1 21<br>
						C11137443 Group3 11<br>
						C11137123 Group2 b 69<br>
						C11137439 Group3 79<br>
						C11137439 Group3 15<br>
						C11133100 Group1 23<br>
						D11144030 Group3 13<br>
						B11108399 Group1 23<br>
						B11108326 Group1 59<br>
						B11119909 Group2 b 61<br>
						B11110893 Group1 28
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Replace all white spaces in file3.csv by an underscore <font class="bashcommand">'_'</font>.</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr '[:blank:]' '_'<br>
						<font class="bashcommand-result">
						Anonymized_ID,Subject_Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2_b,67<br>
						C11135566,Group2_b,73<br>
						B11119903,Group2_b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2_b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2_b,61<br>
						B11110893,Group1,28
						</font>	
						</font></td>
					</tr>
				</table></p>

				<p>You can also replace a range of letters or numbers:</p>

				<p><font class="example">Replace any A, B or C (letters in the range A-C) in file3.csv by the letter D.</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr 'A-C' 'D'<br>
						<font class="bashcommand-result">
						Dnonymized ID,Subject Group,DGE<br>
						D11138122,MISSING,21<br>
						D11138192,Group1,54<br>
						D12226507,Group1,68<br>
						D12226546,Group1,67<br>
						D11138122,Group1,24<br>
						D11138184,Group1,59<br>
						D11138797,Group1,22<br>
						D11138152,Group1,53<br>
						D11138150,Group1,41<br>
						D11137167,Group3,14<br>
						D11137159,Group3,13<br>
						D11137167,Group3,16<br>
						D11137159,Group3,13<br>
						D11131039,Group2 b,67<br>
						D11135566,Group2 b,73<br>
						D11119903,Group2 b,83<br>
						D11137544,Group1,21<br>
						D11137443,Group3,11<br>
						D11137123,Group2 b,69<br>
						D11137439,Group3,79<br>
						D11137439,Group3,15<br>
						D11133100,Group1,23<br>
						D11144030,Group3,13<br>
						D11108399,Group1,23<br>
						D11108326,Group1,59<br>
						D11119909,Group2 b,61<br>
						D11110893,Group1,28
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Replace A by W, B by X, C by Y, and D by Z in file3.csv (replace letters in the range A-D with letters in the range W-Z)</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr 'A-D' 'W-Z'<br>
						<font class="bashcommand-result">
						Wnonymized IZ,Subject Group,WGE<br>
						Y11138122,MISSING,21<br>
						Y11138192,Group1,54<br>
						X12226507,Group1,68<br>
						X12226546,Group1,67<br>
						Y11138122,Group1,24<br>
						Y11138184,Group1,59<br>
						Y11138797,Group1,22<br>
						Y11138152,Group1,53<br>
						Y11138150,Group1,41<br>
						Y11137167,Group3,14<br>
						Y11137159,Group3,13<br>
						Y11137167,Group3,16<br>
						Y11137159,Group3,13<br>
						Y11131039,Group2 b,67<br>
						Y11135566,Group2 b,73<br>
						X11119903,Group2 b,83<br>
						Y11137544,Group1,21<br>
						Y11137443,Group3,11<br>
						Y11137123,Group2 b,69<br>
						Y11137439,Group3,79<br>
						Y11137439,Group3,15<br>
						Y11133100,Group1,23<br>
						Z11144030,Group3,13<br>
						X11108399,Group1,23<br>
						X11108326,Group1,59<br>
						X11119909,Group2 b,61<br>
						X11110893,Group1,28
						</font>
						</font></td>
					</tr>
				</table></p>

				<p>The command <font class="bashcommand">tr</font> doesn't allow you to replace by an empty space in order to delete a character or a set of characters, but you can use the <font class="bashcommand">-d</font> flag for deletion.</p>

				<p><font class="example">Remove all spaces in file3.csv.</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						$ cat file3.csv<br>
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr -d '[:blank:]'<br>
						<font class="bashcommand-result">
						AnonymizedID,SubjectGroup,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2b,67<br>
						C11135566,Group2b,73<br>
						B11119903,Group2b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
					</tr>
				</table></p>

				<p>In order to delete any repeated (continuous) character or sequence use the <font class="bashcommand">-s</font> flag.</p>

				<p><font class="example">Remove any repeated characters (<font class="bashcommand">[:alnum:]</font>) in file3.csv.</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr -s '[:alnum:]'<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C13812,MISING,21<br>
						C138192,Group1,54<br>
						B126507,Group1,68<br>
						B126546,Group1,67<br>
						C13812,Group1,24<br>
						C138184,Group1,59<br>
						C138797,Group1,2<br>
						C138152,Group1,53<br>
						C138150,Group1,41<br>
						C137167,Group3,14<br>
						C137159,Group3,13<br>
						C137167,Group3,16<br>
						C137159,Group3,13<br>
						C131039,Group2 b,67<br>
						C1356,Group2 b,73<br>
						B1903,Group2 b,83<br>
						C13754,Group1,21<br>
						C13743,Group3,1<br>
						C137123,Group2 b,69<br>
						C137439,Group3,79<br>
						C137439,Group3,15<br>
						C1310,Group1,23<br>
						D14030,Group3,13<br>
						B10839,Group1,23<br>
						B108326,Group1,59<br>
						B1909,Group2 b,61<br>
						B10893,Group1,28
						</font>
						</font></td>
					</tr>
				</table></p>
							
				<h3>9.16. Printing other information from a file</h3>

				<p><font class="example">Print the number of lines in file3.csv and file4.txt.</font></p>

				<p><table>
					<tr>
						<th>file3.csv</th>
						<th>file4.csv</th>
					</tr>
					
					<tr>
						<td><p><font class="bashcommand">
						$ awk '{print NF}' file3.csv | wc -l<br>
						<font class="bashcommand-result">28</font>
						</font></p>
						
						<p><font class="bashcommand">
						$ nlines=$(awk '{print NF}' file3.csv | wc -l)<br>
						$ echo $nlines<br>
						<font class="bashcommand-result">28</font>
						</font></p></td>
						
						<td><p><font class="bashcommand">
						$ awk '{print NF}' file4.txt | wc -l<br>
						<font class="bashcommand-result">29</font>
						</font></p>
						
						<p><font class="bashcommand">
						$ nlines=$(awk '{print NF}' file4.txt | wc -l)<br>
						$ echo $nlines<br>
						<font class="bashcommand-result">29</font>
						</font></p></td>
					</tr>
				</table></p>

				<p><font class="example">Print the number of columns in file3.csv and file4.txt.</font></p>

				<p><table>
					<tr>
						<th>Comma-separated file</th>
						<th>Space-separated file</th>
					</tr>
					
					<tr>
						<td><p><font class="bashcommand">
						$ awk -F',' '{print NF}' file3.csv | sort –nu<br>
						<font class="bashcommand-result">3</font>
						</font></p>
						
						<p><font class="bashcommand">
						$ ncols=$(awk -F',' '{print NF}' file3.csv | sort -nu)<br>
						$ echo $ncols<br>
						<font class="bashcommand-result">3</font>
						</font></p></td>
						
						<td><p><font class="bashcommand">
						$ awk '{print NF}' file4.txt | sort -nu<br>
						<font class="bashcommand-result">3</font>
						</font></p>
						
						<p><font class="bashcommand">
						$ ncols=$(awk '{print NF}' file4.txt | sort -nu)<br>
						$ echo $ncols<br>
						<font class="bashcommand-result">3</font>
						</font></p></td>
					</tr>
				</table></p>

				<p><font class="example">Print the length of each line of file4.txt.</font></p>

				<p>To get the length of a string you can use the function <font class="bashcommand">length()</font>, and pass as parameter <font class="bashcommand">$0</font> which obtains all the fields (the whole line).</p>

				<p><table>
					<tr>
						<th>Print each line</th>
						<th>Print the length of each line</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ awk '{print $0}' file4.txt<br>
						<font class="bashcommand-result">
						AnonymizedID SubjectGroup AGE<br>
						B11108326 Group1 59<br>
						B11108399 Group1 23<br>
						B11110893 Group1 28<br>
						B11119909 Group2 61<br>
						D11144030 Group3 11<br>
						D11144030 Group3 13<br>
						B11119903 Group2 84<br>
						C11131039 Group2 67<br>
						C11133100 Group1 23<br>
						C11135566 Group2 72<br>
						C11137159 Group3 11<br>
						C11137159 Group3 12<br>
						C11137167 Group3 14<br>
						C11137167 Group3 16<br>
						C11137439 Group3 15<br>
						C11137439 Group3 79<br>
						C11137443 Group3 15<br>
						C11137544 Group1 22<br>
						C11137123 Group2 68<br>
						C11138150 Group1 44<br>
						C11138152 Group1 10<br>
						C11138797 Group1 24<br>
						C11138184 Group1 57<br>
						C11138122 Group1 23<br>
						C11138122 MISSING 25<br>
						C11138192 Group1 45<br>
						B12226507 Group1 26<br>
						B12226546 Group1 55
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ awk '{print length($0)}' file4.txt<br>
						<font class="bashcommand-result">
						29<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>20<br>19<br>19<br>19
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Print the length of the second field (<font class="bashcommand">length($2)</font>) in file3.csv and file4.txt.</font></p>

				<p><table>
					<tr>
						<th>Comma-separated file</th>
						<th>Space-separated file</th>
					</tr>
					
					<tr>
						<td><p><font class="bashcommand">
						$ awk '{print length($2)}' file4.txt<br>
						<font class="bashcommand-result">
						12<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>7<br>6<br>6<br>6
						</font>
						</font></td>
						
						<td><p><font class="bashcommand">
						$ awk -F',' '{print length($2)}' file3.csv<br>
						<font class="bashcommand-result">
						13<br>7<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>8<br>8<br>8<br>6<br>6<br>8<br>6<br>6<br>6<br>6<br>6<br>6<br>8<br>6
						</font>
						</font></td>
					</tr>
				</table></p>

				<p>
				<font class="example">Print all the lines of file4.txt in upper-case.</font><br>
				To convert a string to upper-case use the function <font class="bashcommand">toupper()</font> and pass as parameter <font class="bashcommand">$0</font> which contains the whole line.
				</p>

				<p><table>
					<tr><td><font class="bashcommand">$ awk '{print toupper($0)}' file4.txt</font></td></tr>
					<tr><td><font class="bashcommand-result">
						ANONYMIZEDID SUBJECTGROUP AGE<br>
						B11108326 GROUP1 59<br>
						B11108399 GROUP1 23<br>
						B11110893 GROUP1 28<br>
						B11119909 GROUP2 61<br>
						D11144030 GROUP3 11<br>
						D11144030 GROUP3 13<br>
						B11119903 GROUP2 84<br>
						C11131039 GROUP2 67<br>
						C11133100 GROUP1 23<br>
						C11135566 GROUP2 72<br>
						C11137159 GROUP3 11<br>
						C11137159 GROUP3 12<br>
						C11137167 GROUP3 14<br>
						C11137167 GROUP3 16<br>
						C11137439 GROUP3 15<br>
						C11137439 GROUP3 79<br>
						C11137443 GROUP3 15<br>
						C11137544 GROUP1 22<br>
						C11137123 GROUP2 68<br>
						C11138150 GROUP1 44<br>
						C11138152 GROUP1 10<br>
						C11138797 GROUP1 24<br>
						C11138184 GROUP1 57<br>
						C11138122 GROUP1 23<br>
						C11138122 MISSING 25<br>
						C11138192 GROUP1 45<br>
						B12226507 GROUP1 26<br>
						B12226546 GROUP1 55 
					</font></td></tr>
				</table></p>

				<p>
				<font class="example">Print all the lines of file4.txt in lower-case.</font><br>
				To convert a string to lower-case use the function <font class="bashcommand">tolower()</font> and pass as parameter <font class="bashcommand">$0</font> which contains the whole line.
				</p>

				<p><table>
					<tr><td><font class="bashcommand">$ awk '{print tolower($0)}' file4.txt</font></tr></td>
					<tr><td><font class="bashcommand-result">
						anonymizedid subjectgroup age<br>
						b11108326 group1 59<br>
						b11108399 group1 23<br>
						b11110893 group1 28<br>
						b11119909 group2 61<br>
						d11144030 group3 11<br>
						d11144030 group3 13<br>
						b11119903 group2 84<br>
						c11131039 group2 67<br>
						c11133100 group1 23<br>
						c11135566 group2 72<br>
						c11137159 group3 11<br>
						c11137159 group3 12<br>
						c11137167 group3 14<br>
						c11137167 group3 16<br>
						c11137439 group3 15<br>
						c11137439 group3 79<br>
						c11137443 group3 15<br>
						c11137544 group1 22<br>
						c11137123 group2 68<br>
						c11138150 group1 44<br>
						c11138152 group1 10<br>
						c11138797 group1 24<br>
						c11138184 group1 57<br>
						c11138122 group1 23<br>
						c11138122 missing 25<br>
						c11138192 group1 45<br>
						b12226507 group1 26<br>
						b12226546 group1 55
					</font></tr></td>
				</p></table>

				<p>Some other functions that can be used in addition to <font class="bashcommand">toupper()</font> and <font class="bashcommand">tolower()</font> can be found <a href="https://www.cs.princeton.edu/courses/archive/spr08/cos333/awk.help" target="_blank">here</a></p>
		    </div>
		       
		    <div id="content10" class="hidden">
		    	<h2>10. Manipulating image files</h2>
		    	    <h3>10.1. Changing format or properties of an image file using sips (for Mac users)</h3>
			    <p>Usage: <font class="bashcommand">sips [flags] inputFile [--out outputFile]</font></p>
			    <p>Image modification flags:</p>
			    
			    <p><table>
			    	<tr>
					<th>Flag</th>
					<th>Meaning</th>
				</tr>
			    	<tr>
					<td><font class="bashcommand">-s</font> key value<br>or<br><font class="bashcommand">--setProperty key value</font></td>
					<td>Set the <font class="bashcommand">value</font> for a <font class="bashcommand">key</font> (see tables below for the available profile property keys and acceptable values for each key).</td>
				</tr>
			    	<tr>
					<td><font class="bashcommand">-r degreesCW</font><br>or<br><font class="bashcommand">--rotate degreesCW</font></td>
					<td>Rotate an image several degrees clockwise.</td>
				</tr>
			    	<tr>
					<td><font class="bashcommand">-f option</font><br>or<br><font class="bashcommand">--flip option</font></td>
					<td>Flip the image using one of the following two options: <font class="bashcommand">horizontal</font> or <font class="bashcommand">vertical</font>.</td>
				</tr>
			    	<tr>
					<td><font class="bashcommand">-c pixelsH pixelsW</font><br>or<br><font class="bashcommand">--cropToHeightWidth pixelsH pixelsW</font></td>
			    		<td>Crop image to fit specified size. <font class="bashcommand">pixelsH</font> indicates the new height in number of pixels, <font class="bashcommand">pixelsW</font> indicates the new width in number of pixels.</td>
			    	</tr>
			    	<tr>
					<td><font class="bashcommand">-z pixelsH pixelsW</font><br>or<br><font class="bashcommand">--resampleHeightWidth pixelsH pixelsW</font></td>
					<td>Resample image at specified size. Image aspect ratio may be altered. <font class="bashcommand">pixelsH</font> indicate the new height in number of pixels, <font class="bashcommand">pixelsW</font> indicate the new width in number of pixels.</td>
				</tr>
			    	<tr>
					<td><font class="bashcommand">-Z pixelsWH</font><br>or<br><font class="bashcommand">--resampleHeightWidthMax pixelsWH</font></td>
					<td>Resample image so height and width aren't greater than specified.</td>
				</tr>
			    	<tr>
					<td><font class="bashcommand">--resampleWidth pixelsW</font></td>
					<td>Resample image to specified width. <font class="bashcommand">pixelsW</font> indicate the new width in number of pixels.</td>
				</tr>
			    	<tr>
					<td><font class="bashcommand">--resampleHeight pixelsH</font></td>
					<td>Resample image to specified height. <font class="bashcommand">pixelsH</font> indicate the new height in number of pixels.</td>
				</tr>
			    	<tr>
					<td><font class="bashcommand">-o</font><br>or<br><font class="bashcommand">--optimizeColorForSharing</td>
					<td>Optimize color for sharing.</td>
				</tr>
			    </p></table>

			    <p>If you want to modify one image to match the properties of another image (for example have one image match the height of another image), you can use the flag <font class="bashcommand">--getProperty</font> with one of the following properties (which can also be used as parameters for some of the flags described above):</p>
		    
			    <p><table>
				<tr>
					<th>Profile property keys</th>
					<th>Usage</th>
				</tr>
				<tr>
					<td><font class="bashcommand">dpiHeight</font></td>
					<td>Height in dpi (printer dots per inch).</td>
				</tr>
				<tr>
					<td><font class="bashcommand">dpiWidth</font></td>
					<td>Width in dpi (printer dots per inch).</td>
				</tr>
				<tr>
					<td><font class="bashcommand">pixelHeight</font></td>
					<td>Height in number of pixels.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">pixelWidth</font></td>
					<td>Width in number of pixels.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">format</font></td>
					<td>Image format. Acceptable values for this key: <font class="bashcommand">jpeg</font>, <font class="bashcommand">tiff</font>, <font class="bashcommand">png</font>, <font class="bashcommand">gif</font>, <font class="bashcommand">jp2</font>, <font class="bashcommand">pict</font>, <font class="bashcommand">bmp</font>, <font class="bashcommand">qtif</font>, <font class="bashcommand">psd</font>, <font class="bashcommand">sgi</font>, <font class="bashcommand">tga</font>, <font class="bashcommand">pdf</font>.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">formatOptions</font></td>
					<td>Quality of the new image. Acceptable values for this key: <font class="bashcommand">low</font>, <font class="bashcommand">normal</font>, <font class="bashcommand">high</font>, <font class="bashcommand">best</font>, or some percentage.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">samplesPerPixel</font></td>
					<td>Samples per pixel.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">bitsPerSample</font></td>
					<td>Bits per sample.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">software</font></td>
					<td>Software use to create the image.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">description</font></td>
					<td>Description.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">copyright</font></td>
					<td>Copyright.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">version</font></td>
					<td>Version.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">platform</font></td>
					<td>Platform where file was created.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">quality</font></td>
					<td>Acceptable values for this key: <font class="bashcommand">normal</font>, <font class="bashcommand">draft</font>, <font class="bashcommand">best</font>.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">renderingIntent</font></td>
					<td>Acceptable values for this key: <font class="bashcommand">perceptual</font>, <font class="bashcommand">relative</font>, <font class="bashcommand">saturation</font>, <font class="bashcommand">absolute</font>.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">creator</font></td>
					<td>Creator of the file.</td>
				</tr>
			    </p></table>

			    <p>For the examples below I will be using the following image, taken from the following article, which I published long time ago: <a href='https://pubmed.ncbi.nlm.nih.gov/29113642/' target='_blank'>link to article</a>. <a href='https://pubmed.ncbi.nlm.nih.gov/29113642/#&gid=article-figures&pid=figure-2-uid-1' target='_blank'>Link to original image</a>.</p>

			    <p><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/instance/5809301/bin/nihms909531f2.jpg" alt="thalamo-cortical connectivity"></p>

			    <p>
				<font class="example">Convert <a href='https://www.ncbi.nlm.nih.gov/pmc/articles/instance/5809301/bin/nihms909531f2.jpg' target='_blank'>AutismArticle1.png</a> to pdf.</font>
				<font class="bashcommand">$ sips -s format pdf AutismArticle1.png --out AutismArticle1.pdf</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br> 
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.pdf</font>
			    </p>

			    <p>
				<font class="example">Rotate <a href='https://www.ncbi.nlm.nih.gov/pmc/articles/instance/5809301/bin/nihms909531f2.jpg' target='_blank'>AutismArticle1.png</a> 45<sup>&#8728;</sup> clock-wise.</font>
				<font class="bashcommand">$ sips -r 45 AutismArticle1.png --out test.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/test.png</font>
			    </p>

			    <p>Result image:</p>
			    <p><img src="rotated1.png" alt="image rotated 45 degrees clock wise"></p>

			<p>
				<font class="example">Rotate <a href='https://www.ncbi.nlm.nih.gov/pmc/articles/instance/5809301/bin/nihms909531f2.jpg' target='_blank'>AutismArticle1.png</a> 45<sup>&#8728;</sup> counter-clock-wise.</font>
				<font class="bashcommand">$ sips -r -45 AutismArticle1.png --out test.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/test2.png</font>
			</p>

			<p>Result image:</p>
			<p><img src="rotated2.png" alt="image rotated 45 degrees counter clock wise"></p>

			<p>
				<font class="example">Flip <a href='https://www.ncbi.nlm.nih.gov/pmc/articles/instance/5809301/bin/nihms909531f2.jpg' target='_blank'>AutismArticle1.png</a> horizontally.</font>
				<font class="bashcommand">$ sips -f horizontal AutismArticle1.png --out test.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/test.png</font>
			</p>

			<p>Result image:</p>
			<p><img src="flipped.png" alt="image rotated 45 degrees counter clock wise"></p>

			<p>
				<font class="example">Flip <a href='https://www.ncbi.nlm.nih.gov/pmc/articles/instance/5809301/bin/nihms909531f2.jpg' target='_blank'>AutismArticle1.png</a> vertically.</font>
				<font class="bashcommand">$ sips -f vertical AutismArticle1.png --out test.png</font><br> 
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br> 
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/test.png</font>
			</p>

			<p>Result image:</p>
			<p><img src="flipped2.png" alt="image rotated 45 degrees counter clock wise"></p>

			<p>
				<font class="example">Crop <a href='https://www.ncbi.nlm.nih.gov/pmc/articles/instance/5809301/bin/nihms909531f2.jpg' target='_blank'>AutismArticle1.png</a> to fit a new size that be &#188;<sup>th</sup> of its original height and &#188;<sup>th</sup> of its original weight.</font>
				The first step is to obtain the current width and height using <font class="bashcommand">sips</font> with the flags <font class="bashcommand">--getProperty pixelWidth</font> and <font class="bashcommand">--getProperty pixelHeight</font>. Then, divide the two numbers by four. And finally use <font class="bashcommand">sips</font> with the <font class="bashcommand">-c</font> flag to crop the file.
			</p>

			<p>
			<font class="bashcommand">$ sips --getProperty pixelHeight AutismArticle1.png</font><br>
			<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br>
			<font class="bashcommand-result">&nbsp;&nbsp;pixelHeight: 440</font><br>
			<font class="bashcommand">$ sips --getProperty pixelWidth AutismArticle1.png</font><br>
			<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br>
			<font class="bashcommand-result">&nbsp;&nbsp;pixelWidth: 727</font><br>
			<font class="bashcommand">$ echo "440/4" | bc -l</font><br>
			<font class="bashcommand-result">110.00000000000000000000</font><br>
			<font class="bashcommand">$ echo "727/4" | bc -l</font><br>
			<font class="bashcommand-result">181.75000000000000000000</font><br>
			<font class="bashcommand">$ sips -c 110 181 AutismArticle1.png --out test.png</font><br>
			<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br>
			<font class="bashcommand-result">&nbsp;&nbsp;/Users/monica/Desktop/Backup/images_presentations/test.png</font>
			</p>

			<p>Result image:</p>
			<p><img src="cropped.png" alt="cropped image"></p>

			<p>
				<font class="example">Resample image to 110x181.</font>
				<font class="bashcommand">$ sips -z 110 181 AutismArticle1.png --out test.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br>
				<font class="bashcommand-result">&nbsp;&nbsp;/Users/monica/Desktop/Backup/images_presentations/test.png</font><br>
				<font class="bashcommand">$ sips --getProperty pixelHeight test.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/test.png</font><br>
				<font class="bashcommand-result">&nbsp;&nbsp;pixelHeight: 110</font><br>
				<font class="bashcommand">$ sips --getProperty pixelWidth test.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/test.png</font><br>
				<font class="bashcommand-result">&nbsp;&nbsp;pixelWidth: 181</font>
			</p>

			<p>Result image:</p>
			<p><img src="resampled.png" alt="cropped image"></p>
		    </div>
		       
		    <div id="content11" class="hidden">
		    	<h2>11. Writing more complex bash scripts</h2>
		    	
		    	<h3>11.1. Reading arguments</h3>
		    		<p>Content 11.1</p>
		    		
		    	<h3>11.2. Using functions</h3>
		    		<p>Content 11.2</p>
		    		
		    	<h3>11.3. Creating/importing libraries</h3>
		    		<p>Content 11.3</p>
		    		
		    	<h3>11.4. Scripting processes in parallel</h3>
		    		<p>Content 11.4</p>
		    </div>
		       
		    <div id="content12" class="hidden">
		    	<h2>12. Remote shell</h2>
		    		<p>Content of section 12</p>
		    </div>
		       
		    <div id="content13" class="hidden">
		    	<h2>13. Cluster jobs</h2>
		    		<p>Content of section 13</p>
		    </div>
		       
		    <div id="content14" class="hidden">
		    	<h2>14. Downloading files from the web</h2>
		    		<p>Content section 14</p>
		    		<p>Stocks</p>
		    </div>
		       
		    <div id="content15" class="hidden">
		    	<h2>15. Creating backups</h2>
		    		<p>Content section 15</p>
		    </div>
		       
		    <div id="content16" class="hidden">
		    	<h2>16. File permissions</h2>
		    		<p>Content of section 16</p>
		    </div>
		       
		    <div id="content17" class="hidden">
		    	<h2>17. Using aliases</h2>
		    		<p>Content of section 17</p>
		    </div>
		       
		    <div id="content18" class="hidden">
		    	<h2>18. keyboard shortcuts</h2>
		    		<p>Content of section 18</p>
		    </div>
		       
		    <div id="content19" class="hidden">
		    	<h2>19. MySQL</h2>
		    		<p>Content of section 19</p>
		    </div>
		       
		    <div id="content20" class="hidden">
		    	<h2>20. Report an error in the tutorial</h2>
					<h3>Thanks for helping me improve this free tutorial!</h3>
					<p>Please, let me know where and what type of error did you find. I will do my best to fix it as soon as I can.</p>
					
			    	<form name="input" action="https://formspree.io/mgcgithub@gmail.com" target="_blank" method="POST">
						Chapter:<br>
						<select onclick="showErrSec()" id="chaperror" name="chaperror">
						  <option value="0">Select a chapter</option>
						  <option value="1">1. Introduction to shell scripting</option>
						  <option value="2">2. Creating simple bash scripts</option>
						  <option value="3">3. Variables</option>
						  <option value="4">4. Arithmetic calculations</option>
						  <option value="5">5. Arrays</option>
						  <option value="6">6. Condition-testing</option>
						</select><br><br>
						
						<div id="secerror1" class="hidden">
							Section:<br>
							<select id="section1" name="section1">
								<option value="0">Select a section</option>
								<option value="1">1.1. Shell scripting</option>
							</select><br><br>
						</div>
						
						<div id="secerror2" class="hidden">
							Section:<br>
							<select id="section2" name="section2">
								<option value="0">Select a section</option>
								<option value="1">2.1. The vi editor</option>
								<option value="2">2.2. Other editors</option>
								<option value="3">2.3. Tips for writing scripts</option>
								<option value="4">2.4. Running a script</option>
							</select><br><br>
						</div>
						
						<div id="secerror3" class="hidden">
							Section:<br>
							<select id="section3" name="section3">
								<option value="0">Select a section</option>
								<option value="1">3.1. Utility, declaration and accessing variables</option>
								<option value="2">3.2. Rules for assigning variable names</option>
								<option value="3">3.3. Reading user input into a variable</option>
								<option value="4">3.4. Using &lt;&lt;&lt; to get input from a different source</option>
							</select><br><br>
						</div>
						
						<div id="secerror4" class="hidden">
							Section:<br>
							<select id="section4" name="section4">
								<option value="0">Select a section</option>
								<option value="1">4.1. Integer calculations</option>
								<option value="2">4.2. Non-integer calculations</option>
							</select><br><br>
						</div>
						
						<div id="secerror5" class="hidden">
							Section:<br>
							<select id="section5" name="section5">
								<option value="0">Select a section</option>
								<option value="1">5.1. Declaring and assigning values</option>
								<option value="2">5.2. Array operations</option>
							</select><br><br>
						</div>
						
						<div id="secerror6" class="hidden">
							Section:<br>
							<select id="section6" name="section6">
								<option value="0">Select a section</option>
								<option value="1">6.1. Condition-testing to check files</option>
								<option value="2">6.2. Condition-testing to compare/evaluate strings</option>
								<option value="3">6.3. Condition-testing to compare numbers</option>
								<option value="4">6.4. Condition-testing to compare arrays</option>
								<option value="5">6.5. Combining different expressions for condition-testing</option>
							</select><br><br>
						</div>
						
						<div onclick="showOther()" id="errtype">
							Error type:<br>
							<select id="etype" name="etype">
								<option value="0">Select error type</option>
								<option value="1">An error in a bash command</option>
								<option value="2">An error in the html code</option>
								<option value="3">Something in this section is not true</option>
								<option value="4">A spelling or grammatical error</option>
								<option value="5">Other</option>
							</select><br><br>
						</div>
						
						<div id="other" class="hidden">
							Please specify: <input type="text" id="othererror" name="othererror"><br><br>
						</div>
						
						<input type="submit" value="Submit">
						<input type="hidden" name="_subject" value="New submission from github"/>
					</form> 
		    </div>
		  </article>
		</section>
		
		<footer>
			<p>
				Last update: July 20 / 2021<br>
				All the content from this tutorial was originally created by the author<br>
				Author: <a href="http://linkedin.com/in/monicakeithmri" target="_blank">Monica Keith</a>
			</p>
		</footer>
	</body>
</html>

<!DOCTYPE html>
<html>
	<title>Bash Programming</title>
	
	<head>	
		<script language="javascript">
			function showContent(num){
				var x = document.getElementById("content".concat(num)).style;
				if (x.display=="none" || x.display==""){
					x.display="block";
				}
				else{
					x.display="none";
				}
				return false;
			}
		</script>
		
		<style type="text/css">
			div.hidden {
				display: none;
			}
			.bashcommand {
				font-family: Courier;
				font-size: 12px;
			}
			.example{
				text-decoration: underline;
				display: block;
			}
			.example:before{
				content: "Example: ";
			}
			table {
				border-collapse: collapse;
			}
			caption {
				padding: 5px;
				caption-side: bottom;
			}
			td, th {
				border: 1px solid #dddddd;
				text-align: left;
				vertical-align: top;
				padding: 5px;
			}
			tr:nth-child(even){
				background-color: #dddddd;
			}
		</style>
	</head>
	
	<body>
		<h1>Bash programming</h1>
		<h2>Tutorial content</h2>
		
		<h3><a href="#content1" onclick="showContent(1);">1. Introduction to shell scripting</a></h3>
		<div id="content1" class="hidden">
			<p>
			<b>Shell (bash) scripting, its benefits and dangers (and how to protect from them)</b>
			</p>
			
			<p>
			Shell is a program that users employ to run commands for the operating system to execute. These can be very simple 
			instructions such as coping or moving files, or long scripts that contain hundreds of commands. Users typically 
			interact with a shell using a terminal window (also referred to as command line), which can be run from the same or 
			a remote machine. There are different types of shells, but I will refer in this tutorial only to the Bourne-Again shell, 
			which is the most commonly used. The Bourne-Again shell (or simply shell, as most people call it) is installed by 
			default in any Linux or MacOS. The programming language used to write commands and scripts in shell is called bash.
			</p>

			<p>
			The terminal window for Mac can be found inside the applications folder and in the subfolder Utilities. You can also 
			open it by pressing the command and space bar in your keyboard to open the spotlight and then type Terminal. 
			In Linux, the easiest way to open the terminal is to use the key combination Ctl + Alt + T.
			</p>

			<p>
			Shell scripting is very powerful; it allows you to run any instruction on your computer or a remote machine. Things 
			that normally would take hours to do could be executed in seconds. For example, if you have thousands of files 
			inside a folder, which need to be renamed following a pattern, it would take forever to rename those files by hand. 
			However, using the command line you could do it in seconds. When you write a shell script, you know exactly what and 
			how you did things, and you will be able to replicate those commands on different files, datasets or programs.
			</p>

			<p>			
			However, as powerful as scripting is, it is also very dangerous. Through the terminal you will have access to any 
			files or system resources if you have the right permissions, and the freedom to do anything with them. Inadvertent 
			"small" typing errors such as adding an extra space in the remove command (<font class="bashcommand">rm</font>) could delete everything in your 
			computer (including the root directory) or any external drive connected to your machine. Similarly, the contents of 
			any file could be mistakenly removed in less than a second. What makes it harder to prevent these errors is that 
			many commands differ in name by only one letter.
			</p>

			<p>
			Unfortunately, there is no way to completely protect your computer from potential mistakes that you may (and you 
			will at some point) do when writing and running shell scripts. However, there are a couple of tips that you can 
			follow in order to minimize the chances of making irreparable mistakes or to prevent any mistake from becoming a 
			catastrophe:
			</p>	

			<ol>
				<li>
				First and most importantly, create constant backups of either your entire drive or the most important folders. 
				Preferably save those backups in an external hard drive or remote machine, which won't be constantly connected 
				to your computer. It is not a bad idea to have more than one backup if your data is not easily recoverable.
				</li><br>

				<li>
				If you're using a shared computer or account, control access permissions to important files and folders. You can 
				control for each file and folder who and what can be done. By managing permissions, you can allow a file to be 
				read but not to be written (hence preventing it from being modified or deleted). Or you can authorize only a 
				user or group of users for viewing, reading, writing or executing a file. In chapter 12 you will learn how to 
				manage permissions.
				</li><br>

				<li>
				The root user is an account in any Linux or Unix operating system (i.e. MacOS) that has access to absolutely all 
				commands, files and directories. When you login as a root in the command line, you can modify, read and write 
				protected folders and files. This is very helpful when installing software or modifying the default settings of 
				your computer. However, coding as the root user can be extremely dangerous. It is very normal to make mistakes 
				when coding and if you have all permissions, you could mistakenly delete, move or modify files that should not 
				be touched. For this reason, it is advisable to only login as a root when strictly necessary and log out once 
				you're done. More information about the root user will be covered in chapter 12.
				</li><br>

				<li>
				Use aliases to protect from "dangerous" commands. Two of the most commonly used but dangerous commands are 
				<font class="bashcommand">rm</font> (to remove files) and <font class="bashcommand">mv</font> (to move files). 
				The <font class="bashcommand">mv</font> command can be as harmful as the <font class="bashcommand">rm</font> 
				command because if you specify the wrong target or source paths, you can end up deleting a big number of files. 
				When you use any of these two commands, always double check what you have written before clicking enter.
				</li><br>

				<li>
				Be careful when copy pasting commands from a website into the terminal. There can be errors that will be 
				executed right away if the text you're copying contains a carriage return at the end of the line. It is better 
				to paste into a shell script and then either execute the shell script or copy from the shell script into the 
				command line. Although generally not dangerous, you might also run into errors when copy pasting from Microsoft 
				word or other editors that modify symbols such as dash or underscore and convert them into new symbols that 
				bash won't understand.
				</li>

			</ol>
		</div>
		
		<h3><a href="#content2" onclick="showContent(2);">2. Creating simple bash scripts</a></h3>
		<div id="content2" class="hidden">
			<h4><a href="#content2.1" onclick="showContent(2.1)">2.1. The vi editor</a></h4>
			<div id="content2.1" class="hidden">
				<p>
				There are an unlimited number of editors available for writing shell scripts in Linux and Mac. A few are 
				installed by default; some are used through the terminal and some others use a graphical interface (GUI). 
				They all have pros and cons and the decision to use one or another is totally personal. In this section I will 
				explain how to use the editor vi, which is installed by default in both Linux and MacOS and can be accessed and 
				used through the terminal window. 
				</p>
				
				These are some of the advantages of vi:
				<ul>
					<li>
					It is available in all Unix systems and any type of terminal.
					</li>
					
					<li>
					It doesn't require a lot of memory to run. So, if you are running many heavy programs in your computer, 
					vi is a good option because it won't slow down the machine anymore and will still load very fast.
					</li>
					
					<li>
					Even though there are a lot of commands that you must learn to become skilled in using this program, once 
					you learn them you can use very short and fast commands to accomplish a lot of things. For example, you 
					can delete all the characters from your current cursor location to the end of the line, just by pressing two 
					times the d in your keyboard (while in command mode). Below you will find a chart with the most commonly used 
					shortcuts in vi.
					</li>
					
					<li>
					You can use it to code in different languages (i.e. it also works for Python, HTML, etc.).
					</li>
					
					<li>
					Some editors add special characters to the text and when you run scripts written in those editors, they could
					fail. vi doesn't add any special characters, and if it did, they are visible in the editor.
					</li>
					
					<li>
					If you don't like using your mouse too much, or you don't have a mouse, or your mouse doesn't work 
					properly, then vi editor is a good choice because you rarely need to use the mouse. Most things are 
					accomplished using the keyboard.
					</li>
				</ul>
				
				However, there are some disadvantages too:
				<ul>
					<li>
					The learning curve can be steep, especially for people who are new to programming and not very comfortable 
					with computers. If you're new to bash, you not only need to learn the language, but also a whole set of 
					commands specific to this program. 
					</li>
					
					<li>
					Not being able to use your mouse can end up wasting your time while you learn all the commands that are used 
					to scroll around the file or jump from one line to another.
					</li>
					
					<li>
					It doesn't give you any error messages or explanation of why it's not doing what you want. If you type the 
					wrong command, it will just do nothing (or do the wrong thing).
					</li>
				</ul>
				
				<p>
				Generally, many people with relatively good experience programming love this editor. In my opinion, it's a good 
				tool to use once you are familiar with shell and have been programming for a while. However, it might be a great 
				option for you if you like challenges or if you are already somehow familiar with shell.
				</p>
				
				<p>
				To create a new file, type (on the command line) 
				<font class="bashcommand">vi &lt;filePath&gt;/&lt;filename&gt;</font>. For example, if you want to create a file 
				called test.sh in the desktop, you should type <font class="bashcommand">vi ~/Desktop/test.sh</font>. The vi 
				editor will open in the current terminal.
				</p>
				
				<p>
				This program runs in two modes, the command mode and the typing mode. By default, it opens in command mode. 
				What this means is that anything you type is not actually being registered in the file but are commands. For 
				example, if you type <font class="bashcommand">:q!</font> as soon as you open the file, it will quit without 
				saving (because <font class="bashcommand">:q!</font> is the command for ignoring any modifications and exiting. 
				If you type <font class="bashcommand">:w</font> it will save changes to the file (or if you haven't write 
				anything, it will just create an empty file). To change to typing mode, type <font class="bashcommand">a</font> 
				(<font class="bashcommand">a</font> is the command for entering typing mode). After you type a (in lower case), 
				you can start editing your file. To go back to command mode (for example to save changes), press the key 
				<font class="bashcommand">esc</font> (top left corner of the keyboard).
				</p>
				
				<p>
				<font class="example">Using the vi editor for the first time</font>
				Open the vi editor, create a script that prints "Hello Word", and save it with the file name helloword.sh
				</p>
				
				<p>
				Step 1: Open the vi editor<br><br>
				<img src="vi_1.png"/>
				</p>
				
				<p>
				Step 2: Type <font class="bashcommand">a</font> to start editing the file. You will see that an 
				<b>--Insert--</b> message in the bottom of the terminal appears. This means that now you are in typing mode.<br><br>
				<img src="vi_2.png"/>
				</p>
				
				<p>
				Step 3: Start typing commands. The simplest command, to print a message such as 
				<font class="bashcommand">"Hello World"</font> (or any other) is <font class="bashcommand">echo</font>. The 
				syntax of this command is the word <font class="bashcommand">echo</font> followed by the message you want to 
				print out between quotation marks (in this case <font class="bashcommand">"Hello World!"</font>).<br><br>
				<img src="vi_3.png"/>
				</p>
				
				<p>
				Step 4: Once you finish your script, press the <font class="bashcommand">esc</font> key to enter command mode. 
				You will see that the <b>--Insert--</b> message at the bottom of the terminal disappears (this means that now 
				you are in command mode).<br><br>
				<img src="vi_4.png"/>
				</p>
				
				<p>
				Step 5: Save changes and exit the vi editor. In order to do this, type <font class="bashcommand">:wq</font> 
				(to write (<font class="bashcommand">w</font>) and quit (<font class="bashcommand">q</font>) at the same time). 
				The table below will show you the most commonly used commands for vi.<br><br>
				<img src="vi_5.png"/>
				</p>
				
				<p>
				Step 6: To be able to execute the script, you will have to give it running permissions. The topic of 
				permissions is a lot more complicated, so I will not go into details now (I will talk about it later). For now, 
				all you need to know is that to give running permissions to your script you have to type 
				<font class="bashcommand">chmod 775 helloword.sh</font><br><br>
				<img src="vi_6.png"/>
				</p>
				
				<p>
				The following table shows a list of vi commands that can be used in command mode and the action that will 
				happen in each case. In general, a number preceding any vi command will tell vi to repeat the command that 
				number of times. For example, <font class="bashcommand">p</font> is the command for pasting. If you write 
				(in command mode) <font class="bashcommand">2p</font>, then vi will paste whatever you copied two times where 
				the cursor is currently located.
				</p>
				
				<table>
				<caption>List of vi commands</caption>
				<tr>
					<th><b>Key/command</b></th>
					<th><b>Action</b></th>
				</tr>
				<tr>
					<td><font class="bashcommand">[ESC]</font></td>
					<td>Switch to command mode</td>
				</tr>
				<tr>
					<td><font class="bashcommand">[ctrl] b</font></td>
					<td>Scroll backward one screen</td>
				</tr>
				<tr>
					<td><font class="bashcommand">[ctrl] d</font></td>
					<td>Scroll down half screen</td>
				</tr>
				<tr>
					<td><font class="bashcommand">[ctrl] f</font></td>
					<td>Scroll forward one screen</td>
				</tr>
				<tr>
					<td><font class="bashcommand">[ctrl] u</font></td>
					<td>Scroll up half screen</td>
				</tr>
				<tr>
					<td><font class="bashcommand">.</font></td>
					<td>Repeat last command</td>
				</tr>
				<tr>
					<td><font class="bashcommand">$</font></td>
					<td>Go to end of line</td>
				</tr>
				<tr>
					<td><font class="bashcommand">? string</font></td>
					<td>Search backward for <font class="bashcommand">string</font></td>
				</tr>
				<tr>
					<td><font class="bashcommand">/ string</font></td>
					<td>Search forward for string</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:0</font></td>
					<td>Go to beginning of line</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:N</font></td>
					<td>Go to line <font class="bashcommand">N</font></td>
				</tr>
				<tr>
					<td><font class="bashcommand">:N,Md</font></td>
					<td>Delete lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font></td>
				</tr>
				<tr>
					<td><font class="bashcommand">:N,MmP</font></td>
					<td>Move lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font> and paste them after line <font class="bashcommand">P</font></td>
				</tr>
				<tr>
					<td><font class="bashcommand">:N,MtP</font></td>
					<td>Copy lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font> and paste them after line <font class="bashcommand">P</font></td>
				</tr>
				<tr>
					<td><font class="bashcommand">:N,Mw file</font></td>
					<td>Save lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font> to file</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:q</font></td>
					<td>Quit (does not save any changes)</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:q!</font></td>
					<td>Ignore any modifications made and quit</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:%s/old/new/option</font></td>
					<td>
					Searches and replaces the string <font class="bashcommand">old</font> by the string 
					<font class="bashcommand">new</font> in the entire file<br>
					The following letters can be added in the field <font class="bashcommand">option</font>:<br>
					<font class="bashcommand">c</font> to prompt for confirmation<br>
					<font class="bashcommand">g</font> to replace all the occurrences of the string
					</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:s/old/new/option</font></td>
					<td>
					Searches and replaces the string <font class="bashcommand">old</font> by the string 
					<font class="bashcommand">new</font> in the line in which the cursor is located</br>
					The following letters can be added in the field <font class="bashcommand">option</font>:</br>
					<font class="bashcommand">c</font> to prompt for confirmation<br>
					<font class="bashcommand">g</font> to replace all the occurrences of the string
					</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:set ignorecase</font></td>
					<td>Ignore case sensitivity during search</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:set noignorecase</font></td>
					<td>Restore case sensitivity during search</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:set number</font></td>
					<td>Turn on line numbering</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:set nonumber</font></td>
					<td>Turn off line numbering</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:syntax on</font></td>
					<td>Turn on syntax colors in the text</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:syntax off</font></td>
					<td>Turn off syntax colors in the text</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:w</font></td>
					<td>Save changes</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:w file</font></td>
					<td>Save changes to file</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:wq</font></td>
					<td>Save changes and quit</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:x</font></td>
					<td>Save changes and quit</td>
				</tr>
				<tr>
					<td><font class="bashcommand">a</font></td>
					<td>Switch to editing mode and continue writing where the cursor is located</td>
				</tr>
				<tr>
					<td><font class="bashcommand">A</font></td>
					<td>Switch to editing mode and continue writing at the end of the line where the cursor is located</td>
				</tr>
				<tr>
					<td><font class="bashcommand">i</font></td>
					<td>Switch to editing mode and continue writing where the cursor is located</td>
				</tr>
				<tr>
					<td><font class="bashcommand">I</font></td>
					<td>Switch to editing mode and continue writing at the beginning of the line where the cursor is
					located</td>
				</tr>
				<tr>
					<td><font class="bashcommand">cw</font></td>
					<td>Delete the rest of the word in which the cursor is located (keeps the characters located before the 
					cursor)</td>
				</tr>
				<tr>
					<td><font class="bashcommand">D</font></td>
					<td>Delete the rest of the line in which the cursor is located (keeps the characters and words located 
					before the cursor)</td>
				</tr>
				<tr>
					<td><font class="bashcommand">dd</font></td>
					<td>Delete the entire line where the cursor is located</td>
				</tr>
				<tr>
					<td><font class="bashcommand">dw</font></td>
					<td>Delete the whole word in which the cursor is located</td>
				</tr>
				<tr>
					<td><font class="bashcommand">J</font></td>
					<td>Put the next line at the end of the line where the cursor is located</td>
				</tr>
				<tr>
					<td><font class="bashcommand">o</font></td>
					<td>Open line below cursor</td>
				</tr>
				<tr>
					<td><font class="bashcommand">O</font></td>
					<td>Open line above cursor</td>
				</tr>
				<tr>
					<td><font class="bashcommand">p</font></td>
					<td>Paste below current line</td>
				</tr>
				<tr>
					<td><font class="bashcommand">P</font></td>
					<td>Paste above current line</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:u</font></td>
					<td>Undo previous command</td>
				</tr>
				<tr>
					<td><font class="bashcommand">:U</font></td>
					<td>Undo all changes to line</td>
				</tr>
				<tr>
					<td><font class="bashcommand">x</font></td>
					<td>Delete text at cursor</td>
				</tr>
				<tr>
					<td><font class="bashcommand">X</font></td>
					<td>Delete (backspace) text at cursor</td>
				</tr>
				<tr>
					<td><font class="bashcommand">yy</font></td>
					<td>Copy line in which the cursor is located</td>
				</tr>
				</table>
			</div>
			
			<h4><a href="#content2.2" onclick="showContent(2.2)">2.2. Other editors</a></h4>
			<div id="content2.2" class="hidden">
				As I previously mentioned, there is an unlimited number of editors and the choice of which to use is totally 
				personal. The following editors are available for both Linux and MacOS: vim, emacs, gedit (which is also 
				installed by default in Linux and uses a GUI, great for beginners), and Eclipse (among many others). Eclipse 
				is a lot more than an editor; it is a development environment used for programming in many other languages 
				(mainly Java) and for software development and modeling. The following are editors available only for MacOS: 
				Xcode, TextWrangler, TextMate, Notepad++, and Atom (among many others).
			</div>
			
			<h4><a href="#content2.3" onclick="showContent(2.3)">2.3. Tips for writing scripts</a></h4>
			<div id="content2.3" class="hidden">
				<ol>
					<li>
					Albeit not mandatory, the first line of any bash script should be the shebang 
					(<font class="bashcommand">#!/bin/bash</font>). This line indicates that the script is written in bash 
					(instead of tcsh, for example) and that the bash interpreter should execute it.<br><br>
					</li>
					
					<li>
					Be organized when writing scripts. As you start writing longer and more complicated programs, this 
					will become more important. Try to comment as often as possible so that other people can understand what 
					your script is doing, which parameters are needed and what they mean or to understand the output. 
					Commenting will also help you fix errors or keep track of the version, changes, authorship, etc, or to 
					remember what your script does if you don't use it for a while. To insert a comment, you simply start the 
					line with a hash (<font class="bashcommand">#</font>). Any line that starts with this symbol will not be 
					executed (except for the shebang). Also try to use indentation to know where pieces of code start and end 
					(for example when doing loops). If you don't indentate, understanding your own code will be very 
					difficult. Part of being organized is also using appropriate variable names. Use names that are associated 
					to the structure you're using (for example, if you're creating an array, naming it 
					<font class="bashcommand">array</font> will help you remember that this variable is an array and not a 
					string or a number) and try to use short names (for example, instead of naming a variable 
					<font class="bashcommand">myListOfSubjects</font>, you can call it 
					<font class="bashcommand">subjList</font>).</br><br>
					</li>
					
					<li>
					It is also a good idea to use the following commands at the beginning of any script:</br>
					<font class="bashcommand">set -e</font>: This will make the program exit as soon as it encounters an error. 
					If you don't use this, then even if there's an error your code will continue to execute.<br> 
					<font class="bashcommand">set -u</font>: This will make the program exit when using undeclared variables. 
					It will prevent the program from executing the wrong commands if you misspell a variable name.<br><br>
					</li>
					
					<li>
					Use double quotes (<font class="bashcommand">"</font>) when declaring a string, single quotes 
					(<font class="bashcommand">'</font>) when declaring a character, and no quotes when declaring numbers. 
					This will prevent word splitting (when declaring a string that has spaces) and other errors in your 
					code.<br><br>
					</li>
					
					<li>
					Use functions. This topic will be covered in chapter X. Using functions will make your code more readable, 
					reusable, and will allow you to run only parts of the code without having to comment all the lines. This 
					is especially useful when debugging or re-running a script.<br><br>
					</li>
					
					<li>
					If you are declaring a variable that the value should never change, then use the word 
					<font class="bashcommand">readonly</font> before the variable name.<br> 
					For example, if I want to declare a variable called <font class="bashcommand">age</font> with value 
					<font class="bashcommand">30</font> and this value should never be replaced, then you should declare it 
					like this:<br>
					<font class="bashcommand">readonly age=30</font><br>
					Instead of:<br>
					<font class="bashcommand">age=30</font><br><br>
					
					If at some point in the script you try to replace the value of that variable, you will get an error message:
					<br>
					<font class="bashcommand">readonly age=30</font><br>
					<font class="bashcommand">age=29</font><br>
					<font class="bashcommand">-bash: age: readonly variable</font>
					</li>
				</ol>
			</div>
			
			<h4><a href="#content2.4" onclick="showContent(2.4)">2.4. Running a script</a></h4>
			<div id="content2.4" class="hidden">
				Running a shell script is easy. You only type the path and name of the file in the command line and then press 
				enter. For example, if your script is located in the Desktop and is called helloWord.sh, then to execute it 
				you should type the following in the command line:<br>
				<font class="bashcommand">~/Desktop/helloWord.sh</font><br><br>
				If you get a Permission Denied error, this means that you must change its permissions to make it runnable. 
				The topic of permissions is a bit complicated and will be explained in detail in chapter 12. But for now, you 
				only need to know that the following command will allow you to execute the script if it's not runnable:<br>
				<font class="bashcommand">chmod 775 &lt;script_path_and_name&gt;</font>
			</div>
		</div>
		
		<h3><a href="#content3" onclick="showContent(3);">3. Variables</a></h3>
		<div id="content3" class="hidden">
			<h4><a href="#content3.1" onclick="showContent(3.1)">3.1. Utility, declaration and accessing variables</a></h4>
			<div id="content3.1" class="hidden">
				<p>
				A very important aspect of programming (in bash or any other language) is the ability to use a label (called 
				variable) to indicate some other quantity (a number, character, string or command). For example, I can use 
				the variable <font class="bashcommand">${desktop}</font> to represent the string 
				<font class="bashcommand">"/Users/monica/Desktop"</font>. Or the variable 
				<font class="bashcommand">${year}</font> to represent the number <font class="bashcommand">2020</font> 
				(after correctly declaring these variables). Variables can be used for many purposes, including making the 
				code more readable, short and organized and to prevent typing errors. They are also very useful in cases in 
				which the actual value of a variable is not known before executing the program, or when you need to save the 
				output of one command to use as input for another command. For example, when reading the contents of a file 
				you can read line by line in an iterative manner (which you will learn later), saving each line in a variable 
				and then doing something with it (depending the purpose of the program). 
				</p>
				
				<p>
				The easy thing about declaring variables in bash is that you don't have to specify data types. However, if 
				the value that you are assigning is a string of characters, you should use quotation marks 
				(<font class="bashcommand">"</font>) between the beginning and the end of your string (especially if the 
				string contains spaces). You must also be careful to not include any white space between the variable name, 
				the equals sign, and the value. Additionally, be aware that the quotation marks used in bash are 
				<font class="bashcommand">"</font>, which is different than those used in Microsoft Word. They look very 
				similar, but bash won't recognize the later ones. So, if you copy-paste from Microsoft Word a command that
				includes quotation marks, you will probably get an error.
				</p>
				
				<p>
				<font class="example">Declaring variables of different data types</font>
				In the following commands, I will assign a number to the variable <font class="bashcommand">YEAR</font>, a String 
				to the variables <font class="bashcommand">MONTH</font> and <font class="bashcommand">NAME</font> and a character to 
				the variable <font class="bashcommand">GENDER</font>. As you can observe, numbers, strings and characters should 
				be declared in a different manner.
				</p>
				
				<p>
				<font class="bashcommand">
				$ YEAR=2018<br>
				$ MONTH="August"<br>
				$ NAME="Monica Keith"<br>
				$ GENDER='F'
				</font>
				</p>
				
				<p>
				<font class="example">Common mistakes when declaring variables</font>
				The following commands will produce errors because there is a white space before and/or after the equal sign 
				(<font class="bashcommand">=</font>), or because the quotation marks (<font class="bashcommand">"</font>) are 
				missing when declaring a string that contains a space. Bellow each erroneous command you can see the error 
				that Bash produces.
				</p>
				
				<p>
				<font class="bashcommand">
				$ NAME ="Monica Keith"<br>
				-bash: NAME: command not found<br>
				$ NAME= "Monica Keith"<br>
				-bash: Monica Keith: command not found<br>
				$ NAME = "Monica Keith"<br>
				-bash: NAME: command not found<br>
				$ NAME=Monica Keith<br>
				-bash: Keith: command not found
				</font>
				</p>
				
				<p>
				Once you assign a value to a variable, you can reference it with a dollar sign, located immediately before 
				the variable name. You can also reference a variable by including curly brackets 
				(<font class="bashcommand">{}</font>) at the beginning and the end of the variable name. It is better (but 
				not mandatory) to always reference variables using brackets. This will prevent errors in your code (specially 
				when referencing strings that have spaces or special characters).
				</p>
				
				<p>
				<font class="example">Referencing variables</font>
				In the following example, I will declare variable <font class="bashcommand">VAR1</font> with value 
				<font class="bashcommand">2</font>, and variable <font class="bashcommand">VAR2</font> with value 
				<font class="bashcommand">"Subject"</font>. Then, I will use the function 
				<font class="bashcommand">echo</font> to print in the command line the value of the two variables.
				</p>
				
				<p>
				<font class="bashcommand">
				$ VAR1=2<br>
				$ VAR2="Subject"<br>
				$ echo ${VAR1}<br>
				2<br>
				$ echo ${VAR2}<br>
				Subject
				</font>
				</p>
				
				<p>
				<font class="example">Common mistakes when referencing variables</font>
				When referencing a variable, be careful not to include any space before or after the brackets. The following 
				examples will produce an error because of the inclusion of a space around the brackets:
				</p>
				
				<p>
				<font class="bashcommand">
				$ echo ${ VAR2}<br>
				-bash: ${ VAR2}: bad substitution<br>
				$ echo ${VAR2 }<br>
				-bash: ${VAR2 }: bad substitution<br>
				$ echo ${ VAR2 }<br>
				-bash: ${ VAR2 }: bad substitution
				</font>
				</p>
				
				<p>
				The following erroneous reference (with a space between the dollar sign and the first bracket) will not cause 
				an error but will not substitute <font class="bashcommand">${VAR2}</font> for the correct value. It will just 
				print <font class="bashcommand">$ {VAR2}</font> instead of <font class="bashcommand">Subject</font>.
				</p>
				
				<p>
				<font class="bashcommand">
				$ echo $ {VAR2}<br>
				$ {VAR2}
				</font>
				</p>
				
				<p>
				<font class="example">Concatenating variables</font>
				You can concatenate different variables and characters to form new strings. To do this, you will need to 
				reference the variables using the curly brackets and use quotation marks at the beginning and the end of your 
				final string. For example, if you want to use the previously declared variables 
				<font class="bashcommand">VAR1</font> and <font class="bashcommand">VAR2</font> to generate the String 
				<font class="bashcommand">Subject_02</font>, you can concatenate them the following way:
				</p>
				
				<p>
				<font class="bashcommand">
				$ echo ${VAR2}<br>
				Subject<br>
				$ echo ${VAR1}<br>
				2<br>
				$ echo "${VAR2}_0${VAR1}"<br>
				Subject_02
				</font>
				</p>
				
				<p>
				Here are a few more examples on how to declare and concatenate variables:
				</p>
				
				<p>
				<font class="bashcommand">
				$ ID="Subject_202"<br>
				$ VOLUME=20<br>
				$ MEASURE="mm"<br>
				$ echo "${ID}: ${VOLUME}${MEASURE}"<br>
				Subject_202: 20mm
				</font>
				</p>
				
				<p>
				<font class="bashcommand">
				$ VAR1="MacOS"<br>
				$ VAR2="Linux"<br>
				$ VAR3="Windows"<br>
				$ echo "(${VAR1},${VAR2},${VAR3})"<br>
				(MacOS,Linux,Windows)
				</font>
				</p>
				
				<p>
				<font class="example">A common mistake when concatenating variables</font>
				It is very common when you are referencing many variables or concatenating variables to create a long string 
				to forget the closing quotation mark. For example, writing<br>
				<font class="bashcommand">echo "(${VAR1},${VAR2},${VAR3})</font><br>
				instead of<br>
				<font class="bashcommand">echo "(${VAR1},${VAR2},${VAR3})"</font>
				</p>
				
				<p>
				When that happens and you click enter in the keyboard, the command line won't allow you to enter any more 
				commands. You will see the symbol <font class="bashcommand">></font> and if you continue pressing enter it 
				will do nothing. This is because the command line is waiting for you to close the open String. To close the 
				string just add the missing quotation mark or cancel and ignore what you have written so far in the current 
				line by pressing CTR+C. 
				</p>
			</div>
			
			<h4><a href="#content3.2" onclick="showContent(3.2)">3.2. Rules for assigning variable names</a></h4>
			<div id="content3.2" class="hidden">
				<p>You can assign any value to a variable. However, a variable cannot have just any name. There are a few 
				rules for assigning variable names.</p>
				
				<ol>
					<li>
					A variable name should not be a number.<br>
					This type of variable is only used to read arguments on a shell script. For example, 
					<font class="bashcommand">$1</font> refers to the first argument of a script, 
					<font class="bashcommand">$2</font> to the second argument, etc. Later you will learn the meaning and use 
					of script arguments.
					</li><br>
					
					<li>
					Variable names must start with an alphabetical letter or an underscore.<br>
					Variable names can contain any number, but it should not be located at the beginning.
					</li><br>
					
					<li>
					Do not use <font class="bashcommand">$</font> or <font class="bashcommand">${}</font> to declare a 
					variable. These characters are used only to reference variables (not to declare).
					</li><br>
					
					<li>
					Do <u>NOT</u> assign the name <font class="bashcommand">PATH</font> to any variable.<br>
					If you do so, you won't get any error right away. But it will mess up the execution of other programs. 
					<font class="bashcommand">PATH</font> is a system variable that specifies a set of directories where 
					executable programs are located. For example, when you install a software that runs in the command line 
					(i.e. FSL), the path to the executable of that program will be included in the system variable 
					<font class="bashcommand">PATH</font>. So, if you rename that variable, you won't be able to execute the 
					program again in the current terminal. If you forget about this rule and mistakenly re-write the value 
					of this variable, close the current terminal and open a new one. Every time you open a new terminal, 
					this system variable will be re-set to the correct value (which is stored in the bash_profile, we will 
					talk about this file in a later chapter). At any moment you can know the value of your 
					<font class="bashcommand">PATH</font> by typing <font class="bashcommand">echo ${PATH}</font>. You will 
					see something like this (although this will significantly varies between one computer and the other 
					depending which programs you have installed and referenced in the bash_profile):<br><br>
					
					<font class="bashcommand">
					$ echo ${PATH}<br>
					/usr/local/fsl/bin:/Applications/freesurfer/bin:/Applications/freesurfer/fsfast/bin:/Applications/freesurfer/tktools:/usr/local/fsl/bin:/Applications/freesurfer/mni/bin:/Users/bunbury/bin:/Applications/MATLAB_R2018a.app/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin
					</font><br><br>
					
					Another Unix reserved name that you should not use is <font class="bashcommand">BASH</font>. There is a long list 
					of Unix reserved words that I will not include here but you will learn as you get more experienced.
					</li><br>
					
					<li>
					Avoid using the following reserved characters from appearing in variable names:
					<font class="bashcommand">/ &gt; &lt; | : &amp; . *</font><br><br>	
					</li>
					
					<font class="example">Some valid and invalid variable names</font><br>
					<table>
					<caption>Valid and invalid variable names</caption>
					<tr>
						<th><b>Valid variable names</b></th>
						<th><b>Invalid variable names</b></th>
					</tr>
					<tr>
						<td>V</td>
						<td>1</td>
					</tr>
					<tr>
						<td>VAR</td>
						<td>1VAR</td>
					</tr>
					<tr>
						<td>VAR1</td>
						<td>2_VAR</td>
					</tr>
					<tr>
						<td>VAR_1</td>
						<td>.VAR</td>
					</tr>
					<tr>
						<td>_VAR1</td>
						<td>$VAR</td>
					</tr>
					<tr>
						<td>_1VAR</td>
						<td>${VAR}</td>
					</tr>
					<tr>
						<td>VARIABLE_NAME</td>
						<td>{VAR}</td>
					</tr>
					<tr>
						<td>PATH1</td>
						<td>PATH</td>
					</tr>
					<tr>
						<td>BASH1</td>
						<td>BASH</td>
					</tr>
					</table>
					
					<p>
					Variable names can be in lower and/or upper case. However, they are case sensitive. If you declare a 
					variable as <font class="bashcommand">VAR1</font>, but you reference it as 
					<font class="bashcommand">${var1}</font>, bash will not recognize the value. You must reference it as 
					<font class="bashcommand">${VAR1}</font>.
					</p>
				</ol>
			</div>
			
			<h4><a href="#content3.3" onclick="showContent(3.3)">3.3. Reading user input into a variable</a></h4>
			<div id="content3.3" class="hidden">
				<p>
				The command <font class="bashcommand">read</font> is the counterpart of <font class="bashcommand">echo</font>. 
				Instead of printing things in the terminal the way <font class="bashcommand">echo</font> does, 
				<font class="bashcommand">read</font> reads input from the user and saves it in the specified variable (in 
				this case <font class="bashcommand">VAR</font>). The word read is followed by the name of the variable where 
				you want to save the information. In the following example, I am going to read the input from the user and 
				save it in the variable <font class="bashcommand">VAR</font>. Generally, Bash will read everything that is 
				written until the user presses the Enter key and save all the information in the corresponding variable.
				</p>
				
				<p>
				<font class="example">Saving user input into a new variable</font>
				<font class="bashcommand">
				$ echo "Username:"<br>
				Username:<br>
				$ read VAR<br>
				Noemi<br>
				$ echo "You typed: ${VAR}"<br>
				You typed: Noemi
				</font>
				</p>
				
				<p>
				There are some flags (options) that can be added to the command read to change the way in which information is 
				displayed or captured:
				</p>
				
				<table>
				<caption>Options for reading user input</caption>
				<tr>
					<th><b>Flag</b></th>
					<th><b>Usage</b></th>
				</tr>
				<tr>
					<td><font class="bashcommand">-s</font></td>
					<td>
					Silent mode. The characters that the user inputs are not displayed (used specially when asking the user to 
					input a password).
					</td>
				</tr>
				<tr>
					<td><font class="bashcommand">-p "MESSAGE"</font></td>
					<td>
					Displays the <font class="bashcommand">MESSAGE</font> where the user must write the input.
					</td>
				</tr>
				<tr>
					<td><font class="bashcommand">-n NUM_CHARS</font></td>
					<td>
					The input line ends after reading <font class="bashcommand">NUM_CHARS</font> characters, rather than waiting for the 
					user to press Enter in the keyboard.
					</td>
				</tr>
				<tr>
					<td><font class="bashcommand">-d 'CHAR_NEW_LINE'</font></td>
					<td>
					<font class="bashcommand">CHAR_NEW_LINE</font> is used to determine the end of the input line (if different than Enter).
					</td>
				</tr>
				<tr>
					<td><font class="bashcommand">-r</font></td>
					<td>
					Backslash does not act as an escape character but instead is part of the line.
					</td>
				</tr>
				<tr>
					<td><font class="bashcommand">-t NSECONDS</font></td>
					<td>
					Bash will stop reading the user input after <font class="bashcommand">NSECONDS</font>. Whatever was entered in that 
					time is captured as the input line.
					</td>
				</tr>
				<tr>
					<td><font class="bashcommand">-a ARRAY_NAME</font></td>
					<td>
					The words that the user inputs are assigned to sequential indices of the array 
					<font class="bashcommand">ARRAY_NAME</font>. The array is emptied before assigning the values if it 
					already exists.
					</td>
				</tr>
				<tr>
					<td><font class="bashcommand">-u FILEDESCRIPTOR</font></td>
					<td>
					Read input from <font class="bashcommand">FILEDESCRIPTOR</font>.
					</td>
				</tr>
				</table>
				
				<p>
				The following examples will show how to use the flags mentioned in the previous table. Be aware on how the 
				variable name is always written at the end of the command. In this section, I will not explain the use of 
				flags <font class="bashcommand">-a</font> and <font class="bashcommand">-u</font> because we haven't learned 
				yet about arrays or file manipulation. Some of the examples will also show common mistakes that will make bash 
				show an error.
				</p>
				
				<p>
				<font class="example">read -s</font>
				In the following example, the flag <font class="bashcommand">-s</font> causes the user input to be silenced, 
				so when the user writes the password, it is not shown in the screen. If the user input is 
				<font class="bashcommand">ThisIsMyPassword</font>, then that string is saved in the variable 
				<font class="bashcommand">PASSWORD</font>. While the user is writing its password and until it presses Enter, 
				you will see the following symbol underneath <font class="bashcommand">$ read -s PASSWORD </font>:
				<img src="pwd.png"/>. Afterwards, the symbol will disappear.
				</p>
				
				<p>
				In the example of a wrong syntax, the mistake is that the variable <font class="bashcommand">PASSWORD</font> 
				is written before the flag <font class="bashcommand">-s</font>. The variable must go at the end of the command 
				independently of which flags are used. As a result, bash is not silencing the user input, is giving the invalid 
				identifier error, and is not saving any string in the variable.
				</p>
				
				<table>
				<tr>
					<th><b>Correct syntax:</b></th>
					<th><b>Wrong syntax:</b></th>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
						$ read -s PASSWORD<br>
						<img src="pwd.png"/><br>
						$ echo ${PASSWORD}</br>
						ThisIsMyPassword
						</font>
					</td>
					<td>
						<font class="bashcommand">
						$ read PASSWORD -s<br>
						ThisIsMyPassword<br>
						-bash: read: `-s': not a valid identifier
						</font>
					</td>
				</tr>
				</table>
				
				<p>
				<font class="example">read -p</font>
				The flag <font class="bashcommand">-p</font> is useful if you want to prompt a message so that the user 
				knows what the input should be. The examples in the following table combine the flags 
				<font class="bashcommand">-p</font> and <font class="bashcommand">-s</font> to indicate the user to input a 
				password and hide the password while its being typed. The prompt message should go right after the flag 
				<font class="bashcommand">-p</font>.
				</p>
				
				<p>
				The following table shows some examples of commands written using a wrong syntax (as well as the correct way 
				to write them). In the first example, the error is that the prompt message is not located right after the flag 
				<font class="bashcommand">-p</font> (instead, it is located after the flag <font class="bashcommand">-s</font>). 
				In the second example, the error is that the variable <font class="bashcommand">PASSWORD</font> is not located 
				at the end of the command. In the third example, the problem is that the prompt message 
				(<font class="bashcommand">Please input your password</font>) is not surrounded by quotation marks. So, for 
				bash only the first word of that sentence (<font class="bashcommand">Please</font>) is the prompt message, and 
				the next word (<font class="bashcommand">input</font>) is read as the variable name. The rest of the command 
				(<font class="bashcommand">your password</font>) is ignored. That is why when reading 
				<font class="bashcommand">${PASSWORD}</font>, nothing is echoed, the variable is empty because nothing was 
				saved with that variable name. Instead, the input was saved in <font class="bashcommand">${input}</font>. This 
				is the reason why the prompt message should always be surrounded by quotation marks.
				</p>
				
				<table>
				<tr>
					<th><b>Correct syntax:</b></th>
					<th><b>Wrong syntax:</b></th>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
						$ read -p "Please input your password" -s PASSWORD<br>
						Please input your password <img src="pwd.png"/><br>
						$ echo ${PASSWORD}<br> 
						ThisIsMyPassword
						</font>
					</td>
					<td>
						<font class="bashcommand">
						$ read -p -s "Please input your password" PASSWORD<br>
						-s<br>
						-bash: read: `Please input your password': not a valid identifier
						</font>
					</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
						$ read -p "Please input your password" -s PASSWORD<br>
						Please input your password <img src="pwd.png"/><br>
						$ echo ${PASSWORD}<br> 
						ThisIsMyPassword
						</font>
					</td>
					<td>
						<font class="bashcommand">
						$ read PASSWORD -s -p "Please input your password"<br>
						ThisIsMyPassword<br>
						-bash: read: `-s': not a valid identifier
						</font>
					</td>
				</tr>
				<tr>
					<td>
					</td>
					<td>
						<font class="bashcommand">
						read -s -p Please input your password ThisIsMyPassword<br>
						$ echo $PASSWORD<br>
						<br>
						$ echo ${input}<br>
						ThisIsMyPassword
						</font>
					</td>
				</tr>
				</table>
				
				<p>
				<font class="example">read -n</font>
				In the following example, <font class="bashcommand">-n 1</font> forces bash to accept only one character in the 
				input. So, the terminal will finish reading after one character. Here we are combining flags 
				<font class="bashcommand">-n</font> and <font class="bashcommand">-p</font> to also prompt a message to the 
				user.
				</p>
				
				<p>
				In the wrong syntax, <font class="bashcommand">1</font> (the number of characters to be accepted) and the 
				prompt message are located in the wrong place. The number of characters accepted should always go after 
				<font class="bashcommand">-n</font> and the prompt message should always go after 
				<font class="bashcommand">-p</font>. 
				</p>
				
				<table>
				<tr>
					<th><b>Correct syntax:</b></th>
					<th><b>Wrong syntax:</b></th>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
						$ read -n 1 -p "Do you wish to continue? (y/n)" VAR<br>
						Do you wish to continue? (y/n)y<br>
						$ echo $VAR<br>
						y
						</font>
					</td>
					<td>
						<font class="bashcommand">
						$ read -n -p 1 "Do you wish to continue? (y/n)" VAR<br>
						-bash: read: -p: invalid number
						</font>
					</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
						$ read -p "Do you wish to continue? (y/n)" -n 1 VAR<br>
						Do you wish to continue? (y/n)y<br>
						$ echo $VAR<br>
						y					
						</font>
					</td>
					<td>
						<font class="bashcommand">
						</font>
					</td>
				</tr>
				</table>
				
				<p>
				<font class="example">read -d</font>
				In the following example the end of the line is determined by the character <font class="bashcommand">#</font> 
				instead of Enter (using the flag <font class="bashcommand">-d</font>). As soon as the user types 
				<font class="bashcommand">#</font>, bash finishes reading and saves the input in the variable 
				<font class="bashcommand">VAR</font>.
				</p>
				
				<p>
				In the wrong syntax, the command is missing the apostrophes (<font class="bashcommand">'</font>) around the 
				character <font class="bashcommand">#</font>.
				</p>
				
				<table>
				<tr>
					<th><b>Correct syntax:</b></th>
					<th><b>Wrong syntax:</b></th>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
						$ read -d '#' VAR<br>
						$ echo $VAR<br>
						SomeText
						</font>
					</td>
					<td>
						<font class="bashcommand">
						$ read -d # VAR<br>
						-bash: read: -d: option requires an argument<br>
						read: usage: read [-ers] [-u fd] [-t timeout] [-p prompt] [-a array] [-n nchars] [-d delim] [name ...]
						</font>
					</td>
				</tr>
				</table>
				
				<p>
				<font class="example">The backslash</font>
				In bash, certain characters have special meanings. For example, the dollar sign 
				(<font class="bashcommand">$</font>) is used to reference a variable. When you type 
				<font class="bashcommand">${VAR}</font>, it will print the value of 
				<font class="bashcommand">VAR</font> instead of the actual string 
				"<font class="bashcommand">${VAR}</font>". The backslash (<font class="bashcommand">\</font>) is used to remove 
				those special meanings from the character followed by it. 
				</p>
				
				<p>
				<font class="bashcommand">
				$ VAR="Some text"<br>
				$ echo ${VAR}<br>
				Some text<br>
				$ echo \${VAR}<br>
				${VAR}
				</font>
				</p>
				
				<p>
				When using the flag <font class="bashcommand">-r</font>, the backslash is part of the line instead of being 
				used as an escape character. The following table shows examples in which the user inputs the same string but it 
				is read differently because in one case the flag is used (first column) but not in the other (second column).
				</p>
				
				<table>
				<tr>
					<th><b>Examples using flag -r</b></th>
					<th><b>Examples without the flag -r</b></th>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
						$ read -r VAR<br>
						C:\Documents\Newsletters\Summer2018.pdf<br>
						$ echo ${VAR}<br>
						C:\Documents\Newsletters\Summer2018.pdf
						</font>
					</td>
					<td>
						<font class="bashcommand">
						$ read VAR<br>
						C:\Documents\Newsletters\Summer2018.pdf<br>
						$ echo ${VAR}<br>
						C:DocumentsNewslettersSummer2018.pdf
						</font>
					</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
						$ read -r MESSAGE<br>
						In HTML \n is used to indicate a new line<br>
						$ echo ${MESSAGE}<br>
						In HTML \n is used to indicate a new line
						</font>
					</td>
					<td>
						<font class="bashcommand">
						$ read MESSAGE<br>
						In HTML \n is used to indicate a new line<br>
						$ echo ${MESSAGE}<br>
						In HTML n is used to indicate a new line
						</font>
					</td>
				</tr>
				</table>
			</div>
			
			<h4><a href="#content3.4" onclick="showContent(3.4)">3.4. Using &lt;&lt;&lt; to get input from a different source</a></h4>
			<div id="content3.4" class="hidden">
				<p>
				So far, we have used the command <font class="bashcommand">read</font> to save the user input into a variable. 
				This command can also be used to read from other sources (i.e. other variables or files).
				</p>
				
				<p>
				<font class="example">Reading content from a variable</font>
				In the following example, <font class="bashcommand">read</font> reads the content of the variable 
				<font class="bashcommand">VAR</font>, but only keeps the first character (because it is using the 
				<font class="bashcommand">-n 1</font> flag):
				</p>
				
				<p>
				<font class="bashcommand">
				$ VAR=yes<br>
				$ read -n 1 R &lt;&lt;&lt; ${VAR}<br>
				$ echo ${R}<br>
				y
				</font>
				</p>
				
				<p>
				<font class="example">Reading and saving the output of a function</font>	
				<font class="bashcommand">read</font> also allows you to read the output of a function and save it in a variable. 
				In this example, we are saving the output of the <font class="bashcommand">pwd</font> function into the variable 
				<font class="bashcommand">CURRENT_DIR</font>. <font class="bashcommand">pwd</font> is a function that prints the 
				current folder in which you are located in the command line. 
				</p>
				
				<p>
				<font class="bashcommand">
				$ pwd<br>
				/Users/myUserName<br>
				$ read CURRENT_DIR &lt;&lt;&lt; $(pwd)<br>
				$ echo ${CURRENT_DIR}<br>
				/Users/myUserName
				</font>
				</p>
				
				<p>
					<font class="example">**Example specific for people doing neuroimaging**</font>
					<b>WARNING:</b> If you have never analyzed MRI brain images, the following paragraph might sound like written in 
					extraterrestrial language, and it probably will not work in your computer since you need neuroimaging software
					to execute it.<br><br>
					
					In this example, we are reading the output of a function and saving it in the variable 
					<font class="bashcommand">VOL</font>. The output of this function (<font class="bashcommand">fslstats -V</font>) 
					consists of two values separated by a space. The first value is the volume of a region of interest (ROI) from 
					an MRI file in number of voxels, and the second value is the volume in mm<sup>3</sup>. Because we are using the 
					flag <font class="bashcommand">-d ' '</font>, it will read only until the first space (which is the character 
					we are choosing to indicate the end of line). So, bash will save in the variable 
					<font class="bashcommand">VOL</font> only the volume in number of voxels and not in mm<sup>3</sup>. 
				</p>
				
				<p>
					<font class="bashcommand">
					$ fslstats /Users/myUserName/Desktop/MRI/subject001/LGN_L.nii.gz -V<br>
					196 186.920166<br>
					$ read -d ' ' VOL &lt;&lt;&lt; $(fslstats /Users/myUserName/Desktop/MRI/subject001/LGN_L.nii.gz -V)<br>
					$ echo $VOL<br>
					196
					</font>
				</p>
			</div>
		</div>
		
		<h3><a href="#content4" onclick="showContent(4);">4. Arithmetic calculations</a></h3>
		<div id="content4" class="hidden">
			<h4><a href="#content4.1" onclick="showContent(4.1)">4.1. Integer calculations</a></h4>
			<div id="content4.1" class="hidden">
				<p>In order to compute arithmetic calculations with integers you can use one of the following syntaxes:</p>
				
				<table>
				<tr>
					<th><b>Syntax</b></th>
					<th><b>Usage</b></th>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">$(( OPERATION ))</font>
					</td>
					<td>
						Evaluates <font class="bashcommand">OPERATION</font>. This can be any arithmetic operation with 
						integer numbers. Including addition (<font class="bashcommand">+</font>), subtraction 
						(<font class="bashcommand">-</font>), multiplication (<font class="bashcommand">*</font>), division 
						(<font class="bashcommand">&#247;</font>), square root (<font class="bashcommand">sqrt(NUM)</font>), 
						exponentiation (<font class="bashcommand">NUM**EXP</font>), etc.
					</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">((++NUM))</font>
					</td>
					<td>
						Increases variable <font class="bashcommand">NUM</font> in 1 <u>before</u> evaluating any expression that 
						contains <font class="bashcommand">++NUM</font>.
					</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">((NUM++))</font>
					</td>
					<td>
						Increases variable <font class="bashcommand">NUM</font> in 1 <u>after</u> evaluating any expression 
						that contains <font class="bashcommand">NUM++</font>.
					</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">((--NUM))</font>
					</td>
					<td>
						Decreases variable <font class="bashcommand">NUM</font> in 1 <u>before</u> evaluating any expression 
						that contains <font class="bashcommand">--NUM</font>.
					</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">((NUM--))</font>
					</td>
					<td>
						Decreases variable <font class="bashcommand">NUM</font> in 1 <u>after</u> evaluating any expression 
						that contains <font class="bashcommand">NUM--</font>.
					</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">((VAR+=NUM))</font>
					</td>
					<td>
						Increases variable <font class="bashcommand">VAR</font> in <font class="bashcommand">NUM</font>. 
						Equivalent to <font class="bashcommand">VAR=$(( $VAR + $NUM ))</font>.
					</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">((VAR-=NUM))</font>
					</td>
					<td>
						Decreases variable <font class="bashcommand">VAR</font> in <font class="bashcommand">NUM</font>. 
						Equivalent to <font class="bashcommand">VAR=$(( $VAR - $NUM ))</font>.
					</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">(( $i % 2 ))</font>
					</td>
					<td>
						<font class="bashcommand">true</font> if <font class="bashcommand">i</font> is an odd number, 
						<font class="bashcommand">false</font> if <font class="bashcommand">i</font> is even.
					</td>
				</tr>
				</table>
				
				<p>
					<font class="example">Usage of $(( OPERATION ))</font>
				</p>
				
				<table>
				<tr>
					<th><b>Example</b></th>
					<th><b>Explanation</b></th>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
							$ echo $(( 2 + 1 ))<br>
							3
						</font>
					</td>
					<td>2 + 1</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
						$ A=2<br>
						$ echo $(( ${A} + 1 ))<br>
						3
						</font>
					</td>
					<td>A + 1</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
							$ A=2<br>
							$ B=1<br>
							$ echo $(( ${A} + ${B} ))<br>
							3
						</font>
					</td>
					<td>A + B</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
						$ A=2<br>
						$ B=1<br>
						$ echo $(( ${A} - ${B} ))<br>
						1
						</font>
					</td>
					<td>A - B</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
							$ A=2<br>
							$ B=1<br>
							$ echo $(( ${A} * ${B} ))<br>
							2
						</font>
					</td>
					<td>A x B</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
							$ A=2<br>
							$ B=1<br>
							$ echo $(( ${A} / ${B} ))<br>
							2
						</font>
					</td>
					<td>A &#247; B</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
							$ A=2<br>
							$ B=1<br>
							$ echo $(( $(( ${A} + ${B} )) * $(( ${A} - ${B} )) ))<br>
							3
						</font>
					</td>
					<td>(A + B) x (A - B)</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
							$ A=2<br>
							$ B=1<br>
							$ echo $(( ${B} / ${A} ))<br>
							0
						</font>
					</td>
					<td>
						B &#247; A<br>
						The result is zero because this syntax is used for integer numbers. So, if the result of the operation 
						is not an integer, it will be rounded to the nearest integer. In the following section you will learn 
						how to operate with non-integer numbers. 
					</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
							$ A=2<br>
							$ echo $(( ${A} ** 3 ))<br>
							8
						</font>
					</td>
					<td>A<sup>3</sup></td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
						$ A=2<br>
						$ B=4<br>
						$ echo $(( ${A} ** ${B} ))<br>
						16
						</font>
					</td>
					<td>A<sup>B</sup></td>
				</tr>
				</table>
				
				<p>
				<font class="example">Usage of ((++NUM)) and ((NUM++))</font>
				In order to increment the value of a variable by one, there are a couple of options. Some of these options will be 
				very useful when doing iterations (which you will learn later on).
				</p>
				
				<table>
				<tr>
					<th><b>${NUM} + 1</b></th>
					<th><b>((++NUM))</b></th>
					<th><b>((NUM++))</b></th>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
						$ NUM=1<br>
						$ echo $(( ${NUM} + 1 ))<br>
						2<br>
						$ echo ${NUM}<br>
						1<br><br>
						</font>
							
						The command echo <font class="bashcommand">$(( ${NUM} + 1 ))</font> prints the result of 
						<font class="bashcommand">NUM</font> plus one, but it does not modify the value of 
						<font class="bashcommand">NUM</font>. For that reason, when <font class="bashcommand">NUM</font> is 
						echoed at the end, it still has value 1 (instead of 2).
					</td>
					<td>
						<font class="bashcommand">
						$ NUM=1<br>
						$ echo $((++NUM))<br>
						2<br>
						$ echo ${NUM}<br>
						2<br><br>
						</font>
						
						The command <font class="bashcommand">echo $((++NUM))</font> is equivalent to this sequence of 
						instructions:<br><br>
						
						<font class="bashcommand">
						NUM=$(( ${NUM} + 1 ))<br>
						echo ${NUM}<br><br>
						</font>
						
						First, increases the value of variable <font class="bashcommand">NUM</font> in one, and then it echoes 
						the result. Opposite to the example in the left, here the variable value is actually modified. And 
						opposite to the example in the right, the variable value is modified before the other instruction 
						(<font class="bashcommand">echo</font>).
					</td>
					<td>
						<font class="bashcommand">
						$ NUM=1<br>
						$ echo $((NUM++))<br>
						1<br>
						$ echo ${NUM}<br>
						2<br><br>
						</font>
						
						The command echo <font class="bashcommand">$((NUM++))</font> is equivalent to this sequence of 
						instructions:<br><br>
						
						<font class="bashcommand">
						echo ${NUM}<br>
						NUM=$(( ${NUM} + 1 ))<br><br>
						</font>
						
						First echoes the value of <font class="bashcommand">NUM</font>. Then, it increases the value of the 
						variable. 
					</td>		
				</tr>
				</table><br>
				
				<table>
				<tr>
					<th><b>${NUM} + 1</b></th>
					<th><b>((++NUM))</b></th>
					<th><b>((NUM++))</b></th>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
						$ NUM=1<br>
						$ A=$(( ${NUM} + 1 ))<br>
						$ echo ${A}<br>
						2<br>
						$ echo ${NUM}<br
						1<br><br>
						</font>
						
						The command <font class="bashcommand">A=$(( ${NUM} + 1 ))</font> assigns to 
						<font class="bashcommand">A</font> the value of <font class="bashcommand">NUM</font> plus one, but it 
						does not modify the value of <font class="bashcommand">NUM</font>.
					</td>
					<td>
						<font class="bashcommand">
						$ NUM=1<br>
						$ A=$((++NUM))<br>
						$ echo ${A}<br>
						2<br>
						$ echo ${NUM}<br>
						2<br><br>
						</font>
						
						The command <font class="bashcommand">A=$((++NUM))</font> is equivalent to this sequence of 
						instructions:<br><br>
						
						<font class="bashcommand">
						NUM=$(( ${NUM} + 1 ))<br>
						A=${NUM}<br><br>
						</font>
						
						First increases the value of variable <font class="bashcommand">NUM</font> in one, and then it assigns 
						the new value to <font class="bashcommand">A</font>. So, after the operation both variables 
						(<font class="bashcommand">A</font> and <font class="bashcommand">NUM</font>) will have value 2.
					</td>
					<td>
						<font class="bashcommand">
						$ NUM=1<br>
						$ A=$((NUM++))<br>
						$ echo ${A}<br>
						1<br>
						$ echo ${NUM}<br>
						2<br><br>
						</font>
						
						The command <font class="bashcommand">A=$((NUM++))</font> is equivalent to this sequence of 
						instructions:<br><br>
						
						<font class="bashcommand">
						A=${NUM}<br>
						NUM=$(( ${NUM} + 1 ))<br><br>
						</font>
						
						First assigns the value of <font class="bashcommand">NUM</font> to the new variable <font class="bashcommand">A</font>. 
						After that, it increases the value of <font class="bashcommand">NUM</font>. So, if the initial value of 
						<font class="bashcommand">NUM</font> was 1, after the operation <font class="bashcommand">A</font> will equal 1 and 
						<font class="bashcommand">NUM</font> will equal 2.
					</td>
				</tr>
				</table>
				
				<p>
					<font class="example">Usage of ((--NUM)) and ((NUM--))</font>
					Expressions <font class="bashcommand">((--NUM))</font> and <font class="bashcommand">((NUM--))</font> work in 
					a very similar way than the previous ones, but instead of increasing the value of
					 <font class="bashcommand">NUM</font> by one, they decrease the value of <font class="bashcommand">NUM</font> 
					 by one. These expressions will also be very useful once you learn iteration. 
				</p>
				
				<table>
				<tr>
					<th><b>${NUM} - 1</b></th>
					<th><b>((--NUM))</b></th>
					<th><b>((NUM--))</b></th>
				</tr>
				<tr>
					<td>
					<font class="bashcommand">
					$ NUM=1<br>
					$ echo $(( ${NUM} - 1 ))<br>
					0<br>
					$ echo ${NUM}<br>
					1<br><br>		
					</font>

					The command echo <font class="bashcommand">$(( ${NUM} - 1 ))</font> prints the result of 
					<font class="bashcommand">NUM</font> minus one, but it does not modify the value of 
					<font class="bashcommand">NUM</font>. For that reason, when <font class="bashcommand">NUM</font> is echoed 
					at the end, it still has value 1 (instead of 0).
					</td>
					<td>
					<font class="bashcommand">
					$ NUM=1<br>
					$ echo $((--NUM))<br>
					0<br>
					$ echo ${NUM}<br>
					0<br><br>
					</font>

					The command echo <font class="bashcommand">$((--NUM))</font> is equivalent to this sequence of instructions:

					<font class="bashcommand">
					NUM=$(( ${NUM} - 1 ))<br>
					echo ${NUM}<br><br>
					</font>

					First, decreases the value of variable <font class="bashcommand">$NUM</font> in one, and then it echoes the 
					result. Opposite to the example in the left, here the variable value is actually modified. And opposite to 
					the example in the right, the variable value is modified before the other instruction 
					(<font class="bashcommand">=</font>).
					</td>
					<td>
					<font class="bashcommand">
					$ NUM=1<br>
					$ echo $((NUM--))<br>
					1<br>
					$ echo ${NUM}<br>
					0<br><br>
					</font>

					The command echo <font class="bashcommand">$((NUM--))</font> is equivalent to this sequence of 
					instructions:<br><br>

					<font class="bashcommand">
					echo ${NUM}<br>
					NUM=$(( ${NUM} - 1 ))<br><br>
					</font>

					First, echoes the value of <font class="bashcommand">NUM</font>. Then, it decreases the value of the 
					variable. 
					</td>
				</tr>
				</table><br>
				
				<table>
				<tr>
					<th><b>${NUM} - 1</b></th>
					<th><b>((--NUM))</b></th>
					<th><b>((NUM--))</b></th>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
							$ NUM=1<br>
							$ A=$(( ${NUM} - 1 ))<br>
							$ echo ${A}<br>
							0<br>
							$ echo ${NUM}<br>
							1<br><br>
						</font>
						
						The command <font class="bashcommand">A=$(( ${NUM} - 1 ))</font> assigns to 
						<font class="bashcommand">A</font> the value of <font class="bashcommand">NUM</font> minus one, but it 
						does not modify the value of <font class="bashcommand">NUM</font>.
					</td>
					<td>
						<font class="bashcommand">
							$ NUM=1<br>
							$ A=$((--NUM))<br>
							$ echo ${A}<br>
							0<br>
							$ echo ${NUM}<br>
							0<br><br>
						</font>
						
						The command <font class="bashcommand">A=$((--NUM))</font> is equivalent to this sequence of 
						instructions:<br><br>
						
						<font class="bashcommand">
							NUM=$(( ${NUM} - 1 ))<br>
							A=${NUM}<br><br>
						</font>			
						
						First, decreases the value of variable <font class="bashcommand">NUM</font> in one, and then it assigns 
						the new value to <font class="bashcommand">A</font>. So, after the operation both variables 
						(<font class="bashcommand">A</font> and <font class="bashcommand">NUM</font>) will have value 0.			
					</td>
					<td>
						<font class="bashcommand">
							$ NUM=1<br>
							$ A=$((NUM--))<br>
							$ echo ${A}<br>
							1<br>
							$ echo ${NUM}<br>
							0<br><br>
						</font>
						
						The command <font class="bashcommand">A=$((NUM--))</font> is equivalent to this sequence of 
						instructions:<br><br>
						
						<font class="bashcommand">
							A=${NUM}<br>
							NUM=$(( ${NUM} - 1 ))<br><br>
						</font>
						
						First, assigns the value of <font class="bashcommand">NUM</font> to the new variable 
						<font class="bashcommand">A</font>. After that, it increases the value of 
						<font class="bashcommand">NUM</font>. So, if the initial value of <font class="bashcommand">NUM</font> was 
						1, after the operation <font class="bashcommand">A</font> will equal 1 and 
						<font class="bashcommand">NUM</font> will equal 2.
					</td>
				</tr>
				</table>
				
				<p>
					<font class="example">Usage of ((VAR+=NUM))</font>
					This expression is a compact way of writing <font class="bashcommand">VAR=$(( ${VAR} + ${NUM} ))</font>
				</p>
				
				<table>
				<tr>
					<th><b>Compact expression</b></th>
					<th><b>Extended equivalent</b></th>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
							$ A=1<br>
							$ ((A+=2))<br>
							$ echo ${A}<br>
							3<br><br>
						</font>				
					</td>
					<td>
						<font class="bashcommand">((A+=2))</font> is equivalent to:<br><br>
	
						<font class="bashcommand">A=$(( ${A} + 2 ))</font>
					</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
							$ A=1<br>
							$ B=$((A+=2))<br>
							$ echo ${A}<br>
							3<br>
							$ echo ${B}<br>
							3<br>
						</font>
					</td>
					<td>
						<font class="bashcommand">B=$((A+=2))</font> is equivalent to this sequence of instructions:<br><br>
	
						<font class="bashcommand">
							A=$(( ${A} + 2 ))<br>
							B=${A}
						</font>
					</td>
				</tr>		
				<tr>
					<td>
						<font class="bashcommand">
							$ A=1<br>
							$ B=9<br>
							$ ((A+=B))<br>
							$ echo ${A}<br>
							10<br>
							$ echo ${B}<br>
							9
						</font>					
					</td>
					<td>
						<font class="bashcommand">((A+=B))</font> is equivalent to:<br><br>
	
						<font class="bashcommand">A=$(( ${A} + ${B} ))</font><br><br>
	
						The value of <font class="bashcommand">B</font> is not being modified.
					</td>
				</tr>
				<tr>
					<td>
						<font class="bashcommand">
							$ A=1<br>
							$ B=9<br>
							$ B=$((A+=B))<br>
							$ echo ${A}<br>
							10<br>
							$ echo ${B}<br>
							10
						</font>
					</td>
					<td>
						<font class="bashcommand">B=$((A+=B))</font> is equivalent to this sequence of instructions:<br><br>

						<font class="bashcommand">
							A=$(( ${A} + ${B} ))<br>
							B=${A}
						</font>

						In this case, the value of <font class="bashcommand">B</font> is being modified because the result of 
						<font class="bashcommand">((A+=B))</font> is being assigned to it (opposite to the previous example).
					</td>
				</tr>	
				</table>
				
				<p>
					<font class="example">Usage of ((VAR-=NUM))</font>
					This expression is a compact way of writing: <font class="bashcommand">VAR=$(( ${VAR} - ${NUM} ))</font>
				</p>
				
				<table>
					<tr>
						<th><b>Compact expression</b></th>
						<th><b>Extended equivalent</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ ((A-=2))<br>
								$ echo ${A}<br>
								-1
							</font>
						</td>
						<td>
							<font class="bashcommand">((A-=2))</font> is equivalent to:<br><br>

							<font class="bashcommand">A=$(( ${A} - 2 ))</font>
						</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ B=$((A-=2))<br>
								$ echo ${A}<br>
								-1<br>
								$ echo ${B}<br>
								-1
							</font>
						</td>
						<td>
							<font class="bashcommand">B=$((A-=2))</font> is equivalent to this sequence of instructions:<br><br>

							<font class="bashcommand">
								A=$(( ${A} - 2 ))<br>
								B=${A}	
							</font>				
						</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ B=9<br>
								$ ((A-=B))<br>
								$ echo ${A}<br>
								-8<br>
								$ echo ${B}<br>
								9
							</font>
						</td>
						<td>
							<font class="bashcommand">((A-=B))</font> is equivalent to:<br><br>

							<font class="bashcommand">A=$(( ${A} - ${B} ))</font><br><br>
							
							The value of <font class="bashcommand">B</font> is not being modified.
						</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ B=9<br>
								$ B=$((A-=B))<br>
								$ echo ${A}<br>
								-8<br>
								$ echo ${B}<br>
								-8
							</font>
						</td>
						<td>
							<font class="bashcommand">B=$((A-=B))</font> is equivalent to this sequence of instructions:<br><br>

							<font class="bashcommand">
								A=$(( ${A} - ${B} ))<br>
								B=${A}<br><br>
							</font>
							
							In this case, the value of B is being modified because the result of 
							<font class="bashcommand">((A-=B))</font> is being assigned to it (opposite to the previous 
							example).
						</td>
					</tr>
				</table>
				
				<p>
				<font class="example">Usage of (( $i % 2 ))</font>
				<font class="bashcommand">
				$for i in $(seq 10)<br>
				>do<br>
				>if (( $i % 2 ))<br>
				>then<br>
				>echo $i is odd<br>
				>else<br>
				>echo $i is even<br>
				>fi<br>
				>done<br>
				1 is odd<br>
				2 is even<br>
				3 is odd<br>
				4 is even<br>
				5 is odd<br>
				6 is even<br>
				7 is odd<br>
				8 is even<br>
				9 is odd<br>
				10 is even
				</font>
				</p>
			</div>
			
			<h4><a href="#content4.2" onclick="showContent(4.2)">4.2. Non-integer calculations</a></h4>
			<div id="content4.2" class="hidden">
				<p>
				When programming in bash, you will often need to do mathematical operations that involve non-integer 
				calculations. To do this, you will need the <font class="bashcommand">bc</font> utility. You can use this 
				utility also for integer calculations, but it is normally left for advanced math.
				</p>
				
				<table>
					<tr>
						<th><b>Syntax</b></th>
						<th><b>Usage</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">echo "OPERATION" | bc</font>
						</td>
						<td>
							Evaluates <font class="bashcommand">OPERATION</font>. This can be any arithmetic operation with 
							integer or non-integer numbers. Including addition (<font class="bashcommand">+</font>), 
							subtraction (<font class="bashcommand">-</font>), multiplication 
							(<font class="bashcommand">*</font>), division (<font class="bashcommand">/</font>), square root 
							(<font class="bashcommand">sqrt(NUM)</font>), exponentiation 
							(<font class="bashcommand">NUM**EXP</font>), etc. It will round the result to the closest 
							integer.
						</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">echo "OPERATION" | bc -l</font>
						</td>
						<td>
							Flag <font class="bashcommand">-l</font> will not round the result. Instead, will print it with 
							all the decimals.
						</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">echo "scale=NDECIMALS; OPERATION" | bc -l</font>
						</td>
						<td>
							Will only print <font class="bashcommand">NDECIMALS</font> instead of all the decimals.
						</td>
					</tr>
				</table>
				
				<font class="example">echo "OPERATION" | bc</font>
				<p>
					<font class="bashcommand">
						$ echo "2.34 / 1.895" | bc<br>
						1<br>
						$ echo "2 / 3" | bc<br>
						0
					</font>
				</p>
				
				<font class="example">echo "OPERATION" | bc -l</font>
				<p>
					<font class="bashcommand">
						$ echo "2.34 / 1.895" | bc -l<br>
						1.23482849604221635883<br>
						$ echo "2 / 3" | bc -l<br>
						.66666666666666666666
					</font>
				</p>
				
				<p>
					<font class="bashcommand">
						$ A=$(echo "2.34 / 1.895" | bc)<br>
						$ B=$(echo "2.34 / 1.895" | bc -l)<br>
						$ echo ${A}<br>
						1<br>
						$ echo ${B}<br>
						1.23482849604221635883<br>
						$ echo "${A} + ${B}" | bc -l<br>
						2.23482849604221635883<br>
						$ echo "${A} + ${B}"<br>
						1 + 1.23482849604221635883
					</font>
				</p>
				
				<p>
					Look at the difference between the last two expressions. They are almost the same except for the 
					<font class="bashcommand">| bc -l</font> at the end of the first expression. Yet, the results are very 
					different. That is because in the second case we are just printing the text 
					<font class="bashcommand">"${A} + ${B}"</font>, while in the first one we are evaluating the expression 
					written in that text, with the use of the <font class="bashcommand">bc</font> utility. The following 
					example may clarify this concept:
				</p>
				
				<p>
					<font class="bashcommand">
						$ echo "${A} + ${B}=$(echo "${A} + ${B}" | bc -l)"<br>
						1 + 1.23482849604221635883=2.23482849604221635883
					</font>
				</p>
				
				<p>
					To find the square root of a number you use the expression <font class="bashcommand">sqrt()</font>, like 
					in many other programming languages.
				</p>
				
				<font class="example">finding the square root of 10 and saving it in variable A</font>
				<p>
					<font class="bashcommand">
						$ A=$(echo "sqrt (10)" | bc -l)<br>
						$ echo ${A}<br>
						3.16227766016837933199
					</font>
				</p>
				
				<p>
					Knowing this, you can do any type of operations with non-integer numbers. Just by writing the desired 
					expression between the quotation marks, or combine integer and non-integer calculations. Lets look at 
					a few more examples:
				</p>
				
				<font class="bashcommand">
					<p>
						$ echo "(2.34 / 1.895) + sqrt (10)" | bc -l<br>
						4.39710615621059569082<br>
						$ echo $((2**3))<br>
						12.397106156210595690828<br>
						$ echo "(2.34 / 1.895) + sqrt (10) + $((2**3))" | bc -l<br>
						12.39710615621059569082<br>
						$ echo "(2.34 / 1.895) + sqrt (10) + 2^3" | bc -l<br>
						12.39710615621059569082<br>
						$ echo "2 + 2" | bc -l<br>
						4<br>
						$ echo "2 + 2"<br>
						2 + 2<br>
						$ echo "2 + 2= $(echo "2 + 2" | bc -l)"<br>
						2 + 2= 4
					</p>	
						
					<p>
						$ A=$(echo "(2.34 / 1.895) + sqrt (10)" | bc -l)<br>
						$ echo ${A}<br>
						4.39710615621059569082<br>
						$ echo $(echo "(2.34 / 1.895) + sqrt (10)" | bc -l)<br>
						4.39710615621059569082<br>
						$ echo "(2.34 / 1.895) + sqrt (10)= $(echo "(2.34 / 1.895) + sqrt (10)" | bc -l)"<br>
						(2.34 / 1.895) + sqrt (10)= 4.39710615621059569082				
					</p>
				</font>
				
				<font class="example">echo "scale=NDECIMALS; OPERATION" | bc -l</font>
				<p>
					Clearly, some of the results of the previous examples have way too many decimals. You can cut the number 
					of decimals using scale.
				</p>
				
				<p>
					<font class="bashcommand">
						$ echo "(2.34 / 1.895) + sqrt (10)" | bc -l<br>
						4.39710615621059569082<br>
						$ echo "scale=3; (2.34 / 1.895) + sqrt (10)" | bc -l<br>
						4.396<br>
						$ echo "scale=0; (2.34 / 1.895) + sqrt (10)" | bc -l<br>
						4
					</font>
				</p>
				
				<font class="example">Comparing non-integers</font>
				<p>
					In order to compare non-integers you can use the <font class="bashcommand">awk</font> function. This 
					function will be studied more in detail in later chapters as it is mainly used for processing files and 
					strings. But as this example shows, it can also be used to deal with numbers.
				</p>
			</div>
		</div>
		
		<h3><a href="#content5" onclick="showContent(5);">5. Arrays</a></h3>
		<div id="content5" class="hidden">
			<h4><a href="#content5.1" onclick="showContent(5.1)">5.1. Declaring and assigning values</a></h4>
			<div id="content5.1" class="hidden">
				<p>
					An array is a data structure that stores a group of elements and allows you to access each element 
					individually or all elements sequentially. For example, you can have an array of subject IDs. The first 
					object in the array would be the ID of your first subject; the second object would be the ID of your 
					second subject, and so on. An analogy could be a To Do List. In that case, you would have an array of 
					things to do and you can ask yourself what is the first thing in your To-Do list, the second thing, or 
					the last thing, etc. There are different ways of creating an array, as well as different ways of adding 
					elements to it:
				</p>
				
				<table>
					<tr>
						<th><b>Syntax</b></th>
						<th><b>Usage</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">ARRAY[INDEX]=VAL</font>
						</td>
						<td>
							
						</td>
					</tr>
				</table>
			</div>
			
			<h4><a href="#content5.2" onclick="showContent(5.2)">5.2. Array operations</a></h4>
			<div id="content5.2" class="hidden">
				Content of section 5.2
			</div>
		</div>
		
		<h3><a href="#content6" onclick="showContent(6);">6. Condition-testing</a></h3>
		<div id="content6" class="hidden">
			<h4><a href="#content6.1" onclick="showContent(6.1)">6.1. Condition-testing to check files</a></h4>
			<div id="content6.1" class="hidden">
				Content of section 6.1
			</div>
			
			<h4><a href="#content6.2" onclick="showContent(6.2)">6.2. Condition-testing to compare/evaluate strings</a></h4>
			<div id="content6.2" class="hidden">
				Content of section 6.2
			</div>
			
			<h4><a href="#content6.3" onclick="showContent(6.3)">6.3. Condition-testing to compare numbers</a></h4>
			<div id="content6.3" class="hidden">
				Content of section 6.3
			</div>
			
			<h4><a href="#content6.4" onclick="showContent(6.4)">6.4. Condition-testing to compare arrays</a></h4>
			<div id="content6.4" class="hidden">
				Content of section 6.4
			</div>
		</div>
		
		<h3><a href="#content7" onclick="showContent(7);">7. Iteration</a></h3>
		<div id="content7" class="hidden">
			<h4><a href="#content7.1" onclick="showContent(7.1)">7.1. The for loop</a></h4>
			<div id="content7.1" class="hidden">
				Content of section 7.1
			</div>
			
			<h4><a href="#content7.2" onclick="showContent(7.2)">7.2. From for to while</a></h4>
			<div id="content7.2" class="hidden">
				Content of section 7.2
			</div>
			
			<h4><a href="#content7.3" onclick="showContent(7.3)">7.3. The while loop</a></h4>
			<div id="content7.3" class="hidden">
				Content of section 7.3
			</div>
		</div>
		
		<h3><a href="#content8" onclick="showContent(8);">8. General file manipulation</a></h3>
		<div id="content8" class="hidden">
			<h4><a href="#content8.1" onclick="showContent(8.1)">8.1. Basic concepts and simple commands</a></h4>
			<div id="content8.1" class="hidden">
				Content of section 8.1
			</div>
			
			<h4><a href="#content8.2" onclick="showContent(8.2)">8.2. Listing files using patterns</a></h4>
			<div id="content8.2" class="hidden">
				Content of section 8.2
			</div>
			
			<h4><a href="#content8.3" onclick="showContent(8.3)">8.3. Frequently used commands for file manipulation</a></h4>
			<div id="content8.3" class="hidden">
				Content of section 8.3
			</div>
			
			<h4><a href="#content8.4" onclick="showContent(8.4)">8.4. Writing files</a></h4>
			<div id="content8.4" class="hidden">
				Content of section 8.4
			</div>
			
			<h4><a href="#content8.5" onclick="showContent(8.5)">8.5. Reading files</a></h4>
			<div id="content8.5" class="hidden">
				Content of section 8.5
			</div>
		</div>
		
		<h3><a href="#content9" onclick="showContent(9);">9. The awk and grep commands for manipulating text and files</a></h3>
		<div id="content9" class="hidden">
			<h4><a href="#content9.1" onclick="showContent(9.1)">9.1. awk</a></h4>
			<div id="content9.1" class="hidden">
				Content of section 9.1
			</div>
			
			<h4><a href="#content9.2" onclick="showContent(9.2)">9.2. grep</a></h4>
			<div id="content9.2" class="hidden">
				Content of section 9.2
			</div>
		</div>
		</div>
		
		<h3><a href="#content10" onclick="showContent(10);">10. Manipulating image files</a></h3>
		<div id="content10" class="hidden">
			Content of section 10
		</div>
		
		<h3><a href="#content11" onclick="showContent(11);">11. Writing more complex bash scripts</a></h3>
		<div id="content11" class="hidden">
			<h4><a href="#content11.1" onclick="showContent(11.1)">11.1. Reading arguments</a></h4>
			<div id="content11.1" class="hidden">
				Content of section 11.1
			</div>
			
			<h4><a href="#content11.2" onclick="showContent(11.2)">11.2. Using functions</a></h4>
			<div id="content11.2" class="hidden">
				Content of section 11.2
			</div>
			
			<h4><a href="#content11.3" onclick="showContent(11.3)">11.3. Creating/importing libraries</a></h4>
			<div id="content11.3" class="hidden">
				Content of section 11.3
			</div>
			
			<h4><a href="#content11.4" onclick="showContent(11.4)">11.4. Scripting processes in parallel</a></h4>
			<div id="content11.4" class="hidden">
				Content of section 11.4
			</div>
		</div>
		
		<h3><a href="#content12" onclick="showContent(12);">12. Remote shell</a></h3>
		<div id="content12" class="hidden">
			Content of section 12
		</div>
		
		<h3><a href="#content13" onclick="showContent(13);">13. Cluster jobs</a></h3>
		<div id="content13" class="hidden">
			Content of section 13
		</div>
		
		<h3><a href="#content14" onclick="showContent(14);">14. Downloading files from the web using the command line</a></h3>
		<div id="content14" class="hidden">
			Content of section 14
		</div>
		
		<h3><a href="#content15" onclick="showContent(15);">15. Creating backups</a></h3>
		<div id="content15" class="hidden">
			Content of section 15
		</div>
		
		<h3><a href="#content16" onclick="showContent(16);">16. File permissions</a></h3>
		<div id="content16" class="hidden">
			Content of section 16
		</div>
		
		<h3><a href="#content17" onclick="showContent(17);">17. Using aliases</a></h3>
		<div id="content17" class="hidden">
			Content of section 17
		</div>
		
		<h3><a href="#content18" onclick="showContent(18);">18. keyboard shortcuts for MacOS</a></h3>
		<div id="content18" class="hidden">
			Content of section 18
		</div>
		
		<p>
			Last update: April 7 / 2020<br>
			All the content from this tutorial was originally created by the author<br>
			Author: <a href="linkedin.com/in/monicakeithmri" target="_blank">Monica Keith</a>
		</p>
	</body>
</html>
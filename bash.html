<!DOCTYPE html>
<html>
	<title>Bash Tutorial</title>

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Bash programming tutorial">
		<meta name="keywords" content="bash, tutorial">
		<meta name="author" content="Monica Keith">	
		
		<link rel="stylesheet" type="text/css" href="styles.css">
		<script src="functions.js"></script>
		<noscript>Sorry, your browser does not support JavaScript. This page needs to have JavaScript enabled.</noscript>
	</head>
	
	<body>
		<header>
		  <h2>Bash Tutorial</h2>
		</header>
		
		<section>
		  <nav>
		    <ul>
		     	<li><a onclick="showContent(1);">1. Introduction to shell scripting</a></li>
		      	<li><a onclick="showContent(2);">2. Creating simple bash scripts</a></li>
		      	<li><a onclick="showContent(3);">3. Variables</a></li>
		      	<li><a onclick="showContent(4);">4. Arithmetic calculations</a></li>
		      	<li><a onclick="showContent(5);">5. Arrays</a></li>
		      	<li><a onclick="showContent(6);">6. Condition-testing</a></li>
		      	<li><a onclick="showContent(7);">7. Iteration</a></li>
		      	<li><a onclick="showContent(8);">8. General file manipulation</a></li>
		      	<li><a onclick="showContent(9);">9. Manipulating text and csv files</a></li>
		      	<li><a onclick="showContent(10);">10. Manipulating image and video files</a></li>
		      	<li><a onclick="showContent(11);">11. Writing more complex bash scripts</a></li>
				<li><a onclick="showContent(12);">12. Remote shell</a></li>
				<li><a onclick="showContent(13);">13. Cluster jobs</a></li>
				<li><a onclick="showContent(14);">14. Downloading files from the web</a></li>
				<li><a onclick="showContent(15);">15. Creating backups</a></li>
				<li><a onclick="showContent(16);">16. File permissions</a></li>
				<li><a onclick="showContent(17);">17. Using aliases</a></li>
				<li><a onclick="showContent(18);">18. Keyboard shortcuts</a></li>
				<li><a onclick="showContent(19);">19. MySQL</a></li>
				<li><a onclick="showContent(20);">20. Report an error in the tutorial</a></li>
		    </ul>
		  </nav>
		  
		  <article>
		  	<div id="content1">
			    <h2>1. Introduction to shell scripting</h2>
			    	<h3>Shell (bash) scripting, its benefits and dangers (and how to protect from them)</h3>
					
					<p>
						Shell is a program that users employ to run commands for the operating system to execute. These can be very simple 
						instructions such as copying or moving files, or long scripts that contain hundreds of commands. Users typically 
						interact with a shell using a terminal window (also referred to as command line), which can be run from the same or 
						a remote machine. There are different types of shells, but I will refer in this tutorial only to the Bourne-Again shell, 
						which is the most commonly used. The Bourne-Again shell (or simply shell, as most people call it) is installed by 
						default in any Linux or MacOS. The programming language used to write commands and scripts in shell is called bash.
					</p>
		
					<p>
						The terminal window for Mac can be found inside the applications folder and in the subfolder Utilities. You can also 
						open it by pressing the command and space bar in your keyboard to open the spotlight and then type Terminal. 
						In Linux, the easiest way to open the terminal is to use the key combination Ctl + Alt + T.
					</p>
		
					<p>
						Shell scripting is very powerful; it allows you to run any instruction on your computer or a remote machine. Things 
						that normally would take hours to do could be executed in seconds. For example, if you have thousands of files 
						inside a folder, which need to be renamed following a pattern, it would take forever to rename those files by hand. 
						However, using the command line you could do it in seconds. When you write a shell script, you know exactly what and 
						how you did things, and you will be able to replicate those commands on different files, datasets or programs.
					</p>
		
					<p>			
						However, as powerful as scripting is, it is also very dangerous. Through the terminal you will have access to any 
						files or system resources if you have the right permissions, and the freedom to do anything with them. Inadvertent 
						"small" typing errors such as adding an extra space in the remove command (<font class="bashcommand">rm</font>) could delete everything in your 
						computer (including the root directory) or any external drive connected to your machine. Similarly, the contents of 
						any file could be mistakenly removed in less than a second. What makes it harder to prevent these errors is that 
						many commands differ in name by only one letter.
					</p>
		
					<p>
						Unfortunately, there is no way to completely protect your computer from potential mistakes that you may (and you 
						will at some point) do when writing and running shell scripts. However, there are a couple of tips that you can 
						follow in order to minimize the chances of making unfixable mistakes or to prevent any mistake from becoming a 
						catastrophe:
					</p>	
		
					<ol>
						<li>
							First and most importantly, create constant backups of either your entire drive or the most important folders. 
							Preferably save those backups in an external hard drive or remote machine, which won't be constantly connected 
							to your computer. It is not a bad idea to have more than one backup if your data is not easily recoverable.
						</li><br>
		
						<li>
							If you're using a shared computer or account, control access permissions to important files and folders. You can 
							control for each file and folder who and what can be done. By managing permissions, you can allow a file to be 
							read but not to be written (hence preventing it from being modified or deleted). Or you can authorize only a 
							user or group of users for viewing, reading, writing or executing a file. In chapter 12 you will learn how to 
							manage permissions.
						</li><br>
		
						<li>
							The root user is an account in any Linux or Unix operating system (i.e. MacOS) that has access to absolutely all 
							commands, files and directories. When you login as a root in the command line, you can modify, read and write 
							protected folders and files. This is very helpful when installing software or modifying the default settings of 
							your computer. However, coding as the root user can be extremely dangerous. It is very normal to make mistakes 
							when coding and if you have all permissions, you could mistakenly delete, move or modify files that should not 
							be touched. For this reason, it is advisable to only login as a root when strictly necessary and log out once 
							you're done. More information about the root user will be covered in chapter 12.
						</li><br>
		
						<li>
							Use aliases to protect from "dangerous" commands. Two of the most commonly used but dangerous commands are 
							<font class="bashcommand">rm</font> (to remove files) and <font class="bashcommand">mv</font> (to move files). 
							The <font class="bashcommand">mv</font> command can be as harmful as the <font class="bashcommand">rm</font> 
							command because if you specify the wrong target or source paths, you can end up deleting a big number of files. 
							When you use any of these two commands, always double check what you have written before clicking enter.
						</li><br>
		
						<li>
							Be careful when copy pasting commands from a website into the terminal. There can be errors that will be 
							executed right away if the text you're copying contains a carriage return at the end of the line. It is better 
							to paste into a shell script and then either execute the shell script or copy from the shell script into the 
							command line. Although generally not dangerous, you might also run into errors when copy pasting from Microsoft 
							word or other editors that modify symbols such as dash or underscore and convert them into new symbols that 
							bash won't understand.
						</li>
		
					</ol>
		    </div>
		    
		    <div id="content2" class="hidden">
			    <h2>2. Creating simple bash scripts</h2>
			    <h3>2.1. The vi editor</h3>
				    <p>
						There are an unlimited number of editors available for writing shell scripts in Linux and Mac. A few are 
						installed by default; some are used through the terminal and some others use a graphical interface (GUI). 
						They all have pros and cons and the decision to use one or another is totally personal. In this section I will 
						explain how to use the editor vi, which is installed by default in both Linux and MacOS and can be accessed and 
						used through the terminal window. 
					</p>
					
					These are some of the advantages of vi:
					<ul>
						<li>
							It is available in all Unix systems and any type of terminal.
						</li>
						
						<li>
							It doesn't require a lot of memory to run. So, if you are running many heavy programs in your computer, 
							vi is a good option because it won't slow down the machine anymore and will still load very fast.
						</li>
						
						<li>
							Even though there are a lot of commands that you must learn to become skilled in using this program, once 
							you learn them you can use very short and fast commands to accomplish a lot of things. For example, you 
							can delete all the characters from your current cursor location to the end of the line, just by pressing two 
							times the d in your keyboard (while in command mode). Below you will find a chart with the most commonly used 
							shortcuts in vi.
						</li>
						
						<li>
							You can use it to code in different languages (i.e. it also works for Python, HTML, etc.).
						</li>
						
						<li>
							Some editors add special characters to the text and when you run scripts written in those editors, they could
							fail. vi doesn't add any special characters, and if it did, they are visible in the editor.
						</li>
						
						<li>
							If you don't like using your mouse too much, or you don't have a mouse, or your mouse doesn't work 
							properly, then vi editor is a good choice because you rarely need to use the mouse. Most things are 
							accomplished using the keyboard.
						</li>
					</ul>
					
					However, there are some disadvantages too:
					<ul>
						<li>
							The learning curve can be steep, especially for people who are new to programming and not very comfortable 
							with computers. If you're new to bash, you not only need to learn the language, but also a whole set of 
							commands specific to this program. 
						</li>
						
						<li>
							Not being able to use your mouse can end up wasting your time while you learn all the commands that are used 
							to scroll around the file or jump from one line to another.
						</li>
						
						<li>
							It doesn't give you any error messages or explanation of why it's not doing what you want. If you type the 
							wrong command, it will just do nothing (or do the wrong thing).
						</li>
					</ul>
					
					<p>
						Generally, many people with relatively good experience programming love this editor. In my opinion, it's a good 
						tool to use once you are familiar with shell and have been programming for a while. However, it might be a great 
						option for you if you like challenges or if you are already somehow familiar with shell.
					</p>
					
					<p>
						To create a new file, type (on the command line) 
						<font class="bashcommand">vi &lt;filePath&gt;/&lt;filename&gt;</font>. For example, if you want to create a file 
						called test.sh in the desktop, you should type <font class="bashcommand">vi ~/Desktop/test.sh</font>. The vi 
						editor will open in the current terminal.
					</p>
					
					<p>
						This program runs in two modes, the command mode and the typing mode. By default, it opens in command mode. 
						What this means is that anything you type is not actually being registered in the file but are commands. For 
						example, if you type <font class="bashcommand">:q!</font> as soon as you open the file, it will quit without 
						saving (because <font class="bashcommand">:q!</font> is the command for ignoring any modifications and exiting. 
						If you type <font class="bashcommand">:w</font> it will save changes to the file (or if you haven't write 
						anything, it will just create an empty file). To change to typing mode, type <font class="bashcommand">a</font> 
						(<font class="bashcommand">a</font> is the command for entering typing mode). After you type a (in lower case), 
						you can start editing your file. To go back to command mode (for example to save changes), press the key 
						<font class="bashcommand">esc</font> (top left corner of the keyboard).
					</p>
					
					<p>
						<font class="example">Using the vi editor for the first time</font>
						Open the vi editor, create a script that prints "Hello Word", and save it with the file name helloword.sh
					</p>
					
					<p>
						Step 1: Open the vi editor<br><br>
						<img src="vi_1.png"/>
					</p>
					
					<p>
						Step 2: Type <font class="bashcommand">a</font> to start editing the file. You will see that an 
						<b>--Insert--</b> message in the bottom of the terminal appears. This means that now you are in typing mode.<br><br>
						<img src="vi_2.png"/>
					</p>
					
					<p>
						Step 3: Start typing commands. The simplest command, to print a message such as 
						<font class="bashcommand">"Hello World"</font> (or any other) is <font class="bashcommand">echo</font>. The 
						syntax of this command is the word <font class="bashcommand">echo</font> followed by the message you want to 
						print out between quotation marks (in this case <font class="bashcommand">"Hello World!"</font>).<br><br>
						<img src="vi_3.png"/>
					</p>
					
					<p>
						Step 4: Once you finish your script, press the <font class="bashcommand">esc</font> key to enter command mode. 
						You will see that the <b>--Insert--</b> message at the bottom of the terminal disappears (this means that now 
						you are in command mode).<br><br>
						<img src="vi_4.png"/>
					</p>
					
					<p>
						Step 5: Save changes and exit the vi editor. In order to do this, type <font class="bashcommand">:wq</font> 
						(to write (<font class="bashcommand">w</font>) and quit (<font class="bashcommand">q</font>) at the same time). 
						The table below will show you the most commonly used commands for vi.<br><br>
						<img src="vi_5.png"/>
					</p>
					
					<p>
						Step 6: To be able to execute the script, you will have to give it running permissions. The topic of 
						permissions is a lot more complicated, so I will not go into details now (I will talk about it later). For now, 
						all you need to know is that to give running permissions to your script you have to type 
						<font class="bashcommand">chmod 775 helloword.sh</font><br><br>
						<img src="vi_6.png"/>
					</p>
					
					<p>
						The following table shows a list of vi commands that can be used in command mode and the action that will 
						happen in each case. In general, a number preceding any vi command will tell vi to repeat the command that 
						number of times. For example, <font class="bashcommand">p</font> is the command for pasting. If you write 
						(in command mode) <font class="bashcommand">2p</font>, then vi will paste whatever you copied two times where 
						the cursor is currently located.
					</p>
					
					<table>
						<caption>List of vi commands</caption>
						<tr>
							<th style="width:30%"><b>Key/command</b></th>
							<th style="width:70%"><b>Action</b></th>
						</tr>
						<tr>
							<td><font class="bashcommand">[ESC]</font></td>
							<td>Switch to command mode</td>
						</tr>
						<tr>
							<td><font class="bashcommand">[ctrl] b</font></td>
							<td>Scroll backward one screen</td>
						</tr>
						<tr>
							<td><font class="bashcommand">[ctrl] d</font></td>
							<td>Scroll down half screen</td>
						</tr>
						<tr>
							<td><font class="bashcommand">[ctrl] f</font></td>
							<td>Scroll forward one screen</td>
						</tr>
						<tr>
							<td><font class="bashcommand">[ctrl] u</font></td>
							<td>Scroll up half screen</td>
						</tr>
						<tr>
							<td><font class="bashcommand">.</font></td>
							<td>Repeat last command</td>
						</tr>
						<tr>
							<td><font class="bashcommand">$</font></td>
							<td>Go to end of line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">? string</font></td>
							<td>Search backward for <font class="bashcommand">string</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">/ string</font></td>
							<td>Search forward for string</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:0</font></td>
							<td>Go to beginning of line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N</font></td>
							<td>Go to line <font class="bashcommand">N</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N,Md</font></td>
							<td>Delete lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N,MmP</font></td>
							<td>Move lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font> and paste them after line <font class="bashcommand">P</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N,MtP</font></td>
							<td>Copy lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font> and paste them after line <font class="bashcommand">P</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N,Mw file</font></td>
							<td>Save lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font> to file</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:q</font></td>
							<td>Quit (does not save any changes)</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:q!</font></td>
							<td>Ignore any modifications made and quit</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:%s/old/new/option</font></td>
							<td>
							Searches and replaces the string <font class="bashcommand">old</font> by the string 
							<font class="bashcommand">new</font> in the entire file<br>
							The following letters can be added in the field <font class="bashcommand">option</font>:<br>
							<font class="bashcommand">c</font> to prompt for confirmation<br>
							<font class="bashcommand">g</font> to replace all the occurrences of the string
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:s/old/new/option</font></td>
							<td>
							Searches and replaces the string <font class="bashcommand">old</font> by the string 
							<font class="bashcommand">new</font> in the line in which the cursor is located</br>
							The following letters can be added in the field <font class="bashcommand">option</font>:</br>
							<font class="bashcommand">c</font> to prompt for confirmation<br>
							<font class="bashcommand">g</font> to replace all the occurrences of the string
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:set ignorecase</font></td>
							<td>Ignore case sensitivity during search</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:set noignorecase</font></td>
							<td>Restore case sensitivity during search</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:set number</font></td>
							<td>Turn on line numbering</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:set nonumber</font></td>
							<td>Turn off line numbering</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:syntax on</font></td>
							<td>Turn on syntax colors in the text</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:syntax off</font></td>
							<td>Turn off syntax colors in the text</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:w</font></td>
							<td>Save changes</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:w file</font></td>
							<td>Save changes to file</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:wq</font></td>
							<td>Save changes and quit</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:x</font></td>
							<td>Save changes and quit</td>
						</tr>
						<tr>
							<td><font class="bashcommand">a</font></td>
							<td>Switch to editing mode and continue writing where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">A</font></td>
							<td>Switch to editing mode and continue writing at the end of the line where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">i</font></td>
							<td>Switch to editing mode and continue writing where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">I</font></td>
							<td>Switch to editing mode and continue writing at the beginning of the line where the cursor is
							located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">cw</font></td>
							<td>Delete the rest of the word in which the cursor is located (keeps the characters located before the 
							cursor)</td>
						</tr>
						<tr>
							<td><font class="bashcommand">D</font></td>
							<td>Delete the rest of the line in which the cursor is located (keeps the characters and words located 
							before the cursor)</td>
						</tr>
						<tr>
							<td><font class="bashcommand">dd</font></td>
							<td>Delete the entire line where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">dw</font></td>
							<td>Delete the whole word in which the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">J</font></td>
							<td>Put the next line at the end of the line where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">o</font></td>
							<td>Open line below cursor</td>
						</tr>
						<tr>
							<td><font class="bashcommand">O</font></td>
							<td>Open line above cursor</td>
						</tr>
						<tr>
							<td><font class="bashcommand">p</font></td>
							<td>Paste below current line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">P</font></td>
							<td>Paste above current line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:u</font></td>
							<td>Undo previous command</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:U</font></td>
							<td>Undo all changes to line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">x</font></td>
							<td>Delete text at cursor</td>
						</tr>
						<tr>
							<td><font class="bashcommand">X</font></td>
							<td>Delete (backspace) text at cursor</td>
						</tr>
						<tr>
							<td><font class="bashcommand">yy</font></td>
							<td>Copy line in which the cursor is located</td>
						</tr>
					</table>
				
				<h3>2.2. Other editors</h3>	
					<p>
						As I previously mentioned, there is an unlimited number of editors and the choice of which to use is totally 
						personal. The following editors are available for both Linux and MacOS: vim, emacs, gedit (which is also 
						installed by default in Linux and uses a GUI, great for beginners), and Eclipse (among many others). Eclipse 
						is a lot more than an editor; it is a development environment used for programming in many other languages 
						(mainly Java) and for software development and modeling. The following are editors available only for MacOS: 
						Xcode, TextWrangler, TextMate, Notepad++, and Atom (among many others).
					</p>
					
				<h3>2.3. Tips for writing scripts</h3>
					<ol>
						<li>
						Albeit not mandatory, the first line of any bash script should be the shebang 
						(<font class="bashcommand">#!/bin/bash</font>). This line indicates that the script is written in bash 
						(instead of tcsh, for example) and that the bash interpreter should execute it.<br><br>
						</li>
						
						<li>
						Be organized when writing scripts. As you start writing longer and more complicated programs, this 
						will become more important. Try to comment as often as possible so that other people can understand what 
						your script is doing, which parameters are needed and what they mean or to understand the output. 
						Commenting will also help you fix errors or keep track of the version, changes, authorship, etc, or to 
						remember what your script does if you don't use it for a while. To insert a comment, you simply start the 
						line with a hash (<font class="bashcommand">#</font>). Any line that starts with this symbol will not be 
						executed (except for the shebang). Also try to use indentation to know where pieces of code start and end 
						(for example when doing loops). If you don't indentate, understanding your own code will be very 
						difficult. Part of being organized is also using appropriate variable names. Use names that are associated 
						to the structure you're using (for example, if you're creating an array, naming it 
						<font class="bashcommand">array</font> will help you remember that this variable is an array and not a 
						string or a number) and try to use short names (for example, instead of naming a variable 
						<font class="bashcommand">myListOfSubjects</font>, you can call it 
						<font class="bashcommand">subjList</font>).</br><br>
						</li>
						
						<li>
						It is also a good idea to use the following commands at the beginning of any script:</br>
						<font class="bashcommand">set -e</font>: This will make the program exit as soon as it encounters an error. 
						If you don't use this, then even if there's an error your code will continue to execute.<br> 
						<font class="bashcommand">set -u</font>: This will make the program exit when using undeclared variables. 
						It will prevent the program from executing the wrong commands if you misspell a variable name.<br><br>
						</li>
						
						<li>
						Use double quotes (<font class="bashcommand">"</font>) when declaring a string, single quotes 
						(<font class="bashcommand">'</font>) when declaring a character, and no quotes when declaring numbers. 
						This will prevent word splitting (when declaring a string that has spaces) and other errors in your 
						code.<br><br>
						</li>
						
						<li>
						Use functions. This topic will be covered in chapter X. Using functions will make your code more readable, 
						reusable, and will allow you to run only parts of the code without having to comment all the lines. This 
						is especially useful when debugging or re-running a script.<br><br>
						</li>
						
						<li>
						If you are declaring a variable that the value should never change, then use the word 
						<font class="bashcommand">readonly</font> before the variable name.<br> 
						For example, if I want to declare a variable called <font class="bashcommand">age</font> with value 
						<font class="bashcommand">30</font> and this value should never be replaced, then you should declare it 
						like this:<br>
						<font class="bashcommand">$ readonly age=30</font><br>
						Instead of:<br>
						<font class="bashcommand">$ age=30</font><br><br>
						
						If at some point in the script you try to replace the value of that variable, you will get an error message:
						<br>
						<font class="bashcommand">$ readonly age=30</font><br>
						<font class="bashcommand">$ age=29</font><br>
						<font class="bashcommand bashcommand-result">-bash: age: readonly variable</font>
						</li>
					</ol>
				
				<h2>2.4. Running a script</h2>
					<p>
						Running a shell script is easy. You only type the path and name of the file in the command line and then press 
						enter. For example, if your script is located in the Desktop and is called helloWord.sh, then to execute it 
						you should type the following in the command line:<br>
						<font class="bashcommand">$ ~/Desktop/helloWord.sh</font><br><br>
						If you get a Permission Denied error, this means that you must change its permissions to make it runnable. 
						The topic of permissions is a bit complicated and will be explained in detail in chapter 12. But for now, you 
						only need to know that the following command will allow you to execute the script if it's not runnable:<br>
						<font class="bashcommand">$ chmod 775 &lt;script_path_and_name&gt;</font>
					</p>
		    </div>
		    
		    <div id="content3" class="hidden">
		    	<h2>3. Variables</h2>
		    	<h3>3.1. Utility, declaration and accessing variables</h3>
		    		<p>
						A very important aspect of programming (in bash or any other language) is the ability to use a label (called 
						variable) to indicate some other quantity (a number, character, string or command). For example, I can use 
						the variable <font class="bashcommand">${desktop}</font> to represent the string 
						<font class="bashcommand">"/Users/monica/Desktop"</font>. Or the variable 
						<font class="bashcommand">${year}</font> to represent the number <font class="bashcommand">2020</font> 
						(after correctly declaring these variables). Variables can be used for many purposes, including making the 
						code more readable, short and organized and to prevent typing errors. They are also very useful in cases in 
						which the actual value of a variable is not known before executing the program, or when you need to save the 
						output of one command to use as input for another command. For example, when reading the contents of a file 
						you can read line by line in an iterative manner (which you will learn later), saving each line in a variable 
						and then doing something with it (depending the purpose of the program). 
					</p>
					
					<p>
						The easy thing about declaring variables in bash is that you don't have to specify data types. However, if 
						the value that you are assigning is a string of characters, you should use quotation marks 
						(<font class="bashcommand">"</font>) between the beginning and the end of your string (especially if the 
						string contains spaces). You must also be careful to not include any white space between the variable name, 
						the equals sign, and the value. Additionally, be aware that the quotation marks used in bash are 
						<font class="bashcommand">"</font>, which is different than those used in Microsoft Word. They look very 
						similar, but bash won't recognize the later ones. So, if you copy-paste from Microsoft Word a command that
						includes quotation marks, you will probably get an error.
					</p>
					
					<p>
						<font class="example">Declaring variables of different data types</font>
						In the following commands, I will assign a number to the variable <font class="bashcommand">YEAR</font>, a String 
						to the variables <font class="bashcommand">MONTH</font> and <font class="bashcommand">NAME</font> and a character to 
						the variable <font class="bashcommand">GENDER</font>. As you can observe, numbers, strings and characters should 
						be declared in a different manner.
					</p>
					
					<p>
						<font class="bashcommand">
						$ YEAR=2018<br>
						$ MONTH="August"<br>
						$ NAME="Monica Keith"<br>
						$ GENDER='F'
						</font>
					</p>
					
					<p>
						<font class="example">Common mistakes when declaring variables</font>
						The following commands will produce errors because there is a white space before and/or after the equal sign 
						(<font class="bashcommand">=</font>), or because the quotation marks (<font class="bashcommand">"</font>) are 
						missing when declaring a string that contains a space. Bellow each erroneous command you can see the error 
						that Bash produces.
					</p>
					
					<p>
						<font class="bashcommand">
						$ NAME ="Monica Keith"<br>
						<font class="bashcommand-result">-bash: NAME: command not found</font><br>
						$ NAME= "Monica Keith"<br>
						<font class="bashcommand-result">-bash: Monica Keith: command not found</font><br>
						$ NAME = "Monica Keith"<br>
						<font class="bashcommand-result">-bash: NAME: command not found</font><br>
						$ NAME=Monica Keith<br>
						<font class="bashcommand-result">-bash: Keith: command not found</font>
						</font>
					</p>
					
					<p>
						Once you assign a value to a variable, you can reference it with a dollar sign, located immediately before 
						the variable name. You can also reference a variable by including curly brackets 
						(<font class="bashcommand">{}</font>) at the beginning and the end of the variable name. It is better (but 
						not mandatory) to always reference variables using brackets. This will prevent errors in your code (specially 
						when referencing strings that have spaces or special characters).
					</p>
					
					<p>
						<font class="example">Referencing variables</font>
						In the following example, I will declare variable <font class="bashcommand">VAR1</font> with value 
						<font class="bashcommand">2</font>, and variable <font class="bashcommand">VAR2</font> with value 
						<font class="bashcommand">"Subject"</font>. Then, I will use the function 
						<font class="bashcommand">echo</font> to print in the command line the value of the two variables.
					</p>
					
					<p>
						<font class="bashcommand">
						$ VAR1=2<br>
						$ VAR2="Subject"<br>
						$ echo ${VAR1}<br>
						<font class="bashcommand-result">2</font><br>
						$ echo ${VAR2}<br>
						<font class="bashcommand-result">Subject</font>
						</font>
					</p>
					
					<p>
						<font class="example">Common mistakes when referencing variables</font>
						When referencing a variable, be careful not to include any space before or after the brackets. The following 
						examples will produce an error because of the inclusion of a space around the brackets:
					</p>
					
					<p>
						<font class="bashcommand">
						$ echo ${ VAR2}<br>
						<font class="bashcommand-result">-bash: ${ VAR2}: bad substitution</font><br>
						$ echo ${VAR2 }<br>
						<font class="bashcommand-result">-bash: ${VAR2 }: bad substitution</font><br>
						$ echo ${ VAR2 }<br>
						<font class="bashcommand-result">-bash: ${ VAR2 }: bad substitution</font>
						</font>
					</p>
					
					<p>
						The following erroneous reference (with a space between the dollar sign and the first bracket) will not cause 
						an error but will not substitute <font class="bashcommand">${VAR2}</font> for the correct value. It will just 
						print <font class="bashcommand">$ {VAR2}</font> instead of <font class="bashcommand">Subject</font>.
					</p>
					
					<p>
						<font class="bashcommand">
						$ echo $ {VAR2}<br>
						$ {VAR2}
						</font>
					</p>
					
					<p>
						<font class="example">Concatenating variables</font>
						You can concatenate different variables and characters to form new strings. To do this, you will need to 
						reference the variables using the curly brackets and use quotation marks at the beginning and the end of your 
						final string. For example, if you want to use the previously declared variables 
						<font class="bashcommand">VAR1</font> and <font class="bashcommand">VAR2</font> to generate the String 
						<font class="bashcommand">Subject_02</font>, you can concatenate them the following way:
					</p>
					
					<p>
						<font class="bashcommand">
						$ echo ${VAR2}<br>
						<font class="bashcommand-result">Subject</font><br>
						$ echo ${VAR1}<br>
						<font class="bashcommand-result">2</font><br>
						$ echo "${VAR2}_0${VAR1}"<br>
						<font class="bashcommand-result">Subject_02</font>
						</font>
					</p>
					
					<p>Here are a few more examples on how to declare and concatenate variables:</p>
					
					<p>
						<font class="bashcommand">
						$ ID="Subject_202"<br>
						$ VOLUME=20<br>
						$ MEASURE="mm"<br>
						$ echo "${ID}: ${VOLUME}${MEASURE}"<br>
						<font class="bashcommand-result">Subject_202: 20mm</font>
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
						$ VAR1="MacOS"<br>
						$ VAR2="Linux"<br>
						$ VAR3="Windows"<br>
						$ echo "(${VAR1},${VAR2},${VAR3})"<br>
						<font class="bashcommand-result">(MacOS,Linux,Windows)</font>
						</font>
					</p>
					
					<p>
						<font class="example">A common mistake when concatenating variables</font>
						It is very common when you are referencing many variables or concatenating variables to create a long string 
						to forget the closing quotation mark. For example, writing<br>
						<font class="bashcommand">$ echo "(${VAR1},${VAR2},${VAR3})</font><br>
						instead of<br>
						<font class="bashcommand">$ echo "(${VAR1},${VAR2},${VAR3})"</font>
					</p>
					
					<p>
						When that happens and you click enter in the keyboard, the command line won't allow you to enter any more 
						commands. You will see the symbol <font class="bashcommand">></font> and if you continue pressing enter it 
						will do nothing. This is because the command line is waiting for you to close the open String. To close the 
						string just add the missing quotation mark or cancel and ignore what you have written so far in the current 
						line by pressing CTR+C. 
					</p>
					
				<h3>3.2. Rules for assigning variable names</h3>
					<p>You can assign any value to a variable. However, a variable cannot have just any name. There are a few 
					rules for assigning variable names.</p>
					
					<ol>
						<li>
							A variable name should not be a number.<br>
							This type of variable is only used to read arguments on a shell script. For example, 
							<font class="bashcommand">$1</font> refers to the first argument of a script, 
							<font class="bashcommand">$2</font> to the second argument, etc. Later you will learn the meaning and use 
							of script arguments.
						</li><br>
						
						<li>
							Variable names must start with an alphabetical letter or an underscore.<br>
							Variable names can contain any number, but it should not be located at the beginning.
						</li><br>
						
						<li>
							Do not use <font class="bashcommand">$</font> or <font class="bashcommand">${}</font> to declare a 
							variable. These characters are used only to reference variables (not to declare).
						</li><br>
						
						<li>
							Do <u>NOT</u> assign the name <font class="bashcommand">PATH</font> to any variable.<br>
							If you do so, you won't get any error right away. But it will mess up the execution of other programs. 
							<font class="bashcommand">PATH</font> is a system variable that specifies a set of directories where 
							executable programs are located. For example, when you install a software that runs in the command line 
							(i.e. FSL), the path to the executable of that program will be included in the system variable 
							<font class="bashcommand">PATH</font>. So, if you rename that variable, you won't be able to execute the 
							program again in the current terminal. If you forget about this rule and mistakenly re-write the value 
							of this variable, close the current terminal and open a new one. Every time you open a new terminal, 
							this system variable will be re-set to the correct value (which is stored in the bash_profile, we will 
							talk about this file in a later chapter). At any moment you can know the value of your 
							<font class="bashcommand">PATH</font> by typing <font class="bashcommand">echo ${PATH}</font>. You will 
							see something like this (although this will significantly varies between one computer and the other 
							depending which programs you have installed and referenced in the bash_profile):<br><br>
							
							<font class="bashcommand">
							$ echo ${PATH}<br>
							<font class="bashcommand-result">/usr/local/fsl/bin:/Applications/freesurfer/bin:/Applications/freesurfer/fsfast/bin:/Applications/freesurfer/tktools:/usr/local/fsl/bin:/Applications/freesurfer/mni/bin:/Users/bunbury/bin:/Applications/MATLAB_R2018a.app/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin</font>
							</font><br><br>
							
							Another Unix reserved name that you should not use is <font class="bashcommand">BASH</font>. There is a long list 
							of Unix reserved words that I will not include here but you will learn as you get more experienced.
						</li><br>
						
						<li>
							Avoid using the following reserved characters from appearing in variable names:
							<font class="bashcommand">/ &gt; &lt; | : &amp; . *</font>	
						</li><br><br>
						
						<font class="example">Some valid and invalid variable names</font><br>
						<table>
							<caption>Valid and invalid variable names</caption>
							<tr>
								<th style="width:50%"><b>Valid variable names</b></th>
								<th style="width:50%"><b>Invalid variable names</b></th>
							</tr>
							<tr>
								<td>V</td>
								<td>1</td>
							</tr>
							<tr>
								<td>VAR</td>
								<td>1VAR</td>
							</tr>
							<tr>
								<td>VAR1</td>
								<td>2_VAR</td>
							</tr>
							<tr>
								<td>VAR_1</td>
								<td>.VAR</td>
							</tr>
							<tr>
								<td>_VAR1</td>
								<td>$VAR</td>
							</tr>
							<tr>
								<td>_1VAR</td>
								<td>${VAR}</td>
							</tr>
							<tr>
								<td>VARIABLE_NAME</td>
								<td>{VAR}</td>
							</tr>
							<tr>
								<td>PATH1</td>
								<td>PATH</td>
							</tr>
							<tr>
								<td>BASH1</td>
								<td>BASH</td>
							</tr>
						</table>
						
						<p>
							Variable names can be in lower and/or upper case. However, they are case sensitive. If you declare a 
							variable as <font class="bashcommand">VAR1</font>, but you reference it as 
							<font class="bashcommand">${var1}</font>, bash will not recognize the value. You must reference it as 
							<font class="bashcommand">${VAR1}</font>.
						</p>
					</ol>
					
				<h3>3.3. Reading user input into a variable</h3>
					<p>
						The command <font class="bashcommand">read</font> is the counterpart of <font class="bashcommand">echo</font>. 
						Instead of printing things in the terminal the way <font class="bashcommand">echo</font> does, 
						<font class="bashcommand">read</font> reads input from the user and saves it in the specified variable (in 
						this case <font class="bashcommand">VAR</font>). The word read is followed by the name of the variable where 
						you want to save the information. In the following example, I am going to read the input from the user and 
						save it in the variable <font class="bashcommand">VAR</font>. Generally, Bash will read everything that is 
						written until the user presses the Enter key and save all the information in the corresponding variable.
					</p>
					
					<p>
						<font class="example">Saving user input into a new variable</font>
						<font class="bashcommand">
						$ echo "Username:"<br>
						<font class="bashcommand-result">Username:</font><br>
						$ read VAR<br>
						<font class="bashcommand-result">Noemi</font><br>
						$ echo "You typed: ${VAR}"<br>
						<font class="bashcommand-result">You typed: Noemi</font>
						</font>
					</p>
					
					<p>
						There are some flags (options) that can be added to the command read to change the way in which information is 
						displayed or captured:
					</p>
					
					<table>
						<caption>Options for reading user input</caption>
						<tr>
							<th style="width:30%"><b>Flag</b></th>
							<th style="width:70%"><b>Usage</b></th>
						</tr>
						<tr>
							<td><font class="bashcommand">-s</font></td>
							<td>
							Silent mode. The characters that the user inputs are not displayed (used specially when asking the user to 
							input a password).
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-p "MESSAGE"</font></td>
							<td>
								Displays the <font class="bashcommand">MESSAGE</font> where the user must write the input.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-n NUM_CHARS</font></td>
							<td>
							The input line ends after reading <font class="bashcommand">NUM_CHARS</font> characters, rather than waiting for the 
							user to press Enter in the keyboard.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-d 'CHAR_NEW_LINE'</font></td>
							<td>
							<font class="bashcommand">CHAR_NEW_LINE</font> is used to determine the end of the input line (if different than Enter).
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-r</font></td>
							<td>
								Backslash does not act as an escape character but instead is part of the line.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-t NSECONDS</font></td>
							<td>
							Bash will stop reading the user input after <font class="bashcommand">NSECONDS</font>. Whatever was entered in that 
							time is captured as the input line.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-a ARRAY_NAME</font></td>
							<td>
							The words that the user inputs are assigned to sequential indices of the array 
							<font class="bashcommand">ARRAY_NAME</font>. The array is emptied before assigning the values if it 
							already exists.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-u FILEDESCRIPTOR</font></td>
							<td>
							Read input from <font class="bashcommand">FILEDESCRIPTOR</font>.
							</td>
						</tr>
					</table>
					
					<p>
						The following examples will show how to use the flags mentioned in the previous table. Be aware on how the 
						variable name is always written at the end of the command. In this section, I will not explain the use of 
						flags <font class="bashcommand">-a</font> and <font class="bashcommand">-u</font> because we haven't learned 
						yet about arrays or file manipulation. Some of the examples will also show common mistakes that will make bash 
						show an error.
					</p>
					
					<p>
						<font class="example">read -s</font>
						In the following example, the flag <font class="bashcommand">-s</font> causes the user input to be silenced, 
						so when the user writes the password, it is not shown in the screen. If the user input is 
						<font class="bashcommand">ThisIsMyPassword</font>, then that string is saved in the variable 
						<font class="bashcommand">PASSWORD</font>. While the user is writing its password and until it presses Enter, 
						you will see the following symbol underneath <font class="bashcommand">$ read -s PASSWORD </font>:
						<img src="pwd.png"/>. Afterwards, the symbol will disappear.
					</p>
					
					<p>
						In the example of a wrong syntax, the mistake is that the variable <font class="bashcommand">PASSWORD</font> 
						is written before the flag <font class="bashcommand">-s</font>. The variable must go at the end of the command 
						independently of which flags are used. As a result, bash is not silencing the user input, is giving the invalid 
						identifier error, and is not saving any string in the variable.
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
								$ read -s PASSWORD<br>
								<img src="pwd.png"/><br>
								$ echo ${PASSWORD}</br>
								<font class="bashcommand-result">ThisIsMyPassword</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
								$ read PASSWORD -s<br>
								ThisIsMyPassword<br>
								<font class="bashcommand-result">-bash: read: `-s': not a valid identifier</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">read -p</font>
						The flag <font class="bashcommand">-p</font> is useful if you want to prompt a message so that the user 
						knows what the input should be. The examples in the following table combine the flags 
						<font class="bashcommand">-p</font> and <font class="bashcommand">-s</font> to indicate the user to input a 
						password and hide the password while its being typed. The prompt message should go right after the flag 
						<font class="bashcommand">-p</font>.
					</p>
					
					<p>
						The following table shows some examples of commands written using a wrong syntax (as well as the correct way 
						to write them). In the first example, the error is that the prompt message is not located right after the flag 
						<font class="bashcommand">-p</font> (instead, it is located after the flag <font class="bashcommand">-s</font>). 
						In the second example, the error is that the variable <font class="bashcommand">PASSWORD</font> is not located 
						at the end of the command. In the third example, the problem is that the prompt message 
						(<font class="bashcommand">Please input your password</font>) is not surrounded by quotation marks. So, for 
						bash only the first word of that sentence (<font class="bashcommand">Please</font>) is the prompt message, and 
						the next word (<font class="bashcommand">input</font>) is read as the variable name. The rest of the command 
						(<font class="bashcommand">your password</font>) is ignored. That is why when reading 
						<font class="bashcommand">${PASSWORD}</font>, nothing is echoed, the variable is empty because nothing was 
						saved with that variable name. Instead, the input was saved in <font class="bashcommand">${input}</font>. This 
						is the reason why the prompt message should always be surrounded by quotation marks.
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -p "Please input your password" -s PASSWORD<br>
									<font class="bashcommand-result">Please input your password</font> <img src="pwd.png"/><br>
									$ echo ${PASSWORD}<br> 
									<font class="bashcommand-result">ThisIsMyPassword</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read -p -s "Please input your password" PASSWORD<br>
									<font class="bashcommand-result">-s</font><br>
									<font class="bashcommand-result">-bash: read: `Please input your password': not a valid identifier</font>
								</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -p "Please input your password" -s PASSWORD<br>
									<font class="bashcommand-result">Please input your password</font> <img src="pwd.png"/><br>
									$ echo ${PASSWORD}<br> 
									<font class="bashcommand-result">ThisIsMyPassword</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read PASSWORD -s -p "Please input your password"<br>
									ThisIsMyPassword<br>
									<font class="bashcommand-result">-bash: read: `-s': not a valid identifier</font>
								</font>
							</td>
						</tr>
						<tr>
							<td>
							</td>
							<td>
								<font class="bashcommand">
									$ read -s -p Please input your password<br>
									ThisIsMyPassword<br>
									$ echo $PASSWORD<br>
									<br>
									$ echo ${input}<br>
									<font class="bashcommand-result">ThisIsMyPassword</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">read -n</font>
						In the following example, <font class="bashcommand">-n 1</font> forces bash to accept only one character in the 
						input. So, the terminal will finish reading after one character. Here we are combining flags 
						<font class="bashcommand">-n</font> and <font class="bashcommand">-p</font> to also prompt a message to the 
						user.
					</p>
					
					<p>
						In the wrong syntax, <font class="bashcommand">1</font> (the number of characters to be accepted) and the 
						prompt message are located in the wrong place. The number of characters accepted should always go after 
						<font class="bashcommand">-n</font> and the prompt message should always go after 
						<font class="bashcommand">-p</font>. 
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -n 1 -p "Do you wish to continue? (y/n)" VAR<br>
									<font class="bashcommand-result">Do you wish to continue? (y/n)y</font><br>
									$ echo $VAR<br>
									<font class="bashcommand-result">y</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read -n -p 1 "Do you wish to continue? (y/n)" VAR<br>
									<font class="bashcommand-result">-bash: read: -p: invalid number</font>
								</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -p "Do you wish to continue? (y/n)" -n 1 VAR<br>
									<font class="bashcommand-result">Do you wish to continue? (y/n)y</font><br>
									$ echo $VAR<br>
									<font class="bashcommand-result">y</font>					
								</font>
							</td>
							<td>
								<font class="bashcommand">
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">read -d</font>
						In the following example the end of the line is determined by the character <font class="bashcommand">#</font> 
						instead of Enter (using the flag <font class="bashcommand">-d</font>). As soon as the user types 
						<font class="bashcommand">#</font>, bash finishes reading and saves the input in the variable 
						<font class="bashcommand">VAR</font>.
					</p>
					
					<p>
						In the wrong syntax, the command is missing the apostrophes (<font class="bashcommand">'</font>) around the 
						character <font class="bashcommand">#</font>.
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -d '#' VAR<br>
									$ echo $VAR<br>
									<font class="bashcommand-result">SomeText</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read -d # VAR<br>
									<font class="bashcommand-result">-bash: read: -d: option requires an argument</font><br>
									<font class="bashcommand-result">read: usage: read [-ers] [-u fd] [-t timeout] [-p prompt] [-a array] [-n nchars] [-d delim] [name ...]</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">The backslash</font>
						In bash, certain characters have special meanings. For example, the dollar sign 
						(<font class="bashcommand">$</font>) is used to reference a variable. When you type 
						<font class="bashcommand">${VAR}</font>, it will print the value of 
						<font class="bashcommand">VAR</font> instead of the actual string 
						"<font class="bashcommand">${VAR}</font>". The backslash (<font class="bashcommand">\</font>) is used to remove 
						those special meanings from the character followed by it. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ VAR="Some text"<br>
							$ echo ${VAR}<br>
							<font class="bashcommand-result">Some text</font><br>
							$ echo \${VAR}<br>
							${VAR}
						</font>
					</p>
					
					<p>
						When using the flag <font class="bashcommand">-r</font>, the backslash is part of the line instead of being 
						used as an escape character. The following table shows examples in which the user inputs the same string but it 
						is read differently because in one case the flag is used (first column) but not in the other (second column).
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Examples using flag -r</b></th>
							<th style="width:50%"><b>Examples without the flag -r</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -r VAR<br>
									<font class="bashcommand-result">C:\Documents\Newsletters\Summer2018.pdf</font><br>
									$ echo ${VAR}<br>
									<font class="bashcommand-result">C:\Documents\Newsletters\Summer2018.pdf</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read VAR<br>
									<font class="bashcommand-result">C:\Documents\Newsletters\Summer2018.pdf</font><br>
									$ echo ${VAR}<br>
									<font class="bashcommand-result">C:DocumentsNewslettersSummer2018.pdf</font>
									</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -r MESSAGE<br>
									<font class="bashcommand-result">In HTML \n is used to indicate a new line</font><br>
									$ echo ${MESSAGE}<br>
									<font class="bashcommand-result">In HTML \n is used to indicate a new line</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read MESSAGE<br>
									<font class="bashcommand-result">In HTML \n is used to indicate a new line</font><br>
									$ echo ${MESSAGE}<br>
									<font class="bashcommand-result">In HTML n is used to indicate a new line</font>
								</font>
							</td>
						</tr>
					</table>
				
				<h3>3.4. Using &lt;&lt;&lt; to get input from a different source</h3>
					<p>
						So far, we have used the command <font class="bashcommand">read</font> to save the user input into a variable. 
						This command can also be used to read from other sources (i.e. other variables or files).
					</p>
					
					<p>
						<font class="example">Reading content from a variable</font>
						In the following example, <font class="bashcommand">read</font> reads the content of the variable 
						<font class="bashcommand">VAR</font>, but only keeps the first character (because it is using the 
						<font class="bashcommand">-n 1</font> flag):
					</p>
					
					<p>
						<font class="bashcommand">
						$ VAR=yes<br>
						$ read -n 1 R &lt;&lt;&lt; ${VAR}<br>
						$ echo ${R}<br>
						<font class="bashcommand-result">y</font>
						</font>
					</p>
					
					<p>
						<font class="example">Reading and saving the output of a function</font>	
						<font class="bashcommand">read</font> also allows you to read the output of a function and save it in a variable. 
						In this example, we are saving the output of the <font class="bashcommand">pwd</font> function into the variable 
						<font class="bashcommand">CURRENT_DIR</font>. <font class="bashcommand">pwd</font> is a function that prints the 
						current folder in which you are located in the command line. 
					</p>
					
					<p>
						<font class="bashcommand">
						$ pwd<br>
						<font class="bashcommand-result">/Users/myUserName</font><br>
						$ read CURRENT_DIR &lt;&lt;&lt; $(pwd)<br>
						$ echo ${CURRENT_DIR}<br>
						<font class="bashcommand-result">/Users/myUserName</font>
						</font>
					</p>
					
					<p>
						<font class="example">**Example specific for people doing neuroimaging**</font>
						<b>WARNING:</b> If you have never analyzed MRI brain images, the following paragraph might sound like written in 
						extraterrestrial language, and it probably will not work in your computer since you need neuroimaging software
						to execute it.
					</p>
					
					<p>	
						In this example, we are reading the output of a function and saving it in the variable 
						<font class="bashcommand">VOL</font>. The output of this function (<font class="bashcommand">fslstats -V</font>) 
						consists of two values separated by a space. The first value is the volume of a region of interest (ROI) from 
						an MRI file in number of voxels, and the second value is the volume in mm<sup>3</sup>. Because we are using the 
						flag <font class="bashcommand">-d ' '</font>, it will read only until the first space (which is the character 
						we are choosing to indicate the end of line). So, bash will save in the variable 
						<font class="bashcommand">VOL</font> only the volume in number of voxels and not in mm<sup>3</sup>. 
					</p>
					
					<p>
						<font class="bashcommand">
						$ fslstats /Users/myUserName/Desktop/MRI/subject001/LGN_L.nii.gz -V<br>
						<font class="bashcommand-result">196 186.920166</font><br>
						$ read -d ' ' VOL &lt;&lt;&lt; $(fslstats /Users/myUserName/Desktop/MRI/subject001/LGN_L.nii.gz -V)<br>
						$ echo $VOL<br>
						<font class="bashcommand-result">196</font>
						</font>
					</p>					
		    </div>
		    
		    <div id="content4" class="hidden">
		    	<h2>4. Arithmetic calculations</h2>
		    	<h3>4.1. Integer calculations</h3>
			    	<p>In order to compute arithmetic calculations with integers you can use one of the following syntaxes:</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Syntax</b></th>
							<th style="width:70%"><b>Usage</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">$(( OPERATION ))</font>
							</td>
							<td>
								Evaluates <font class="bashcommand">OPERATION</font>. This can be any arithmetic operation with 
								integer numbers. Including addition (<font class="bashcommand">+</font>), subtraction 
								(<font class="bashcommand">-</font>), multiplication (<font class="bashcommand">*</font>), division 
								(<font class="bashcommand">&#247;</font>), square root (<font class="bashcommand">sqrt(NUM)</font>), 
								exponentiation (<font class="bashcommand">NUM**EXP</font>), etc.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((++NUM))</font>
							</td>
							<td>
								Increases variable <font class="bashcommand">NUM</font> in 1 <u>before</u> evaluating any expression that 
								contains <font class="bashcommand">++NUM</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((NUM++))</font>
							</td>
							<td>
								Increases variable <font class="bashcommand">NUM</font> in 1 <u>after</u> evaluating any expression 
								that contains <font class="bashcommand">NUM++</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((--NUM))</font>
							</td>
							<td>
								Decreases variable <font class="bashcommand">NUM</font> in 1 <u>before</u> evaluating any expression 
								that contains <font class="bashcommand">--NUM</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((NUM--))</font>
							</td>
							<td>
								Decreases variable <font class="bashcommand">NUM</font> in 1 <u>after</u> evaluating any expression 
								that contains <font class="bashcommand">NUM--</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((VAR+=NUM))</font>
							</td>
							<td>
								Increases variable <font class="bashcommand">VAR</font> in <font class="bashcommand">NUM</font>. 
								Equivalent to <font class="bashcommand">VAR=$(( $VAR + $NUM ))</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((VAR-=NUM))</font>
							</td>
							<td>
								Decreases variable <font class="bashcommand">VAR</font> in <font class="bashcommand">NUM</font>. 
								Equivalent to <font class="bashcommand">VAR=$(( $VAR - $NUM ))</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">(( $i % 2 ))</font>
							</td>
							<td>
								<font class="bashcommand">true</font> if <font class="bashcommand">i</font> is an odd number, 
								<font class="bashcommand">false</font> if <font class="bashcommand">i</font> is even.
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">Usage of $(( OPERATION ))</font>
					</p>
					
					<table>
					<tr>
						<th style="width:30%"><b>Example</b></th>
						<th style="width:70%"><b>Explanation</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ echo $(( 2 + 1 ))<br>
								<font class="bashcommand-result">3</font>
							</font>
						</td>
						<td>2 + 1</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
							$ A=2<br>
							$ echo $(( ${A} + 1 ))<br>
							<font class="bashcommand-result">3</font>
							</font>
						</td>
						<td>A + 1</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( ${A} + ${B} ))<br>
								<font class="bashcommand-result">3</font>
							</font>
						</td>
						<td>A + B</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( ${A} - ${B} ))<br>
								<font class="bashcommand-result">1</font>
							</font>
						</td>
						<td>A - B</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( ${A} * ${B} ))<br>
								<font class="bashcommand-result">2</font>
							</font>
						</td>
						<td>A x B</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( ${A} / ${B} ))<br>
								<font class="bashcommand-result">2</font>
							</font>
						</td>
						<td>A &#247; B</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( $(( ${A} + ${B} )) * $(( ${A} - ${B} )) ))<br>
								<font class="bashcommand-result">3</font>
							</font>
						</td>
						<td>(A + B) x (A - B)</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( ${B} / ${A} ))<br>
								<font class="bashcommand-result">0</font>
							</font>
						</td>
						<td>
							B &#247; A<br>
							The result is zero because this syntax is used for integer numbers. So, if the result of the operation 
							is not an integer, it will be rounded to the nearest integer. In the following section you will learn 
							how to operate with non-integer numbers. 
						</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ echo $(( ${A} ** 3 ))<br>
								<font class="bashcommand-result">8</font>
							</font>
						</td>
						<td>A<sup>3</sup></td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=4<br>
								$ echo $(( ${A} ** ${B} ))<br>
								<font class="bashcommand-result">16</font>
							</font>
						</td>
						<td>A<sup>B</sup></td>
					</tr>
					</table>
					
					<p>
						<font class="example">Usage of ((++NUM)) and ((NUM++))</font>
						In order to increment the value of a variable by one, there are a couple of options. Some of these options will be 
						very useful when doing iterations (which you will learn later on).
					</p>
					
					<table>
					<tr>
						<th style="width:33%"><b>${NUM} + 1</b></th>
						<th style="width:34%"><b>((++NUM))</b></th>
						<th style="width:33%"><b>((NUM++))</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
							$ NUM=1<br>
							$ echo $(( ${NUM} + 1 ))<br>
							<font class="bashcommand-result">2</font><br>
							$ echo ${NUM}<br>
							<font class="bashcommand-result">1</font><br><br>
							</font>
								
							The command echo <font class="bashcommand">$(( ${NUM} + 1 ))</font> prints the result of 
							<font class="bashcommand">NUM</font> plus one, but it does not modify the value of 
							<font class="bashcommand">NUM</font>. For that reason, when <font class="bashcommand">NUM</font> is 
							echoed at the end, it still has value 1 (instead of 2).
						</td>
						<td>
							<font class="bashcommand">
								$ NUM=1<br>
								$ echo $((++NUM))<br>
								<font class="bashcommand-result">2</font><br>
								$ echo ${NUM}<br>
								<font class="bashcommand-result">2</font><br><br>
							</font>
							
							The command <font class="bashcommand">echo $((++NUM))</font> is equivalent to this sequence of 
							instructions:<br><br>
							
							<font class="bashcommand">
								$ NUM=$(( ${NUM} + 1 ))<br>
								$ echo ${NUM}<br><br>
							</font>
							
							First, increases the value of variable <font class="bashcommand">NUM</font> in one, and then it echoes 
							the result. Opposite to the example in the left, here the variable value is actually modified. And 
							opposite to the example in the right, the variable value is modified before the other instruction 
							(<font class="bashcommand">echo</font>).
						</td>
						<td>
							<font class="bashcommand">
								$ NUM=1<br>
								$ echo $((NUM++))<br>
								<font class="bashcommand-result">1</font><br>
								$ echo ${NUM}<br>
								<font class="bashcommand-result">2</font><br><br>
							</font>
							
							The command echo <font class="bashcommand">$((NUM++))</font> is equivalent to this sequence of 
							instructions:<br><br>
							
							<font class="bashcommand">
								$ echo ${NUM}<br>
								$ NUM=$(( ${NUM} + 1 ))<br><br>
							</font>
							
							First echoes the value of <font class="bashcommand">NUM</font>. Then, it increases the value of the 
							variable. 
						</td>		
					</tr>
					</table><br>
					
					<table>
					<tr>
						<th style="width:33%"><b>${NUM} + 1</b></th>
						<th style="width:34%"><b>((++NUM))</b></th>
						<th style="width:33%"><b>((NUM++))</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ NUM=1<br>
								$ A=$(( ${NUM} + 1 ))<br>
								$ echo ${A}<br>
								<font class="bashcommand-result">2</font><br>
								$ echo ${NUM}<br
								<font class="bashcommand-result">1</font><br><br>
							</font>
							
							The command <font class="bashcommand">A=$(( ${NUM} + 1 ))</font> assigns to 
							<font class="bashcommand">A</font> the value of <font class="bashcommand">NUM</font> plus one, but it 
							does not modify the value of <font class="bashcommand">NUM</font>.
						</td>
						<td>
							<font class="bashcommand">
								$ NUM=1<br>
								$ A=$((++NUM))<br>
								$ echo ${A}<br>
								<font class="bashcommand-result">2</font><br>
								$ echo ${NUM}<br>
								<font class="bashcommand-result">2</font><br><br>
							</font>
							
							The command <font class="bashcommand">A=$((++NUM))</font> is equivalent to this sequence of 
							instructions:<br><br>
							
							<font class="bashcommand">
								$ NUM=$(( ${NUM} + 1 ))<br>
								$ A=${NUM}<br><br>
							</font>
							
							First increases the value of variable <font class="bashcommand">NUM</font> in one, and then it assigns 
							the new value to <font class="bashcommand">A</font>. So, after the operation both variables 
							(<font class="bashcommand">A</font> and <font class="bashcommand">NUM</font>) will have value 2.
						</td>
						<td>
							<font class="bashcommand">
								$ NUM=1<br>
								$ A=$((NUM++))<br>
								$ echo ${A}<br>
								<font class="bashcommand-result">1</font><br>
								$ echo ${NUM}<br>
								<font class="bashcommand-result">2</font><br><br>
							</font>
							
							The command <font class="bashcommand">A=$((NUM++))</font> is equivalent to this sequence of 
							instructions:<br><br>
							
							<font class="bashcommand">
								$ A=${NUM}<br>
								$ NUM=$(( ${NUM} + 1 ))<br><br>
							</font>
							
							First assigns the value of <font class="bashcommand">NUM</font> to the new variable <font class="bashcommand">A</font>. 
							After that, it increases the value of <font class="bashcommand">NUM</font>. So, if the initial value of 
							<font class="bashcommand">NUM</font> was 1, after the operation <font class="bashcommand">A</font> will equal 1 and 
							<font class="bashcommand">NUM</font> will equal 2.
						</td>
					</tr>
					</table>
					
					<p>
						<font class="example">Usage of ((--NUM)) and ((NUM--))</font>
						Expressions <font class="bashcommand">((--NUM))</font> and <font class="bashcommand">((NUM--))</font> work in 
						a very similar way than the previous ones, but instead of increasing the value of
						 <font class="bashcommand">NUM</font> by one, they decrease the value of <font class="bashcommand">NUM</font> 
						 by one. These expressions will also be very useful once you learn iteration. 
					</p>
					
					<table>
						<tr>
							<th style="width:33%"><b>${NUM} - 1</b></th>
							<th style="width:34%"><b>((--NUM))</b></th>
							<th style="width:33%"><b>((NUM--))</b></th>
						</tr>
						<tr>
							<td>
							<font class="bashcommand">
								$ NUM=1<br>
								$ echo $(( ${NUM} - 1 ))<br>
								<font class="bashcommand-result">0</font><br>
								$ echo ${NUM}<br>
								<font class="bashcommand-result">1</font><br><br>		
							</font>
		
							The command echo <font class="bashcommand">$(( ${NUM} - 1 ))</font> prints the result of 
							<font class="bashcommand">NUM</font> minus one, but it does not modify the value of 
							<font class="bashcommand">NUM</font>. For that reason, when <font class="bashcommand">NUM</font> is echoed 
							at the end, it still has value 1 (instead of 0).
							</td>
							
							<td>
							<font class="bashcommand">
								$ NUM=1<br>
								$ echo $((--NUM))<br>
								<font class="bashcommand-result">0</font><br>
								$ echo ${NUM}<br>
								<font class="bashcommand-result">0</font><br><br>
							</font>
		
							The command echo <font class="bashcommand">$((--NUM))</font> is equivalent to this sequence of instructions:<br><br>
		
							<font class="bashcommand">
								$ NUM=$(( ${NUM} - 1 ))<br>
								$ echo ${NUM}<br><br>
							</font>
		
							First, decreases the value of variable <font class="bashcommand">$NUM</font> in one, and then it echoes the 
							result. Opposite to the example in the left, here the variable value is actually modified. And opposite to 
							the example in the right, the variable value is modified before the other instruction 
							(<font class="bashcommand">=</font>).
							</td>
							
							<td>
								<font class="bashcommand">
									$ NUM=1<br>
									$ echo $((NUM--))<br>
									<font class="bashcommand-result">1</font><br>
									$ echo ${NUM}<br>
									<font class="bashcommand-result">0</font><br><br>
								</font>
			
								The command echo <font class="bashcommand">$((NUM--))</font> is equivalent to this sequence of 
								instructions:<br><br>
			
								<font class="bashcommand">
									$ echo ${NUM}<br>
									$ NUM=$(( ${NUM} - 1 ))<br><br>
								</font>
			
								First, echoes the value of <font class="bashcommand">NUM</font>. Then, it decreases the value of the 
								variable. 
							</td>
						</tr>
					</table><br>
					
					<table>
						<tr>
							<th style="width:33%"><b>${NUM} - 1</b></th>
							<th style="width:34%"><b>((--NUM))</b></th>
							<th style="width:33%"><b>((NUM--))</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ NUM=1<br>
									$ A=$(( ${NUM} - 1 ))<br>
									$ echo ${A}<br>
									<font class="bashcommand-result">0</font><br>
									$ echo ${NUM}<br>
									<font class="bashcommand-result">1</font><br><br>
								</font>
								
								The command <font class="bashcommand">A=$(( ${NUM} - 1 ))</font> assigns to 
								<font class="bashcommand">A</font> the value of <font class="bashcommand">NUM</font> minus one, but it 
								does not modify the value of <font class="bashcommand">NUM</font>.
							</td>
							<td>
								<font class="bashcommand">
									$ NUM=1<br>
									$ A=$((--NUM))<br>
									$ echo ${A}<br>
									<font class="bashcommand-result">0</font><br>
									$ echo ${NUM}<br>
									<font class="bashcommand-result">0</font><br><br>
								</font>
								
								The command <font class="bashcommand">A=$((--NUM))</font> is equivalent to this sequence of 
								instructions:<br><br>
								
								<font class="bashcommand">
									$ NUM=$(( ${NUM} - 1 ))<br>
									$ A=${NUM}<br><br>
								</font>			
								
								First, decreases the value of variable <font class="bashcommand">NUM</font> in one, and then it assigns 
								the new value to <font class="bashcommand">A</font>. So, after the operation both variables 
								(<font class="bashcommand">A</font> and <font class="bashcommand">NUM</font>) will have value 0.			
							</td>
							<td>
								<font class="bashcommand">
									$ NUM=1<br>
									$ A=$((NUM--))<br>
									$ echo ${A}<br>
									<font class="bashcommand-result">1</font><br>
									$ echo ${NUM}<br>
									<font class="bashcommand-result">0</font><br><br>
								</font>
								
								The command <font class="bashcommand">A=$((NUM--))</font> is equivalent to this sequence of 
								instructions:<br><br>
								
								<font class="bashcommand">
									$ A=${NUM}<br>
									$ NUM=$(( ${NUM} - 1 ))<br><br>
								</font>
								
								First, assigns the value of <font class="bashcommand">NUM</font> to the new variable 
								<font class="bashcommand">A</font>. After that, it increases the value of 
								<font class="bashcommand">NUM</font>. So, if the initial value of <font class="bashcommand">NUM</font> was 
								1, after the operation <font class="bashcommand">A</font> will equal 1 and 
								<font class="bashcommand">NUM</font> will equal 2.
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">Usage of ((VAR+=NUM))</font>
						This expression is a compact way of writing <font class="bashcommand">VAR=$(( ${VAR} + ${NUM} ))</font>
					</p>
					
					<table>
					<tr>
						<th style="width:30%"><b>Compact expression</b></th>
						<th style="width:70%"><b>Extended equivalent</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ ((A+=2))<br>
								$ echo ${A}<br>
								<font class="bashcommand-result">3</font><br><br>
							</font>				
						</td>
						<td>
							<font class="bashcommand">((A+=2))</font> is equivalent to:<br><br>
		
							<font class="bashcommand">A=$(( ${A} + 2 ))</font>
						</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ B=$((A+=2))<br>
								$ echo ${A}<br>
								<font class="bashcommand-result">3</font><br>
								$ echo ${B}<br>
								<font class="bashcommand-result">3</font><br>
							</font>
						</td>
						<td>
							<font class="bashcommand">B=$((A+=2))</font> is equivalent to this sequence of instructions:<br><br>
		
							<font class="bashcommand">
								$ A=$(( ${A} + 2 ))<br>
								$ B=${A}
							</font>
						</td>
					</tr>		
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ B=9<br>
								$ ((A+=B))<br>
								$ echo ${A}<br>
								<font class="bashcommand-result">10</font><br>
								$ echo ${B}<br>
								<font class="bashcommand-result">9</font>
							</font>					
						</td>
						<td>
							<font class="bashcommand">((A+=B))</font> is equivalent to:<br><br>
		
							<font class="bashcommand">$ A=$(( ${A} + ${B} ))</font><br><br>
		
							The value of <font class="bashcommand">B</font> is not being modified.
						</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ B=9<br>
								$ B=$((A+=B))<br>
								$ echo ${A}<br>
								<font class="bashcommand-result">10</font><br>
								$ echo ${B}<br>
								<font class="bashcommand-result">10</font>
							</font>
						</td>
						<td>
							<font class="bashcommand">B=$((A+=B))</font> is equivalent to this sequence of instructions:<br><br>
	
							<font class="bashcommand">
								$ A=$(( ${A} + ${B} ))<br>
								$ B=${A}<br><br>
							</font>
	
							In this case, the value of <font class="bashcommand">B</font> is being modified because the result of 
							<font class="bashcommand">((A+=B))</font> is being assigned to it (opposite to the previous example).
						</td>
					</tr>	
					</table>
					
					<p>
						<font class="example">Usage of ((VAR-=NUM))</font>
						This expression is a compact way of writing: <font class="bashcommand">VAR=$(( ${VAR} - ${NUM} ))</font>
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Compact expression</b></th>
							<th style="width:70%"><b>Extended equivalent</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ A=1<br>
									$ ((A-=2))<br>
									$ echo ${A}<br>
									<font class="bashcommand-result">-1</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">((A-=2))</font> is equivalent to:<br><br>
	
								<font class="bashcommand">A=$(( ${A} - 2 ))</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ A=1<br>
									$ B=$((A-=2))<br>
									$ echo ${A}<br>
									<font class="bashcommand-result">-1</font><br>
									$ echo ${B}<br>
									<font class="bashcommand-result">-1</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">B=$((A-=2))</font> is equivalent to this sequence of instructions:<br><br>
	
								<font class="bashcommand">
									$ A=$(( ${A} - 2 ))<br>
									$ B=${A}	
								</font>				
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ A=1<br>
									$ B=9<br>
									$ ((A-=B))<br>
									$ echo ${A}<br>
									<font class="bashcommand-result">-8</font><br>
									$ echo ${B}<br>
									<font class="bashcommand-result">9</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">((A-=B))</font> is equivalent to:<br><br>
	
								<font class="bashcommand">$ A=$(( ${A} - ${B} ))</font><br><br>
								
								The value of <font class="bashcommand">B</font> is not being modified.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ A=1<br>
									$ B=9<br>
									$ B=$((A-=B))<br>
									$ echo ${A}<br>
									<font class="bashcommand-result">-8</font><br>
									$ echo ${B}<br>
									<font class="bashcommand-result">-8</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">B=$((A-=B))</font> is equivalent to this sequence of instructions:<br><br>
	
								<font class="bashcommand">
									$ A=$(( ${A} - ${B} ))<br>
									$ B=${A}<br><br>
								</font>
								
								In this case, the value of B is being modified because the result of 
								<font class="bashcommand">((A-=B))</font> is being assigned to it (opposite to the previous 
								example).
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">Usage of (( $i % 2 ))</font>
						<font class="bashcommand">
							$for i in $(seq 10)<br>
							&gt; do<br>
							&gt; if (( $i % 2 ))<br>
							&gt; then<br>
							&gt; echo $i is odd<br>
							&gt; else<br>
							&gt; echo $i is even<br>
							&gt; fi<br>
							&gt; done<br>
							<font class="bashcommand-result">
							1 is odd<br>
							2 is even<br>
							3 is odd<br>
							4 is even<br>
							5 is odd<br>
							6 is even<br>
							7 is odd<br>
							8 is even<br>
							9 is odd<br>
							10 is even
							</font>
						</font>
					</p>
					
				<h3>4.2. Non-integer calculations</h3>
					<p>
						When programming in bash, you will often need to do mathematical operations that involve non-integer 
						calculations. To do this, you will need the <font class="bashcommand">bc</font> utility. You can use this 
						utility also for integer calculations, but it is normally left for advanced math.
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Syntax</b></th>
							<th style="width:70%"><b>Usage</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">echo "OPERATION" | bc</font>
							</td>
							<td>
								Evaluates <font class="bashcommand">OPERATION</font>. This can be any arithmetic operation with 
								integer or non-integer numbers. Including addition (<font class="bashcommand">+</font>), 
								subtraction (<font class="bashcommand">-</font>), multiplication 
								(<font class="bashcommand">*</font>), division (<font class="bashcommand">/</font>), square root 
								(<font class="bashcommand">sqrt(NUM)</font>), exponentiation 
								(<font class="bashcommand">NUM**EXP</font>), etc. It will round the result to the closest 
								integer.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">echo "OPERATION" | bc -l</font>
							</td>
							<td>
								Flag <font class="bashcommand">-l</font> will not round the result. Instead, will print it with 
								all the decimals.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">echo "scale=NDECIMALS; OPERATION" | bc -l</font>
							</td>
							<td>
								Will only print <font class="bashcommand">NDECIMALS</font> instead of all the decimals.
							</td>
						</tr>
					</table><br>
					
					<font class="example">echo "OPERATION" | bc</font>
					<p>
						<font class="bashcommand">
							$ echo "2.34 / 1.895" | bc<br>
							<font class="bashcommand-result">1</font><br>
							$ echo "2 / 3" | bc<br>
							<font class="bashcommand-result">0</font>
						</font>
					</p>
					
					<font class="example">echo "OPERATION" | bc -l</font>
					<p>
						<font class="bashcommand">
							$ echo "2.34 / 1.895" | bc -l<br>
							<font class="bashcommand-result">1.23482849604221635883</font><br>
							$ echo "2 / 3" | bc -l<br>
							<font class="bashcommand-result">.66666666666666666666</font>
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ A=$(echo "2.34 / 1.895" | bc)<br>
							$ B=$(echo "2.34 / 1.895" | bc -l)<br>
							$ echo ${A}<br>
							<font class="bashcommand-result">1</font><br>
							$ echo ${B}<br>
							<font class="bashcommand-result">1.23482849604221635883</font><br>
							$ echo "${A} + ${B}" | bc -l<br>
							<font class="bashcommand-result">2.23482849604221635883</font><br>
							$ echo "${A} + ${B}"<br>
							<font class="bashcommand-result">1 + 1.23482849604221635883</font>
						</font>
					</p>
					
					<p>
						Look at the difference between the last two expressions. They are almost the same except for the 
						<font class="bashcommand">| bc -l</font> at the end of the first expression. Yet, the results are very 
						different. That is because in the second case we are just printing the text 
						<font class="bashcommand">"${A} + ${B}"</font>, while in the first one we are evaluating the expression 
						written in that text, with the use of the <font class="bashcommand">bc</font> utility. The following 
						example may clarify this concept:
					</p>
					
					<p>
						<font class="bashcommand">
							$ echo "${A} + ${B}=$(echo "${A} + ${B}" | bc -l)"<br>
							<font class="bashcommand-result">1 + 1.23482849604221635883=2.23482849604221635883</font>
						</font>
					</p>
					
					<p>
						To find the square root of a number you use the expression <font class="bashcommand">sqrt()</font>, like 
						in many other programming languages.
					</p>
					
					<font class="example">finding the square root of 10 and saving it in variable A</font>
					<p>
						<font class="bashcommand">
							$ A=$(echo "sqrt (10)" | bc -l)<br>
							$ echo ${A}<br>
							<font class="bashcommand-result">3.16227766016837933199</font>
						</font>
					</p>
					
					<p>
						Knowing this, you can do any type of operations with non-integer numbers. Just by writing the desired 
						expression between the quotation marks, or combine integer and non-integer calculations. Lets look at 
						a few more examples:
					</p>
					
					<font class="bashcommand">
						<p>
							$ echo "(2.34 / 1.895) + sqrt (10)" | bc -l<br>
							<font class="bashcommand-result">4.39710615621059569082</font><br>
							$ echo $((2**3))<br>
							<font class="bashcommand-result">12.397106156210595690828</font><br>
							$ echo "(2.34 / 1.895) + sqrt (10) + $((2**3))" | bc -l<br>
							<font class="bashcommand-result">12.39710615621059569082</font><br>
							$ echo "(2.34 / 1.895) + sqrt (10) + 2^3" | bc -l<br>
							<font class="bashcommand-result">12.39710615621059569082</font><br>
							$ echo "2 + 2" | bc -l<br>
							<font class="bashcommand-result">4</font><br>
							$ echo "2 + 2"<br>
							<font class="bashcommand-result">2 + 2</font><br>
							$ echo "2 + 2 = $(echo "2 + 2" | bc -l)"<br>
							<font class="bashcommand-result">2 + 2 = 4</font>
						</p>	
							
						<p>
							$ A=$(echo "(2.34 / 1.895) + sqrt (10)" | bc -l)<br>
							$ echo ${A}<br>
							<font class="bashcommand-result">4.39710615621059569082</font><br>
							$ echo $(echo "(2.34 / 1.895) + sqrt (10)" | bc -l)<br>
							<font class="bashcommand-result">4.39710615621059569082</font><br>
							$ echo "(2.34 / 1.895) + sqrt (10)= $(echo "(2.34 / 1.895) + sqrt (10)" | bc -l)"<br>
							<font class="bashcommand-result">(2.34 / 1.895) + sqrt (10)= 4.39710615621059569082</font>				
						</p>
					</font>
					
					<font class="example">echo "scale=NDECIMALS; OPERATION" | bc -l</font>
					<p>
						Clearly, some of the results of the previous examples have way too many decimals. You can cut the number 
						of decimals using scale.
					</p>
					
					<p>
						<font class="bashcommand">
							$ echo "(2.34 / 1.895) + sqrt (10)" | bc -l<br>
							<font class="bashcommand-result">4.39710615621059569082</font><br>
							$ echo "scale=3; (2.34 / 1.895) + sqrt (10)" | bc -l<br>
							<font class="bashcommand-result">4.396</font><br>
							$ echo "scale=0; (2.34 / 1.895) + sqrt (10)" | bc -l<br>
							<font class="bashcommand-result">4</font>
						</font>
					</p>
					
					<font class="example">Comparing non-integers</font>
					<p>
						In order to compare non-integers you can use the <font class="bashcommand">awk</font> function. This 
						function will be studied more in detail in later chapters as it is mainly used for processing files and 
						strings. But as this example shows, it can also be used to deal with numbers.
					</p>
		    </div>
		    
		    <div id="content5" class="hidden">
		    	<h2>5. Arrays</h2>
		    	<h3>5.1. Declaring and assigning values</h3>
			    	<p>
						An array is a data structure that stores a group of elements and allows you to access each element 
						individually or all elements sequentially. For example, you can have an array of subject IDs. The first 
						object in the array would be the ID of your first subject; the second object would be the ID of your 
						second subject, and so on. An analogy could be a To Do List. In that case, you would have an array of 
						things to do and you can ask yourself what is the first thing in your To-Do list, the second thing, or 
						the last thing, etc. There are different ways of creating an array, as well as different ways of adding 
						elements to it:
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Syntax</b></th>
							<th style="width:70%"><b>Usage</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY[INDEX]=VAL</font>
							</td>
							<td>
								If <font class="bashcommand">ARRAY</font> hasn't been initialized, it will create the array and 
								put element <font class="bashcommand">VAL</font> in the position 
								<font class="bashcommand">INDEX</font>. The first element of an array is always in 
								<font class="bashcommand">INDEX=0</font>, instead of <font class="bashcommand">INDEX=1</font>. 
								If <font class="bashcommand">ARRAY</font> already exists, it will replace 
								<font class="bashcommand">ARRAY</font> in the position <font class="bashcommand">INDEX</font> by 
								the value <font class="bashcommand">VAL</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">declare -a ARRAY=('VAL1' 'VAL2' 'VAL3' ...)</font>
							</td>
							<td>
								Initializes <font class="bashcommand">ARRAY</font> and puts the values inside the parenthesis 
								into the array, respecting the same order. You can specify any number of values. The array is 
								emptied before assigning the values if it already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">read -a ARRAY</font>
							</td>
							<td>
								The words that the user inputs are assigned to sequential indices of 
								<font class="bashcommand">ARRAY</font>. The words must be separated by spaces. The array is 
								emptied before assigning the values if it already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">IFS='DEL' read -a ARRAY</font>
							</td>
							<td>
								Splits the user input using delimiter <font class="bashcommand">DEL</font>, which must be a 
								character or a space. Then, saves the different elements into 
								<font class="bashcommand">ARRAY</font>. The array is emptied before assigning the values if it 
								already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">IFS='DEL' read -a ARRAY &lt;&lt;&lt; STRING</font>
							</td>
							<td>
								Splits <font class="bashcommand">STRING</font> using delimiter 
								<font class="bashcommand">DEL</font>, which must be a character or a space. Then, saves the 
								different elements into <font class="bashcommand">ARRAY</font>. The array is emptied before 
								assigning the values if it already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=($(seq FIRST STEP SIZE))</font>
							</td>
							<td>
								Creates an array of equally spaced numbers beginning with <font class="bashcommand">FIRST</font> 
								and separated by <font class="bashcommand">STEP</font>. It will add 
								<font class="bashcommand">SIZE</font> numbers to <font class="bashcommand">ARRAY</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=$(count -digits N FIRST LAST)</font>
							</td>
							<td>
								Creates an array of numbers, each with <font class="bashcommand">N</font> number of digits, 
								starting with <font class="bashcommand">FIRST</font> and ending with 
								<font class="bashcommand">LAST</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=$(seq N)</font>
							</td>
							<td>
								Creates an array of sequential numbers, starting with 1 and ending with 
								<font class="bashcommand">N</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=(ELEMENT1 ELEMENT3 ...)</font>
							</td>
							<td>
								Creates an array with the elements specified inside the parenthesis.
							</td>
						</tr>
					</table>
					
					<p>
						In the following examples we will use the syntax <font class="bashcommand">${ARRAY[INDEX]}</font> to 
						access the element located in the position <font class="bashcommand">INDEX</font> inside 
						<font class="bashcommand">ARRAY</font>. Remember that the first item in an array has index 0, the second 
						item has index 1, etc. I will also use the syntax <font class="bashcommand">${#ARRAY[@]}</font> to get 
						the number of non-empty values inside <font class="bashcommand">ARRAY</font>.
					</p>
					
					<font class="example">ARRAY[INDEX]=VAL</font>
					<p>
						Create an array of subjects' age where each element in the array corresponds to the age of one subject. 
						There are five subjects, so the size of the array is five. Remember, subject 1 will have its age in the 
						position 0, subject 2 in the position 1, etc. This is because <u>in bash, arrays start in the position 0 
						instead of position 1</u>. After assigning all the values to my array, I can print its contents using 
						the expression echo <font class="bashcommand">${ARRAY[@]}</font>. I can also check the size of my array 
						using <font class="bashcommand">echo ${#ARRAY[@]}</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ age[0]=59<br>
							$ age[1]=63<br>
							$ age[2]=21<br>
							$ age[3]=15<br>
							$ age[4]=94<br>
							$ echo ${age[@]}<br>
							<font class="bashcommand-result">59 63 21 15 94</font><br>
							$ echo "Array size: ${#age[@]}"<br>
							<font class="bashcommand-result">Array size: 5</font>
						</font>
					</p>
					
					<p>
						In the following example, I will start assigning values to the array in the position 1 (instead of 0). 
						That is not a problem, but the first position of my array (index=0) will remain empty, and my array will 
						have only 4 values. If I echo the item in position 0 (echo <font class="bashcommand">${ARRAY[0]}</font>), 
						I will get an empty string.
					</p>
					
					<p>
						<font class="bashcommand">
							$ age[1]=63<br>
							$ age[2]=21<br>
							$ age[3]=15<br>
							$ age[4]=94<br>
							$ echo ${age[@]}<br>
							<font class="bashcommand-result">63 21 15 94</font><br>
							$ echo "Array size: ${#age[@]}"<br>
							<font class="bashcommand-result">Array size: 4</font><br>
							$ echo "age(0): ${age[0]} "<br>
							<font class="bashcommand-result">age(0):</font>
						</font>
					</p>
					
					<p>
						<font class="example">declare -a ARRAY=('VAL1' 'VAL2' 'VAL3' ...)</font>
						It is also possible to initiate an array and assign all the values at the same time. To print an element 
						of the array, located in the position <font class="bashcommand">INDEX</font>, you must use the expression 
						<font class="bashcommand">${ARRAY[INDEX]}</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Germany' 'Spain' 'Canada')<br>
							$ echo "The element in position 0 is: ${array[0]}"<br>
							<font class="bashcommand-result">The element in position 0 is: Colombia</font><br>
							$ echo "The element in position 1 is: ${array[1]}"<br>
							<font class="bashcommand-result">The element in position 1 is: United States</font><br>
							$ echo "The element in position 2 is: ${array[2]}"<br>
							<font class="bashcommand-result">The element in position 2 is: Germany</font><br>
							$ echo "The element in position 3 is: ${array[3]}"<br>
							<font class="bashcommand-result">The element in position 3 is: Spain</font><br>
							$ echo "The element in position 4 is: ${array[4]}"<br>
							<font class="bashcommand-result">The element in position 4 is: Canada</font><br>
							$ echo "List of elements in the array: ${array[@]}"<br> 
							<font class="bashcommand-result">List of elements in the array: Colombia United States Germany Spain Canada</font><br>
							$ echo "The number of elements in the array is ${#array[@]}"<br>
							<font class="bashcommand-result">The number of elements in the array is 5</font>
						</font>
					</p>
					
					<p>
						After you declare an array, it doesn't need to stay static. You can keep adding items:
					</p>
					
					<p>
						<font class="bashcommand">
							$ array[5]="Argentina"<br>
							$ array[6]="France"<br>
							$ echo "List of elements in the array: ${array4[@]}"<br>
							<font class="bashcommand-result">List of elements in the array: Colombia United States Germany Spain Canada Argentina France</font>
						</font>
					</p>
					
					<p>
						<font class="example">read -a ARRAY</font>
						Another way of creating and initializing an array is by reading a user input. As we previously learned, 
						the command read captures the user input and saves it in a variable. By using the flag 
						<font class="bashcommand">-a</font>, the user can input more than one word (separated by a space) and bash 
						will assign each word to sequential indexes of the array, starting at 0.
					</p>
					
					<p>
						<font class="bashcommand">
							$ read -a ARRAY<br>
							<font class="bashcommand-result">Element1 Element2 Element3</font><br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">Element1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Element2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Element3</font>
						</font>
					</p>
					
					<p>
						<font class="example">IFS='DEL' read -a ARRAY</font>
						If you want to use a different delimiter other than a space to split the user input into array elements, 
						you can add <font class="bashcommand">IFS='DEL'</font> before the read command, with 
						<font class="bashcommand">DEL</font> being any character.
					</p>
					
					<font class="bashcommand">
						<p>
							$ IFS='/' read -a ARRAY<br>
							<font class="bashcommand-result">Element1/Element2/Element3</font><br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">Element1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Element2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Element3</font>
						</p>
						
						<p>
							$ IFS='.' read -a ARRAY<br>
							<font class="bashcommand-result">1.2.3</font><br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">3</font>
						</p>
					</font>
					
					<p>
						<font class="example">IFS='DEL' read -a ARRAY &lt;&lt;&lt; STRING</font>
						The same way as you can split a user input into elements of an array using a specific delimiter, you can 
						split elements of a string. This is very useful when trying to retain parts of a file path.
					</p>
					
					<p>
						<font class="bashcommand">
							$ IFS='/' read -a ARRAY &lt;&lt;&lt; "Element1/Element2/Element3"<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">Element1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Element2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Element3</font>
						</font>
					</p>
					
					<p>
						In the following example, the input string (<font class="bashcommand">/Element1/Element2/Element3</font>) 
						starts with the delimiter (<font class="bashcommand">/</font>). So, when you split it, 
						<font class="bashcommand">Element1</font> will be in position 1 (not in position 0), because the element 
						in position 0 would be the string located before the first appearance of the delimiter (which is an 
						empty string). 
					</p>
					
					<font class="bashcommand">
						<p>
							$ IFS='/' read -a ARRAY &lt;&lt;&lt; "/Element1/Element2/Element3"<br>
							$ echo ${ARRAY[0]}<br>
							<br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Element1</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Element2</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">Element3</font>
						</p>
						
						<p>
							$ IFS='/' read -a ARRAY &lt;&lt;&lt; "./Folder/Subfolder/file.txt"<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">.</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Folder</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Subfolder</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">file.txt</font>
						</p>
						
						<p>
							$ IFS='.' read -a ARRAY &lt;&lt;&lt; "1.2.3"<br>
							<font class="bashcommand-result">1.2.3</font><br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">3</font>
						</p>
						
						<p>
							$ IFS='.' read -a ARRAY &lt;&lt;&lt; "23.485"<br>
							$ echo "The integer part is ${ARRAY[0]}, and the decimal part is 0.${ARRAY[1]}"<br>
							<font class="bashcommand-result">The integer part is 23, and the decimal part is 0.485</font>
						</p>
					</font>
					
					<p>
						<font class="example">ARRAY=($(seq FIRST STEP SIZE))</font>
						You can also create an array of equally spaced or consecutive numbers in a very easy way using the 
						command <font class="bashcommand">seq</font>. In this example, I will create an array of numbers that go 
						from 15 to 19. The distance between each number (<font class="bashcommand">STEP</font>) is 0.5.
					</p>
					
					<p>
						<font class="bashcommand">
							$ ARRAY=($(seq 15 0.5 19))<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">15</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">15.5</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">16</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">16.5</font><br>
							$ echo ${ARRAY[4]}<br>
							<font class="bashcommand-result">17</font><br>
							$ echo ${ARRAY[5]}<br>
							<font class="bashcommand-result">17.5</font><br>
							$ echo ${ARRAY[6]}<br>
							<font class="bashcommand-result">18</font><br>
							$ echo ${ARRAY[7]}<br>
							<font class="bashcommand-result">18.5</font><br>
							$ echo ${ARRAY[8]}<br>
							<font class="bashcommand-result">19</font>
						</font>
					</p>
					
					<p>
						In this example, I will create an array of numbers that go from 1 to 10. The distance between each 
						number (<font class="bashcommand">STEP</font>) is 2. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ ARRAY=($(seq 1 2 10))<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">3</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">5</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">7</font><br>
							$ echo ${ARRAY[4]}<br>
							<font class="bashcommand-result">9</font>
						</font>
					</p>
					
					<p>
						When the step between the numbers is 1, it doesn't need to be written:<br>
	 					<font class="bashcommand">($(seq 15 1 19))</font> is the same as 
	 					<font class="bashcommand">($(seq 15 19))</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ ARRAY=($(seq 15 19))<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">15</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">16</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">17</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">18</font><br>
							$ echo ${ARRAY[4]}<br>
							<font class="bashcommand-result">19</font>
						</font>
					</p>
					
					<font class="example">ARRAY=(ELEMENT1 ELEMENT2 ELEMENT3 ...)</font>
					
					<p>
						<font class="bashcommand">
							$ array=(e1 e2 e3 e4 e5 e6)<br>
							$ echo ${array[0]}<br>
							<font class="bashcommand-result">e1</font><br>
							$ echo ${array[1]}<br>
							<font class="bashcommand-result">e2</font><br>
							$ echo ${array[2]}<br>
							<font class="bashcommand-result">e3</font><br>
							$ echo ${array[3]}<br>
							<font class="bashcommand-result">e4</font><br>
							$ echo ${array[4]}<br>
							<font class="bashcommand-result">e5</font><br>
							$ echo ${array[5]}<br>
							<font class="bashcommand-result">e6</font>
						</font>
					</p>
					
					<p>
						Bash and other programs have functions that return a list of elements. For example, as you will learn in 
						the section of file manipulation, the command <font class="bashcommand">ls</font> returns the list of 
						files in your current working directory. In these cases, instead of manually entering a list of elements 
						between parentheses to convert into an array, you can write the function name, and its output will be saved in the array:
					</p>
					
					<font class="bashcommand">
						<p>
							$ ls<br>
							<font class="bashcommand-result">
							<table class="ghostTable">
								<tr>
									<td>@update.afni.binaries</td>
									<td>Downloads</td>
									<td>abin</td>
								</tr>
								
								<tr>
									<td>AFNI_data5</td>
									<td>Library</td>
									<td>afni_handouts</td>
								</tr>
								
								<tr>
									<td>AFNI_data6</td>
									<td>Movies</td>
									<td>dax</td>
								</tr>
								
								<tr>
									<td>AFNI_demos</td>
									<td>Music</td>
									<td>std_meshes</td>
								</tr>
								
								<tr>
									<td>Desktop</td>
									<td>Pictures</td>
									<td>suma_demo</td>
								</tr>
								
								<tr>
									<td>Documents</td>
									<td>Public</td>
									<td>test.txt</td>
								</tr>
							</table>
							</font>
						</p>
						
						<p>
							$ array=($(ls))<br>
							$ echo ${array[0]}<br>
							<font class="bashcommand-result">@update.afni.binaries</font><br>
							$ echo ${array[1]}<br>
							<font class="bashcommand-result">AFNI_data5</font><br>
							$ echo ${array[2]}<br>
							<font class="bashcommand-result">AFNI_data6</font><br>
							$ echo ${array[3]}<br>
							<font class="bashcommand-result">AFNI_demos</font><br>
							$ echo ${array[4]}<br>
							<font class="bashcommand-result">Desktop</font>
						</p>
					</font>
					
				<h3>5.2. Array operations</h3>
					<p>Once you have initialized an array, you can do the following operations with it:</p>
					
					<table>
					<tr>
						<th style="width:30%"><b>Syntax</b></th>
						<th style="width:70%"><b>Usage</b></th>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${ARRAY[INDEX]}</font>
						</td>
						<td>
							Returns the element in position <font class="bashcommand">INDEX</font> inside 
							<font class="bashcommand">ARRAY</font>. The first index is 0, then 1, etc.<br>
							See the examples section of creating sub-strings 
							(<font class="bashcommand">${STRING:START:NUM}</font>) to know how to obtain a character in a 
							specific position inside a string instead of an array.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${#ARRAY[@]}</font><br>
							or<br>
							<font class="bashcommand">${#STRING}</font>
						</td>
						<td>
							Returns the size of <font class="bashcommand">ARRAY</font> (number of non-empty elements) or the 
							number of characters in <font class="bashcommand">STRING</font>.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${#ARRAY[INDEX]}</font>
						</td>
						<td>
							Returns the size of the element located in the position <font class="bashcommand">INDEX</font> 
							(number of characters).
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${ARRAY[@]}</font>
						</td>
						<td>
							Returns all the elements of <font class="bashcommand">ARRAY</font>.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${ARRAY[@]/OLD_ITEM/NEW_ITEM}</font>
						</td>
						<td>
							Replaces <b>all occurrences</b> of <font class="bashcommand">OLD_ITEM</font> by 
							<font class="bashcommand">NEW_ITEM</font>. You could use the symbols 
							<font class="bashcommand">*</font>, <font class="bashcommand">#</font> and 
							<font class="bashcommand">%</font> inside <font class="bashcommand">OLD_ITEM</font> to replace 
							all elements that follow a specific pattern (<a href="#ex5">see examples</a>).
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${STRING/OLD_ITEM/NEW_ITEM}</font>
						</td>
						<td>
							Replaces the <b>first occurrence</b> of <font class="bashcommand">OLD_ITEM</font> by 
							<font class="bashcommand">NEW_ITEM</font> in <font class="bashcommand">STRING</font> (a string 
							is an array of characters). You could use the symbols <font class="bashcommand">*</font>, 
							<font class="bashcommand">#</font> and <font class="bashcommand">%</font> inside 
							<font class="bashcommand">OLD_ITEM</font> to replace all elements that follow a specific pattern 
							(<a href="#ex6">see examples</a>).
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${STRING//OLD_ITEM/NEW_ITEM}</font>
						</td>
						<td>
							Replaces <b>all occurrences</b> of <font class="bashcommand">OLD_ITEM</font> by 
							<font class="bashcommand">NEW_ITEM</font> in <font class="bashcommand">STRING</font>. You could use 
							the symbols <font class="bashcommand">*</font>, <font class="bashcommand">#</font> and 
							<font class="bashcommand">%</font> inside <font class="bashcommand">OLD_ITEM</font> to replace all 
							elements that follow a specific pattern (<a href="#ex7">see examples</a>).
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">NEWARRAY=("${ARRAY[@]}")</font>
						</td>
						<td>
							Copy the elements of <font class="bashcommand">ARRAY</font> into 
							<font class="bashcommand">NEWARRAY</font>.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">NEWARRAY=("${ARRAY1[@]}" "${ARRAY2[@]}" "${ARRAY3[@]}" ...)</font>
						</td>
						<td>
							Concatenates arrays <font class="bashcommand">ARRAY1</font>, 
							<font class="bashcommand">ARRAY2</font>, and <font class="bashcommand">ARRAY3</font> into one 
							single array called <font class="bashcommand">NEWARRAY</font>. You can concatenate as many 
							arrays as you want.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">unset ARRAY</font>
						</td>
						<td>
							Deletes <font class="bashcommand">ARRAY</font> from memory.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${ARRAY[@]:START:NUM}</font><br>
							or<br>
							<font class="bashcommand">${STRING:START:NUM}</font>
						</td>
						<td>
							Creates a sub-array from <font class="bashcommand">ARRAY</font> (or a sub-string from 
							<font class="bashcommand">STRING</font>). Beginning with the element in the position 
							<font class="bashcommand">START</font> and containing <font class="bashcommand">NUM</font> 
							number of elements.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">IFS=$'\n' sorted=($(sort &lt;&lt;&lt;"${array[*]}"))</font>
						</td>
						<td>
							Sorts in alphabetical order array and saves the result in sorted.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">IFS='+' sum=$(echo "scale=1;${array[*]}"|bc)</font>
						</td>
						<td>
							Adds all elements in array and saves the result in variable <font class="bashcommand">sum</font>.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">IFS='+' avg=$(echo "scale=1;(${array[*]})/${#array[@]}"|bc)</font>
						</td>
						<td>
							Calculates the average of elements in <font class="bashcommand">array</font> and saves the 
							result in variable <font class="bashcommand">avg</font>.
						</td>
					</tr>
				</table>
				
				<div id="ex1">
					<p><font class="example">${ARRAY[INDEX]}</font></p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Spain' 'Canada')<br>
							$ echo "The element of the array in position 0 is: ${array[0]}"<br>
							<font class="bashcommand-result">The element of the array in position 0 is: Colombia</font><br>
							$ echo "The element of the array in position 1 is: ${array[1]}"<br>
							<font class="bashcommand-result">The element of the array in position 1 is: United States</font>
						</font>
					</p>
				</div>
				
				<div id="ex2">
					<p><font class="example">${#ARRAY[@]}</font></p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Spain' 'Canada')<br>
							$ echo "The number of elements in the array is ${#array[@]}"<br>
							<font class="bashcommand-result">The number of elements in the array is 4</font>
						</font>
					</p>
				</div>
				
				<div id="ex3">
					<p>
						<font class="example">${#ARRAY[INDEX]}</font>
						<font class="bashcommand">${#ARRAY[INDEX]}</font> will return the number of characters of the element of 
						the array located in the specified index. <font class="bashcommand">Colombia</font> is in index 0, 
						<font class="bashcommand">United States</font> in index 1, <font class="bashcommand">Spain</font> in 
						index 2. <font class="bashcommand">Spain</font> has six characters, so 
						<font class="bashcommand">${#ARRAY[2]}=6</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Spain' 'Canada')<br>
							$ echo "The element in position 2 is ${array[2]}, and its size is ${#array[2]}"<br>
							<font class="bashcommand-result">The element in position 2 is Spain, and its size is 5</font>
						</font>
					</p>
				</div>
				
				<div id="ex4">
					<p><font class="example">${ARRAY[@]}</font></p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Spain' 'Canada')<br>
							$ echo ${array[@]}<br>
							<font class="bashcommand-result">Colombia United States Spain Canada</font>
						</font>
					</p>
				</div>
				
				<div id="ex5">
					<p>
						<font class="example">${ARRAY[@]/OLD_ITEM/NEW_ITEM}</font>
						Substitute all the instances of <font class="bashcommand">Colombia</font> 
						(<font class="bashcommand">OLD_ITEM</font>) by Spain (<font class="bashcommand">NEW_ITEM</font>) in 
						the array.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Colombia' 'Canada')<br>
							$ echo ${array[@]/Colombia/Spain}<br>
							<font class="bashcommand-result">Spain United States Spain Canada</font>
						</font>
					</p>
					
					<p>To remove an item, you simply substitute it by nothing (leave <font class="bashcommand">NEW_ITEM</font> 
					empty).</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Subject01' 'Subject01' 'Subject03' 'Subject04')<br>
							$ echo ${array[@]/Subject01/}<br>
							<font class="bashcommand-result">Subject03 Subject04</font>
						</font>
					</p>
				</div>
				
				<div id="ex6">
					<p>
						<font class="bashcommand">${STRING/OLD_ITEM/NEW_ITEM}</font>
						A string is an array of characters. So, you can replace parts of a string the same way that you do 
						with an array (without the <font class="bashcommand">[@]</font>).
					</p>
					
					<font class="bashcommand">
						<p>
							$ P="/Users/Neuro/Desktop"<br>
							$ echo ${P/Neuro/Research}<br>
							<font class="bashcommand-result">/Users/Research/Desktop</font>
						</p>
						
						<p>
							$ P="/Users/Neuro/Desktop"<br>
							$ echo ${P/Desktop/}<br>
							<font class="bashcommand-result">/Users/Neuro/</font>
						</p>
					</font>
					
					<p>
						You can use patterns to remove a group of elements from an array. For example, in the following 
						array you have three items that start by <font class="bashcommand">AA</font>, so you use as 
						<font class="bashcommand">ITEM_TO_REPLACE: AA*</font>. As you can see, the three items that start 
						with <font class="bashcommand">AA</font> are deleted.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=('AA123' 'AB345' 'AA987' 'BB098' 'AA456')<br>
							$ echo ${ARRAY[@]/AA*/}<br>
							<font class="bashcommand-result">AB345 BB098</font>
						</font>
					</p>
					
					<p>
						Below are a few more examples on how to use patterns to remove a group of items from an array:
					</p>
					
					<p>
						Delete all items that end with the letter Z (<font class="bashcommand">'HGTZ'</font> and 
						<font class="bashcommand">'ZZZZ'</font>):<br>
						<font class="bashcommand">
							$ declare -a ARRAY=('QWER' 'HGTZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ echo ${ARRAY[@]/*Z/}<br>
							<font class="bashcommand-result">QWER QRJD JHGF</font>
						</font>
					</p>
					
					<p>
						Delete all items that have an <font class="bashcommand">A</font> at the beginning and a 
						<font class="bashcommand">Z</font> at the end (<font class="bashcommand">'ASDFZ'</font>). Observe 
						that either <font class="bashcommand">'RFGHJZ'</font> nor <font class="bashcommand">'ZZZZ'</font> get 
						deleted because even though they end with a <font class="bashcommand">Z</font>, they don't start 
						with an <font class="bashcommand">A</font>, so those two strings don't follow the 
						<font class="bashcommand">A*Z</font> pattern: <br>
						<font class="bashcommand">
							$ declare -a ARRAY=('ASDFZ' 'RFGHJZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ echo ${ARRAY[@]/A*Z/}<br>
							<font class="bashcommand-result">RFGHJZ QRJD ZZZZ JHGF</font>
						</font>
					</p>
					
					<p>
						To replace the front-end occurrences of a substring within an array, you can use the following 
						syntax: <font class="bashcommand">${ARRAY[@]/#SUBSTRING_TO_REPLACE/NEW_SUBSTRING}:</font><br>
						<font class="bashcommand">
							$ declare -a ARRAY=('SUBJ0' 'SUBJ9' 'SUBJ3' 'SUBJ4' 'SUBJ3')<br>
							$ echo ${ARRAY[@]/#SUBJ/SUBJECT}<br>
							<font class="bashcommand-result">SUBJECT0 SUBJECT9 SUBJECT3 SUBJECT4 SUBJECT3</font>
						</font>
					</p>
					
					<p>
						To replace the back end occurrences of a substring within an array, use the symbol 
						<font class="bashcommand">%</font> instead of <font class="bashcommand">#</font> and the same syntax 
						as before:<br>
						<font class="bashcommand">
							$ declare -a ARRAY=('ID_001' 'AGE_001' 'GENDER_001' 'QC_001')<br>
							$ echo ${ARRAY[@]/%001/125}<br>
							<font class="bashcommand-result">ID_125 AGE_125 GENDER_125 QC_125</font>
						</font> 
					</p>
				</div>
				
				<div id="ex7">
					<p>
						<font class="example">${STRING//OLD_ITEM/NEW_ITEM}</font>
						With strings, contrary to how it happens with arrays, using the previous syntax will only replace the 
						first occurrence of <font class="bashcommand">OLD_ITEM</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ P="/Users/Neuro/Desktop/Neuro"<br>
							$ echo ${P/Neuro/Research}<br>
							<font class="bashcommand-result">/Users/Research/Desktop/Neuro</font>
						</font>
					</p>
					
					<p>In order to replace all occurrences of <font class="bashcommand">OLD_ITEM</font> you must use double 
					slash:</p>
					
					<font class="bashcommand">
						<p>
							$ P="/Users/Neuro/Desktop/Neuro"<br>
							$ echo ${P//Neuro/Research}<br>
							<font class="bashcommand-result">/Users/Research/Desktop/Research</font>
						</p>
						
						<p>
							$ P="/Users/Neuro/Desktop"<br>
							$ echo ${P//e/}<br>
							<font class="bashcommand-result">/Usrs/Nuro/Dsktop</font>
						</p>
					</font>
				</div>
				
				<div id="ex8">
					<p>
						<font class="example">NEWARRAY=("${ARRAY[@]}")</font>
						This syntax is used to copy all the elements of one array into a new one.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=('ASDFZ' 'RFGHJZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ NEWARRAY=("${ARRAY[@]}")<br>
							$ echo ${NEWARRAY[@]}<br>
							<font class="bashcommand-result">ASDFZ RFGHJZ QRJD ZZZZ JHGF</font>
						</font>
					</p>
				</div>
				
				<div id="ex9">
					<p>
						<font class="example">NEWARRAY=("${ ARRAY1[@]}" "${ARRAY2[@]}" "${ ARRAY3[@]}" ...)</font>
						Concatenating arrays is very similar to copying arrays. If you want to concatenate array 
						<font class="bashcommand">A</font> and <font class="bashcommand">B</font>, and save the result in 
						<font class="bashcommand">C</font>. You just copy <font class="bashcommand">A</font> after 
						<font class="bashcommand">B</font> (using the previous syntax) and assign it to 
						<font class="bashcommand">C</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a A=('ASDFZ' 'RFGHJZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ declare -a B=('3333' '2222' '1111')<br>
							$ C=("${A[@]}" "${B[@]}")<br>
							$ echo ${C[@]}<br>
							<font class="bashcommand-result">ASDFZ RFGHJZ QRJD ZZZZ JHGF 3333 2222 1111</font>
						</font>
					</p>
				</div>
				
				<div id="ex10">
					<p>
						<font class="example">unset ARRAY</font>
						If your script creates very big temporary arrays that won't be used again, you might want to delete them 
						to free some memory. For that you use the command unset. You might want to use unset also if you want to 
						make sure that the array is empty before you start adding elements.
					</p>
					
					<p>
						In this example, after deleting array A and echoing it again, nothing will be printed as the array is now 
						empty:
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a A=('ASDFZ' 'RFGHJZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ echo ${A[@]}<br>
							<font class="bashcommand-result">ASDFZ RFGHJZ QRJD ZZZZ JHGF</font><br>
							$ unset A<br>
							$ echo ${A[@]}
						</font>
					</p>
				</div>
				
				<div id="ex11">
					<p>
						<font class="example">${ARRAY[@]:START:NUM}</font>
						By using <font class="bashcommand">${ARRAY[@]:START:N}</font>, you can create a sub-array that 
						contains <font class="bashcommand">N</font> elements from the original array, starting from the 
						index <font class="bashcommand">START</font>. Remember, the index of the first item is 0. So, in the 
						following example the index of <font class="bashcommand">'Element1'</font> is 0 and the index of 
						<font class="bashcommand">'Element2'</font> is 1.
					</p>
					
					<p>
						Extract 2 items from <font class="bashcommand">ARRAY</font> starting in index 0 (items 
						<font class="bashcommand">'Element1'</font> and <font class="bashcommand">'Element2'</font>):
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=( 'Element1' 'Element2' 'Element3' 'Element4' 'Element5')<br>
							$ echo ${ARRAY[@]:0:2}<br>
							<font class="bashcommand-result">Element1 Element2</font>
						</font>
					</p>
					
					<p>
						Extract 3 items from <font class="bashcommand">ARRAY</font> starting in index 2 (items 
						<font class="bashcommand">'Element3'</font>, <font class="bashcommand">'Element4'</font> and 
						<font class="bashcommand">'Element5'</font>):
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=( 'Element1' 'Element2' 'Element3' 'Element4' 'Element5')<br>
							$ echo ${ARRAY[@]:2:3}<br>
							<font class="bashcommand-result">Element3 Element4 Element5</font>
						</font>
					</p>
					
					<p>
						Extract 4 items from <font class="bashcommand">ARRAY</font> starting in index 2. There are only 
						three elements from the item in index 2 until the end of the array. So, bash will only extract 3 
						items (there's no 4th item to extract).
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=( 'Element1' 'Element2' 'Element3' 'Element4' 'Element5')<br>
							$ echo ${ARRAY[@]:2:4}<br>
							<font class="bashcommand-result">Element3 Element4 Element5</font>
						</font>
					</p>
				</div>
				
				<div id="ex12">
					<p>
						<font class="example">${STRING:START:NUM}</font>
						Extract characters from a string. Remember, a string is also an array (an array of characters).
					</p>
					
					<p>
						<font class="bashcommand">
							$ S="Colombia"<br>
							$ echo "The first character in ${S} is ${S:0:1}"<br>
							<font class="bashcommand-result">The first character in Colombia is C</font><br>
							$ echo "The third character in ${S} is ${S:2:1}"<br>
							<font class="bashcommand-result">The third character in Colombia is l</font><br>
							$ SIZE=${#S}<br>
							$ echo $SIZE<br>
							<font class="bashcommand-result">8</font><br>
							$ echo "The last two characters in ${S} are ${S:$(( ${SIZE} - 2 )):2}"<br>
							<font class="bashcommand-result">The last two characters in Colombia are ia</font>
						</font>
					</p>
				</div>
				
				<div id="ex13">
					<p>
						<font class="example">IFS=$'\n' sorted=($(sort <<<"${array[*]}"))</font>
						Sort <font class="bashcommand">array</font> and save the output in sorted (array stays the same):
					</p>
					
					<p>
						<font class="bashcommand">
							$ array=(ewrwr dfgfgdf asda yrtytr)<br>
							$ echo ${array[@]}<br>
							<font class="bashcommand-result">ewrwr dfgfgdf asda yrtytr</font><br>
							$ IFS=$'\n' sorted=($(sort &lt;&lt;&lt;"${array[*]}"))<br>
							${sorted[@]}<br>
							<font class="bashcommand-result">asda dfgfgdf ewrwr yrtytr</font><br>
							$ echo ${array[@]}<br>
							<font class="bashcommand-result">ewrwr dfgfgdf asda yrtytr</font>
						</font>
					</p>
				</div>
		    </div>
		    
		    <div id="content6" class="hidden">
		    	<h2>6. Condition-testing</h2>
		    
		    	<p>
					Variables can be used to test if a certain condition is true or false, and therefore be able to take a 
					different course of action depending on the result of the test. For example, you might want to evaluate 
					if a file exists to decide if you can copy it into a different folder or not. For condition-testing you 
					will use the if-command. This command has the following syntax:
				</p>
				
				<p>
					if [ CONDITION_TO_EVALUATE ]<br>
					then<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&lt;INSTRUCTIONS THAT WILL RUN IF THE CONDITION IS TRUE&gt;<br>
					elif [ OTHER_CONDITION_TO_EVALUATE_IF_1ST_CONDITION_IS_FALSE ]<br>
					then<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&lt;INSTRUCTIONS THAT WILL RUN IF FIRST CONDITION IS FALSE BUT SECOND IS TRUE&gt;<br>
					else<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&lt;INSTRUCTIONS THAT WILL RUN IF ALL THE PREVIOUS CONDITIONS ARE FALSE&gt;<br>
					fi
				</p>
				
				<p>
					The CONDITION_TO_EVALUATE is an expression that follows a specific syntax depending on what you want to 
					test (checking files, string comparison, comparing numbers, or combining different expressions). Lets 
					look at the different syntaxes used in each of these situations and at some examples that will help you 
					understand this seemingly confusing subject.
				</p>
				
				<h3>6.1. Condition-testing to check files</h3>
					<p>
						In the following table, <font class="bashcommand">FILE</font> refers to the path of the file or to the 
						variable that contains the path of the file. The spaces after <font class="bashcommand">[</font> and 
						before <font class="bashcommand">]</font> are very important. If those spaces are missing, bash will 
						give an error.
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Condition</b></th>
							<th style="width:70%"><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -a FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -d FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a directory.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -e FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -f FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a regular file.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -g FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and its SGID bit is set.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -h FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a symbolic link.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -k FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and its sticky bit is set.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -p FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a named pipe (FIFO).</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -r FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is readable.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -s FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and has a size greater than zero.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -t FD ]</font>
							</td>
							<td>Tests if file descriptor <font class="bashcommand">FD</font> is open and refers to a terminal.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -u FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and its SUID (set user ID) bit is set.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -w FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is writable.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -x FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is executable.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -O FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is owned by the effective user ID.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -G FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is owned by the effective group ID.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -L FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a symbolic link.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -N FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and has been modified since it was last read.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -S FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a socket.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ FILE1 -nt FILE2 ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE1</font> has been changed more recently than <font class="bashcommand">FILE2</font>, or if <font class="bashcommand">FILE1</font> exists and <font class="bashcommand">FILE2</font> does not.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ FILE1 -ot FILE2 ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE1</font> is older than <font class="bashcommand">FILE2</font>, or is <font class="bashcommand">FILE2</font> exists and <font class="bashcommand">FILE1</font> does not.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ FILE1 -ef FILE2 ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE1</font> and <font class="bashcommand">FILE2</font> refer to the same device and inode numbers.</td>
						</tr>
					</table>
					
				<p>
					In the following section you will not find examples of the following flags because they are related to user permissions, a topic that has not been explained yet and will be explained in future chapters, or because they are less common. However, the use of these flags is the same as the ones explained below. 
				</p>
				
				<p>
					<font class="example">[-aFILE]:</font>
					<font class="bashcommand">
						$ FILE=/Users/MyUser/Desktop/someFile.txt<br>
						$ if [ -a "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "${FILE} exists"<br>
						&gt; else<br>
						&gt; echo "${FILE} doesn't exist"<br>
						&gt; fi 
					</font>
				</p>
				
				<p>
					<font class="bashcommand">
						$ if [ -a "/Users/MyUser/Desktop/someFile.txt" ]<br>
						&gt; then<br>
						&gt; echo "The file exists"<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist"<br>
						&gt; fi 
					</font>
				</p>
				
				<p>
					The following example shows a common mistake. Here, the quotation marks surrounding the file path are missing. Since the path has spaces, bash gives an error: 
				</p>
				
				<p>
					<font class="bashcommand">
						$ if [ -a /Users/MyUser/Desktop/some file name with spaces.txt ]<br>
						&gt; then<br>
						&gt; echo "The file exists"<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist"<br>
						&gt; fi<br>
						<font class="bashcommand-result">-bash: [: too many argument</font>
					</font>
				</p>
				
				<p>
					<font class="example">[-dFILE]:</font>
					<font class="bashcommand">
						$ FILE=/Users/MyUser/Desktop/someFile.txt<br>
						$ if [ -a "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "The file exists. Now I will find out if it's a directory or a regular file."<br>
						&gt; if [ -d "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "It is a directory."<br>
						&gt; else<br>
						&gt; echo "It is a regular file."<br>
						&gt; fi<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist."<br>
						&gt; fi
					</font>
				</p>
				
				<p>
					The following example shows a common mistake. Here, the spaces before and after the expression (<font class="bashcommand">-a "${FILE}"</font>) are missing. So, bash will give an error: 
				</p>
				
				<p>
					<font class="bashcommand">
						$ FILE=/Users/MyUser/Desktop/someFile.txt<br>
						$ if [-a "${FILE}"]<br>
						&gt; then<br>
						&gt; echo "The file exists. Now I will find out if it's a directory or a regular file."<br>
						&gt; if [ -d "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "It is a directory."<br>
						&gt; else<br>
						&gt; echo "It is a regular file."<br>
						&gt; fi<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist."<br>
						&gt; fi<br>
						<font class="bashcommand-result">-bash: [-a: command not found</font>
					</font>
				</p>
				
				<p>
					<font class="example">[-fFILE]:</font>
					<font class="bashcommand">
						$ FILE=/Users/MyUser/Desktop/someFile.txt<br>
						$ if [ -a "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "The file exists. Now I will find out if it's a directory or a regular file."<br>
						&gt; if [ -f "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "It is a regular file."<br>
						&gt; else<br>
						&gt; echo "It is a directory."<br>
						&gt; fi<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist."<br>
						&gt; fi
					</font>
				</p>
				
				<p>
					<font class="example">[-NFILE]:</font>
					<font class="bashcommand">
						$ if [ -N "/Users/MyUser/Desktop/someFile.txt" ]<br>
						&gt; then<br>
						&gt; echo "The file exists and has been modified since the last time it was opened."<br>
						&gt; else<br>
						&gt; echo "Either the file doesn't exist, or it hasn't been modified."<br>
						&gt; fi 
					</font>
				</p>
				
				<h3>6.2. Condition-testing to compare/evaluate strings</h3>
					<p>
						When comparing strings, it is mandatory to use the quotation marks. The spaces after <font class="bashcommand">[</font> and before <font class="bashcommand">]</font> are very important. If those spaces are missing, bash will give an error. 
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Condition</b></th>
							<th style="width:70%"><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -z"STRING" ]</font>
							</td>
							<td>Tests if the length of<font class="bashcommand">STRING</font>is zero</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -n"STRING" ]</font>
							</td>
							<td>Tests if the length of<font class="bashcommand">STRING</font>is non-zero</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" == "STRING2" ]</font>
							</td>
							<td>Tests if the strings are equal</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" != "STRING2" ]</font>
							</td>
							<td>Tests if the strings are not equal</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" \< "STRING2" ]</font>
							</td>
							<td>Tests if<font class="bashcommand">STRING1</font>sorts before<font class="bashcommand">STRING2</font></td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" \> "STRING2" ]</font>
							</td>
							<td>Tests if<font class="bashcommand">STRING1</font>sorts after<font class="bashcommand">STRING2</font></td>
						</tr>
					</table>
					
					<p>
						<font class="example">[ -z"STRING" ]:</font>
						<font class="bashcommand">
							$ if [ -z "" ]<br>
							&gt; then<br>
							&gt; echo "Empty string"<br>
							&gt; fi<br>
							<font class="bashcommand-result">Empty string</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ -n"STRING" ]:</font>
						<font class="bashcommand">
							$ VAR="Some text"<br>
							$ if [ -n "${VAR}" ]<br>
							&gt; then<br>
							&gt; echo "The string is not empty"<br>
							&gt; fi<br>
							<font class="bashcommand-result">The string is not empty</font> 
						</font>
					</p>
					
					<p>In this example, bash will show an error because I forgot to put the quotation marks around <font class="bashcommand">${VAR}</font>.</p>
					
					<p>
						<font class="bashcommand">
							$ VAR="Some text"<br>
							$ if [ -n ${VAR} ]<br>
							&gt; then<br>
							&gt; echo "The string is not empty"<br>
							&gt; fi<br>
							<font class="bashcommand-result">-bash: [: Some: binary operator expected</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ "STRING1" == "STRING2" ]:</font>
						<font class="bashcommand">
							$ QC="Good"<br>
							$ if [ "${QC}" == "Good" ]<br>
							&gt; then<br>
							&gt; echo "Quality control good"<br>
							&gt; else<br>
							&gt; echo "Image has bad quality"<br>
							&gt; fi<br>
							<font class="bashcommand-result">Quality control good</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ "STRING1" != "STRING2" ]:</font>
						<font class="bashcommand">
							$ QC="Good"<br>
							$ if [ "${QC}" != "Good" ]<br>
							&gt; then<br>
							&gt; echo "Quality control is not good"<br>
							&gt; else<br>
							&gt; echo "Image has good quality"<br>
							&gt; fi<br>
							<font class="bashcommand-result">Image has good quality</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ "STRING1" \< "STRING2" ]:</font>
						In the following example, I am comparing the strings <font class="bashcommand">"Canada"</font> with <font class="bashcommand">"Colombia"</font> and printing the one that sorts first. <font class="bashcommand">"Canada"</font> will be printed because the first letter of both words is the same but the second letter in <font class="bashcommand">"Canada"</font> (letter <font class="bashcommand">a</font>) comes before the second letter in <font class="bashcommand">"Colombia"</font> (letter <font class="bashcommand">o</font>).<br>
						<font class="bashcommand">
							$ VAR1="Canada"<br>
							$ VAR2="Colombia"<br>
							$ if [ "${VAR1}" \< "${VAR2}" ]<br>
							&gt; then<br>
							&gt; echo ${VAR1}<br>
							&gt; else<br>
							&gt; echo ${VAR2}<br>
							&gt; fi<br>
							<font class="bashcommand-result">Canada</font>
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${VAR1}" \< "${VAR2}" ] &gt;&gt; echo ${VAR1} || echo ${VAR2}<br>
							<font class="bashcommand-result">Canada</font>
						</font>	
					</p>
					
					<p>
						<font class="example">[ "STRING1" \> "STRING2" ]:</font>
						<font class="bashcommand">
							$ VAR1="Canada"<br> 
							$ VAR2="Colombia"<br>
							$ if [ "${VAR1}" \> "${VAR2}" ]<br>
							&gt; then<br>
							&gt; echo ${VAR2}<br>
							&gt; else<br>
							&gt; echo ${VAR1}<br>
							&gt; fi<br>
							<font class="bashcommand-result">Canada</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${VAR1}" \> "${VAR2}" ] &gt;&gt; echo ${VAR2} || echo ${VAR1}<br>
							<font class="bashcommand-result">Canada</font>
						</font>
					</p>
					
				<h3>6.3. Condition-testing to compare numbers</h3>
					<p>The spaces after <font class="bashcommand">[</font> and before <font class="bashcommand">]</font> are very important. If those spaces are missing, bash will give an error.</p>
					<table>
						<tr>
							<th><b>Condition</b></th>
							<th><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -eq NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is equal to <font class="bashcommand">NUM2</font></td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -ne NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is not equal to <font class="bashcommand">NUM2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -lt NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is less than <font class="bashcommand">NUM2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -le NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is less than or equal to <font class="bashcommand">NUM2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -gt NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is greater than <font class="bashcommand">NUM2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -ge NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is greater than or equal to <font class="bashcommand">NUM2</font>.</td>
						</tr>
					</table>
					
					<p>
						<font class="example">[ NUM1 -eq NUM2 ]:</font>
						<font class="bashcommand">
							$ if [ 3 -eq 3 ]<br>
							&gt; then<br>		
							&gt; echo "This makes sense, 3 equals 3."<br>					
							&gt; fi<br>			
							<font class="bashcommand-result">This makes sense, 3 equals 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ 3 -eq 3 ] &gt;&gt; echo "This makes sense, 3 equals 3."<br>
							<font class="bashcommand-result">This makes sense, 3 equals 3.</font>
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -eq "3" ]<br>
							&gt; then<br> 
							&gt; echo "This makes sense, ${A} equals 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This makes sense, 3 equals 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -eq "3" ] &gt;&gt; echo "This makes sense, ${A} equals 3."<br>
							<font class="bashcommand-result">This makes sense, 3 equals 3.</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ NUM1 -ne NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -ne "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is not equal to 3"<br> 
							&gt; else<br>
							&gt; echo "Variable A equals 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A equals 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -ne "3" ] &gt;&gt; echo "Variable A is not equal to 3" || echo "Variable A equals 3."<br>
							<font class="bashcommand-result">Variable A equals 3.</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ NUM1 -lt NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -lt "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is less than 3"<br> 
							&gt; else<br>
							&gt; echo "Variable A not less than 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A is not less than 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -lt "3" ] &gt;&gt; echo "Variable A is less than 3" || echo "Variable A not less than 3."<br>
							<font class="bashcommand-result">Variable A is not less than 3.</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ NUM1 -le NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br> 
							$ if [ "${A}" -le "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is less or equal to 3"<br>
							&gt; else<br>
							&gt; echo "Variable A greater than 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A is less or equal to 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -le "3" ] &gt;&gt; echo "Variable A is less or equal to 3" || echo "Variable A greater than 3."<br>
							<font class="bashcommand-result">Variable A is less or equal to 3.</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ NUM1 -gt NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -gt "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is greater than 3."<br>
							&gt; else<br>
							&gt; echo "Variable A not greater than 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A is not greater than 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -gt "3" ] &gt;&gt; echo "Variable A is greater than 3." || echo "Variable A not greater than 3."<br>
							<font class="bashcommand-result">Variable A is not greater than 3.</font>
						</font>	
					</p>
					
					<p>
						<font class="example">[ NUM1 -ge NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -ge "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is greater or equal to 3"<br>
							&gt; else<br>
							&gt; echo "Variable A less than 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A is greater or equal to 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -ge "3" ] &gt;&gt; echo "Variable A is greater or equal to 3" || echo "Variable A less than 3."<br>
							<font class="bashcommand-result">Variable A is greater or equal to 3.</font>
						</font>
					</p>
					
				<h3>6.4. Condition-testing to compare arrays</h3>
					<table>
						<tr>
							<th><b>Condition</b></th>
							<th><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ "${array1[*]}" == "${array2[*]}" ]</font></td>
							<td>Tests if <font class="bashcommand">array1</font> equals to <font class="bashcommand">array2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ "${array1[*]}" != "${array2[*]}" ]</font></td>
							<td>Tests if array1 is different to array2.</td>
						</tr>
					</table>
					
					<p>
						<font class="example">[ "${array1[*]}" == "${array2[*]}" ]:</font>
						<font class="bashcommand">
							$ arr1=(a b c)<br>
							$ arr2=(a b c d)<br>
							$ arr3=(a b c)<br>
							$ if [ "${arr1[*]}" == "${arr3[*]}" ]<br>
							&gt; then<br>
							&gt; echo "equal"<br>
							&gt; else<br>
							&gt; echo "different"<br>
							&gt; fi<br>
							<font class="bashcommand-result">equal</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${arr1[*]}" == "${arr3[*]}" ] &gt;&gt; echo "equal" || echo "different"<br>
							<font class="bashcommand-result">equal</font>
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ "${arr1[*]}" == "${arr2[*]}" ]<br>
							&gt; then<br>
							&gt; echo "equal"<br>
							&gt; else<br>
							&gt; echo "different"<br>
							&gt; fi<br>
							<font class="bashcommand-result">different</font>
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${arr1[*]}" == "${arr2[*]}" ] &gt;&gt; echo "equal" || echo "different"<br>
							<font class="bashcommand-result">different</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ "${arr1[*]}" != "${arr2[*]}" ]:</font>
						<font class="bashcommand">
							$ if [ "${arr1[*]}" != "${arr2[*]}" ]<br>
							&gt; then<br>
							&gt; echo "different"<br>
							&gt; else<br>
							&gt; echo "equal"<br>
							&gt; fi<br>
							<font class="bashcommand-result">different</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${arr1[*]}" != "${arr2[*]}" ] &gt;&gt; echo "different" || echo "equal"<br>
							<font class="bashcommand-result">different</font>
						</font>
					</p>
					
					<h3>6.5. Combining different expressions for condition-testing</h3>
					<table>
						<tr>
							<th><b>Condition</b></th>
							<th><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ EXPR ]</font></td>
							<td>Tests if the expression <font class="bashcommand">EXPR</font> is <b>true</b>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ ! EXPR ]</font></td>
							<td>Tests if the expression <font class="bashcommand">EXPR</font> is <b>false</b>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ EXPR1 ] || [ EXPR2 ]</font></td>
							<td>Tests if <font class="bashcommand">EXPR1</font> <b>or</b> <font class="bashcommand">EXPR2</font> are true. You can add as many expressions as desired.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ EXPR1 ] &amp;&amp; [ EXPR2 ]</font></td>
							<td>Tests if <font class="bashcommand">EXPR1</font> <b>and</b> <font class="bashcommand">EXPR2</font> are true. You can add as many expressions as desired.</td>
						</tr>
					</table>
					
					<p>
						<font class="example">[ EXPR ] vs [ ! EXPR ]</font>
						<font class="bashcommand">
							$ if [ 3 -eq 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be printed if the expression 3 equals 3 is true."<br>
							&gt; else<br>
							&gt; echo "This will be printed if the expression is false (3 is not equal to 3)."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be printed if the expression 3 equals 3 is true.</font>
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ 3 -eq 3 ] &gt;&gt;  echo "This will be printed if the expression 3 equals 3 is true." || echo "This will be printed if the expression is false (3 is not equal to 3)."<br>
							<font class="bashcommand-result">This will be printed if the expression 3 equals 3 is true.</font>
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ ! 3 -eq 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be printed if it is false that 3 equals 3 (so, if 3 is different than 3)."<br>
							&gt; else<br>
							&gt; echo "This will be printed if it is not false (it's true) that 3 equals 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be printed if it is not false (it's true) that 3 equals 3.</font>
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ ! 3 -eq 3 ] &gt;&gt; echo "This will be printed if it is false that 3 equals 3 (so, if 3 is different than 3)." || echo "This will be printed if it is not false (it's true) that 3 equals 3."<br>
							<font class="bashcommand-result">This will be printed if it is not false (it's true) that 3 equals 3.</font>
						</font>
					</p>
					
					<p>We learned that the expression <font class="bashcommand">-f FILE</font> tests if a file exists. If we want to test if a file doesn't exist, then we just need to test if <font class="bashcommand">-f FILE</font> is false.</p>

					<font class="bashcommand">
						<p>
							$ FILE="SomeFileThatExists.txt"<br>
							$ if [ -f ${FILE} ]<br>
							&gt; then<br>
							&gt; echo "The file exist"<br>
							&gt; fi <br>
							<font class="bashcommand-result">The file exist</font>
						</p>
						
						<p>
							The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
							<font class="bashcommand">$ [ -f ${FILE} ] &gt;&gt; echo "The file exist"</font><br>
							<font class="bashcommand-result">The file exist</font>
						</p>
						
						<p>
							$ FILE="SomeFileThatDoesntExist.txt"<br>
							$ if [ ! -f ${FILE} ]<br>
							&gt; then<br>
							&gt; echo "The file doesn't exist"<br>
							&gt; fi<br>
							<font class="bashcommand-result">The file doesn't exist</font>
						</p>
						
						<p>
							The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
							<font class="bashcommand">$ [ ! -f ${FILE} ] &gt;&gt; echo "The file doesn't exist"</font><br>
							<font class="bashcommand-result">The file doesn't exist</font>
						</p>
					</font>
					
					<p>
						<font class="example">[ EXPR1 ] || [ EXPR2 ]:</font>
						Test if any of the two expressions are true.
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ 2 -lt 3 ] || [ 4 -lt 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be echoed if any of the two expressions are true: 2&lt;3 OR 4&lt;3."<br>
							&gt; else<br>
							&gt; echo "This will be echoed if none of the two expressions are true"<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be echoed if any of the two expressions are true: 2&lt;3 OR 4&lt;3.</font> 
						</font>
					</p>
					
					<p>The previous example can also be written using a shorter syntax. When using multiple expressions, they will have to be encapsulated in parentheses using the following syntax: ( expressions ) &amp;&amp; what_to_do_if_true || what_to_do_if_false</p>
					
					<p>
						Shorter version:<br>
						<font class="bashcommand">
							$ ( [ 2 -lt 3 ] || [ 4 -lt 3 ] ) &amp;&amp; echo "This will be echoed if any of the two expressions are true: 2&lt;3 OR 4&lt;3." || echo "This will be echoed if none of the two expressions are true":<br>
							<font class="bashcommand-result">This will be echoed if any of the two expressions are true: 2&lt;3 OR 4&lt;3.</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ EXPR1 ] &amp;&amp; [ EXPR2 ]:</font>
						Test if the two expressions are true. The second expression, contrary to the previous example, has the negation (<font class="bashcommand">!</font>). So, the second expression is not testing if 4 is less than 3, it is testing if 4 is <b>NOT</b> less than 3. So, both of the expressions are true, because 4 is not less than 3, and 2 is less than 3. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be echoed if the two expressions are true."<br>
							&gt; else<br>
							&gt; echo "This will be echoed if one of the two expressions are false, or if both are false."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be echoed if the two expressions are true.</font> 
						</font>
					</p>
					
					<p>The previous example can also be written using a shorter syntax. Remember that when using multiple expressions, they will have to be encapsulated in parentheses using the following syntax: ( expressions ) &amp;&amp; what_to_do_if_true || what_to_do_if_false</p>
					
					<p>
						This is the shorter version:<br>
						<font class="bashcommand">
							$ ( [ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ] ) &amp;&amp; echo "This will be echoed if the two expressions are true." || echo "This will be echoed if one of the two expressions are false, or if both are false."<br>
							<font class="bashcommand-result">This will be echoed if the two expressions are true.</font> 
						</font>
					</p>
					
					<font class="example">Using the and (&amp;&amp;) and or (||) operands to test more than two conditions:</font>
					
					<p>
						Using &amp;&amp; to test more than two conditions:<br>
						You can combine more than two expressions. In the following example I am combining three. Because I am using the <b>AND</b> operator, the whole condition will test true <b>if and only if</b> all the three expressions are true. If one is false, then the whole expression will be false.  
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ] &amp;&amp; [ 4 -lt 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be echoed if all the three expressions are true."<br>
							&gt; else<br>
							&gt; echo "This will be echoed if any of the three expressions is false."<br> 
							&gt; fi<br>
							<font class="bashcommand-result">This will be echoed if any of the three expressions is false.</font> 
						</font>
					</p>
					
					<p>
						Let's take a look at why the whole expression evaluates false:<br>
						<font class="bashcommand">[ 2 -lt 3 ]</font>: This is true, 2 &lt; 3.<br>
						<font class="bashcommand">[ ! 4 -lt 3 ]</font>: This is true, 4 is not less than 3.<br> 
						<font class="bashcommand">[ 4 -lt 3 ]</font>: This is false, It is false that 4 be less than 3.<br>
						<font class="bashcommand">[ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ] &amp;&amp; [ 4 -lt 3 ]</font>: This is false because one of the three expressions is false. 
					</p>
					
					<p>The previous example can also be written using a shorter syntax. Remember that when using multiple expressions, they will have to be encapsulated in parentheses using the following syntax: ( expressions ) &amp;&amp; what_to_do_if_true || what_to_do_if_false</p>
					
					<p>
						This is the shorter version:</br>
						<font class="bashcommand">
							$ ( [ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ] &amp;&amp; [ 4 -lt 3 ] ) &amp;&amp; echo "This will be echoed if all the three expressions are true." || echo "This will be echoed if any of the three expressions is false."<br>
							<font class="bashcommand-result">This will be echoed if any of the three expressions is false.</font> 
						</font>
					</p>
					
					<p>
						Using <font class="bashcommand">||</font> to test more than two conditions:<br>
						This example is very similar than the previous one but instead of using the operator AND (<font class="bashcommand">&gt;&gt;</font>)), we are using the operator OR (<font class="bashcommand">||</font>). So, the whole expression will be true if ANY of the three expressions is true. Since the first two are true, then the result is true. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ 2 -lt 3 ] || [ ! 4 -lt 3 ] || [ 4 -lt 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be echoed if ANY of the three expressions is true."<br>
							&gt; else<br>
							&gt; echo "This will be echoed if all of the three expressions are false."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be echoed if ANY of the three expressions is true.</font>
						</font>
					</p>
					
					<p>The previous example can also be written using a shorter syntax. Remember that when using multiple expressions, they will have to be encapsulated in parentheses using the following syntax: ( expressions ) &amp;&amp; what_to_do_if_true || what_to_do_if_false</p>
					
					<p>
						This is the shorter version:<br>
						<font class="bashcommand">
							$ ( [ 2 -lt 3 ] || [ ! 4 -lt 3 ] || [ 4 -lt 3 ] ) &amp;&amp; echo "This will be echoed if ANY of the three expressions is true." || echo "This will be echoed if all of the three expressions are false."<br>
							<font class="bashcommand-result">This will be echoed if ANY of the three expressions is true.</font>
						</font>
					</p>
					
					<p>
						<font class="example">Combining &amp;&amp; and || into one expression:</font>
						When combining both operands (&amp;&amp;, ||), it is better to always use parenthesis to indicate the order in which you want the operations to be evaluated. In the following example we have three files. The path of the three files are saved in the variables <font class="bashcommand">${FILE1} ${FILE2}</font> and <font class="bashcommand">${FILE3}</font>. Files <font class="bashcommand">${FILE1}</font> and <font class="bashcommand">${FILE3}</font> exist, but <font class="bashcommand">${FILE2}</font> doesn't exist. We want to evaluate the following condition: Does <font class="bashcommand">${FILE3}</font> and one of the other two files exists?
					</p>
					
					<p>
						<font class="bashcommand">[ -f ${FILE3} ]</font> This condition is true because <font class="bashcommand">${FILE3}</font> exists.<br> 
						<font class="bashcommand">[ -f ${FILE2} ] || [ -f ${FILE1} ]</font> This condition is true because even though <font class="bashcommand">${FILE2}</font> doesn't exist, <font class="bashcommand">${FILE1}</font> does exist. And with an <font class="bashcommand">OR</font> (<font class="bashcommand">||</font>) we only need one of the expressions to be true.<br> 
						<font class="bashcommand">( [ -f ${FILE1} ] || [ -f ${FILE2} ] ) &amp;&amp; [ -f ${FILE3} ]</font> This is true because both of expressions are true.
					</p>
					
					<p>
						<font class="bashcommand">
						$ if ( [ -f ${FILE1} ] || [ -f ${FILE2} ] ) &amp;&amp; [ -f ${FILE3} ]<br>
						&gt; then<br>
						&gt; echo "The condition is true"<br>
						&gt; else<br>
						&gt; echo "The condition is false"<br>
						&gt; fi<br>
						<font class="bashcommand-result">The condition is true</font>
						</font>
					</p>
					
					<p>
						This is the shorter version for the previous command:<br>
						<font class="bashcommand">
						( [ -f ${FILE1} ] || [ -f ${FILE2} ] ) &amp;&amp; [ -f ${FILE3} ] &amp;&amp; echo "The condition is true" || echo "The condition is false"
						</font>
					</p>
					
					<p>In the following example, we want to include a subject if it is female and age less than six or male and age greater than ten. </p>
					
					<p>
						<font class="bashcommand">
							$ GENDER="MALE"<br>
							$ AGE=23<br>
							$ if ( [ "${GENDER}" == "FEMALE" ] && [ "${AGE}" -lt "6" ] ) || ( [ "${GENDER}" == "MALE" ] && [ "${AGE}" -gt "10" ] )<br>
							&gt; then<br>
							&gt; echo "Include subject"<br>
							&gt; else<br>
							&gt; echo "Exclude subject"<br>
							&gt; fi<br>
							<font class="bashcommand-result">Include subject</font>
						</font>
					</p>
 
		    </div>
		       
		    <div id="content7" class="hidden">
		    	<h2>7. Iteration</h2>
				<p>
					In the following section we will learn how to use loops to iterate through the content of arrays or through a list of files. However, we will leave the part of iterating through the content of a file for the next section (File manipulation). Iteration is basically the repetition of a process or group of commands on a list of items. For example, you might use iteration to repeat the same processing steps on the MRI images of a list of subjects, or to manipulate in the same way a list of files. It saves time because instead of typing the same command 100 times to do the exact same thing on 100 subjects, you type it just one time inside a loop. You will use loops (as well as condition-testing) in almost every script that you write.
				</p>
				
				<table>
						<tr>
							<th><b>Command</b></th>
							<th><b>Use</b></th>
							<th><b>Syntax</b></th>
						</tr>
						
						<tr>
							<td><font class="bashcommand">for</font></td>
							<td>For iterating over a series of items within a list (array).</td>
							<td>
								for item in list_of_items<br>
								do<br>
								&emsp;Commands to run on each item<br>
								done 
							</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">for</font></td>
							<td>For iterating through an index.</td>
							<td>
								for ((i=1; i<=64; i+=1))<br>
								do<br>
								&emsp;Commands to run on each iteration<br>
								done
							</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">while</font></td>
							<td>For iterating while a control expression (condition) is true.</td>
							<td>
								while condition_is_true<br>
								do<br>
								&emsp;Commands to run while the condition is true<br>
								done 
							</td>
						</tr>
				</table>
		    	
		    	<h3>7.1. The for loop</h3>
					<h4>Iterating through an array of words</h4>
		    		
					<p>
						In the following example we have an array with a list of subjects ID:<br>
						<font class="bashcommand">
						$ declare -a ARRAY=('SUBJ0' 'SUBJ9' 'SUBJ3' 'SUBJ4' 'SUBJ3') 
						</font>
					</p>
					
					<p>If we wanted to print the ID of each subject within the list without using a loop, we would have to type 5 different commands (imagine if you have 800 subjects?):</p>
					
					<p>
						<font class="bashcommand">
							$ echo ${ARRAY[0]}<br> 
							<font class="bashcommand-result">SUBJ0</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">SUBJ9</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">SUBJ3</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">SUBJ4</font><br>
							$ echo ${ARRAY[4]}<br>
							<font class="bashcommand-result">SUBJ3</font> 
						</font>
					</p>
					
					<p>If we use a loop, you will just need to write the command one time. In this example, with only five subjects it doesnt save too much lines of code. But normally you will be working with many more subjects than five.</p>
					
					<p>
						<font class="bashcommand">
							$ for ID in ${ARRAY[@]}<br>
							&gt;  do<br>
							&gt;  echo ${ID}<br>
							&gt;  done<br>
							<font class="bashcommand-result">
							SUBJ0<br>
							SUBJ9<br>
							SUBJ3<br>
							SUBJ4<br>
							SUBJ3  
							</font>
						</font>
					</p>
		    		
					<p>What this for loop does is iterate through every item in <font class="bashcommand">${ARRAY[@]}</font> (the items that would be listed if you typed echo <font class="bashcommand">${ARRAY[@]}</font>) and assign each item to the variable <font class="bashcommand">ID</font> during the corresponding loop. So, the loop will run 5 times. The first time it runs it will assign subject <font class="bashcommand">'SUBJ0'</font> to variable <font class="bashcommand">ID</font>, the second time subject <font class="bashcommand">'SUBJ9'</font>, etc.</p>

					<p>
						<font class="bashcommand">
							$ num=0<br>
							$ for ID in ${ARRAY[@]}<br>
							&gt;  do<br>
							&gt;  echo "Subject number ${num} is ${ID}"<br>
							&gt;  ((num++))<br>
							&gt;  done<br>
							<font class="bashcommand-result">
							Subject number 0 is SUBJ0<br>
							Subject number 1 is SUBJ9<br>
							Subject number 2 is SUBJ3<br>
							Subject number 3 is SUBJ4<br>
							Subject number 4 is SUBJ3 
							</font>
						</font>
					</p>
					
					<h4>Iterating through files using patterns</h4>
					<p>
						As we learned in the Arrays section, you can use patterns to create arrays. You can also use patterns to list files which path is very similar except for a few words. For example, if you have a folder located in the following path:<br>  
						/Users/MyUserName/Desktop/MyProjectFolder<br>
						And inside this folder you have 100 files named very similarly (only vary in one character):<br>
						DTI_SUBJ1.nii.gz<br>
						DTI_SUBJ2.nii.gz<br>
						DTI_SUBJ3.nii.gz<br>
						DTI_SUBJ4.nii.gz<br>
						DTI_SUBJ5.nii.gz<br> 
						...<br>
						DTI_SUBJ100.nii.gz<br>
						Then, you could echo the list of all those files by simply typing:<br>
						<font class="bashcommand">$ echo /Users/MyUserName/Desktop/MyProjectFolder/DTI_SUBJ*.nii.gz</font><br>
						The previous command matches all the file paths that contain any characters in the position where the asterisk is located.
					</p>
					
					<p>
						Or let's suppose that you have your subject's information organized in the following way:<br>
						You have your main subjects folder located in this path:<br>
						/Users/MyUserName/Desktop/MyProjectFolder<br>
						Then, inside that folder you have one folder per subject:<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject1<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject2<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject3<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject4<br>
						...<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject100<br>
						And inside each subject folder, you have the following files:<br>
						DTI.nii.gz<br>
						ANAT.nii.gz<br>
						LGN.nii.gz 
					</p>
					
					<p>
						So, if you wanted to obtain the list of the DTI.nii.gz files for all subjects, you could type:<br> 
						<font class="bashcommand">echo /Users/MyUserName/Desktop/MyProjectFolder/Subject*/DTI.nii.gz</font><br>
						Because the path of the DTI of all subjects is the same except for the subject number, then you create the pattern by substituting the part that changes by an asterisk <font class="bashcommand">*</font>. 
					</p>
					
					<p>
						When using the asterisk, it will select all files that contain any amount of characters in that position. But if you want to restrict the search to a specific amount of characters, you could also use the interrogation character.
					</p>
					
					<p>
						For example, let's supose you have a main folder located in the folowing path:<br>
						/MyComputer/MyUser/MyDocuments/MyFolder<br>
						And inside that folder you have 100 files named:<br>
						myFile001.txt<br>
						myFile002.txt<br>
						...<br>
						myFile099.txt<br>
						myFile100.txt
					</p>
					
					<p>You want to iterate through the files myFile001.txt to myFile009.txt. All those files have the exact same path and name except for exactly one character. So, you can replace that character by an interrogration:</p>
					
					<p>	
						<font class="bashcommand">
							$ for f in /MyComputer/MyUser/MyDocuments/MyFolder/myFile00?.txt<br>
							&gt;  do<br>
							&gt;  echo $f<br>
							&gt;  done<br>
							<font class="bashcommand-result">
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile001.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile002.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile003.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile004.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile005.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile006.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile007.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile008.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile009.txt
							</font>
						</font>
					</p>
					
					<p>
						You could choose to print the results into a file instead of the command prompt. This can be easily achieved using the symbol <font class="bashcommand">&gt;&gt;</font>. After running the following loop, you will not see any output in the command line, the path of the nine files will be saved in output.txt:<br>
						The command <font class="bashcommand">cat ${maindir}output.txt</font> prints the content of this output file.
					</p>
					
					<p>
						<font class="bashcommand">
							$ maindir=/MyComputer/MyUser/MyDocuments/MyFolder/<br>
							$ for f in ${maindir}myFile00?.txt<br>
							&gt;  do<br>
							&gt;  echo $f &gt;&gt; ${maindir}output.txt<br>
							&gt;  done<br>
							$ cat ${maindir}output.txt<br>
							<font class="bashcommand-result">
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile001.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile002.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile003.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile004.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile005.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile006.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile007.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile008.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile009.txt
							</font>
						</font>
					</p>
					
					<h4>Iterating through files in your current directory</h4>
					<p>To know the current directory in which you are located in the command line, type <font class="bashcommand">pwd</font>. In the following example we want to we want to perform some action on all the files inside the current directory. To get the list of those files we use the command <font class="bashcommand">ls</font>.</p>
					
					<p>
						<font class="bashcommand">
						$ pwd<br>
						<font class="bashcommand-result">/path/to/my/current/directory</font><br>
						$ for f in $( ls )<br>
						&gt;  do<br>
						&gt;  echo "Do something with this file: ${f}"<br>
						&gt;  done
						</font>
					</p>
					
		    	<h3>7.2. From for to while</h3>
		    		<p>Every loop that you write using the for command, can also be written using the while command. The results will be the same but sometimes one of them will be more efficient and easier to code than the other. In general, the for command is a lot easier to use and understand. However:</p>

					<ul>
					  <li>You should use the <b>for</b> command when you want to iterate through <b>all the elements</b> of an array.</li>
					  <li>You should use the <b>while</b> command when you want to iterate through <b>a limited number of elements within the array.</b></li>
					  <li>You should use the <b>while</b> command when you want to <b>iterate through more than one array</b> or while <b>several conditions should be met</b>.</li>
					</ul>
					
					<p>The following example shows how a for loop can be converted into a while loop. The objective of this piece of code is to print the elements of an array.</p>
		    		
					<p>
						<font class="example">From for to while</font>
						<font class="bashcommand">$ declare -a ARRAY=('SUBJ0' 'SUBJ9' 'SUBJ3' 'SUBJ4' 'SUBJ3')</font>
					</p>
					
					<table>
						<tr>
							<th><b>Using a for loop</b></th>
							<th><b>Using a while loop</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">
									$ for E in ${ARRAY[@]}<br>
									&gt;  do<br>
									&gt;  echo ${E}<br>
									&gt;  done<br>
									<font class="bashcommand-result"> 
									SUBJ0<br>
									SUBJ9<br>
									SUBJ3<br>
									SUBJ4<br>
									SUBJ3  
									</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ SIZE=${#ARRAY[@]} <br>
									$ i=0 <br>
									$ while [ ${i} -lt ${SIZE} ] <br>
									&gt;  do <br>
									&gt;  echo ${ARRAY[${i}]} <br>
									&gt;  ((i++)) <br>
									&gt;  done <br>
									<font class="bashcommand-result">
									SUBJ0 <br>
									SUBJ9 <br>
									SUBJ3 <br>
									SUBJ4 <br>
									SUBJ3 
									</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>In the previous example, both loops (the one in the left using a <b>for</b> and the one in the right using a <b>while</b>) iterate through the elements of an array and echoes them in the terminal window. However, there are some important differences:</p>
					
					<ul>
						<li>The <u>for loop</u> automatically stops when iteration reaches the end of the array. The <u>while loop</u> stops when the condition (<font class="bashcommand">[ ${i} -lt ${SIZE} ]</font>) evaluates false. This means that it will iterate as long as variable <font class="bashcommand">i</font> is less (<font class="bashcommand">-lt</font>) <font class="bashcommand">SIZE</font>. In the while loop, variable <font class="bashcommand">i</font> contains the index of each item during the iteration and variable <font class="bashcommand">SIZE</font> contains the size of the array. For this reason, <font class="bashcommand">((i++))</font> is included inside the while loop. <font class="bashcommand">((i++))</font> increments the value of <font class="bashcommand">i</font> in 1 on each iteration. If you didn't include this, bash would iterate forever, because you wouldn't be increasing the value of <font class="bashcommand">i</font> and it would always equal zero. Hence, it would never be less than the size of the array, so the condition that the while evaluates will never be false. Since while iterates as long as that condition is true, it would iterate forever.</li>
						<li>In the <u>for loop</u> each element of the array is saved in variable <font class="bashcommand">E</font>. However, you don't have to assign each value to the variable, it is done automatically. In the <u>while loop</u> the element in the position <font class="bashcommand">i</font> is being referenced with <font class="bashcommand">${ARRAY[${i}]}</font>.</li>
						<li>Off course, in this case as we want to iterate through all the elements of <font class="bashcommand">ARRAY</font>, it makes no sense to use the while loop. It requires more lines of code; it is easier to make mistakes and it is harder to understand. But this is a good example to show how it works. </li>
					</ul>
					
					<p>
						<font class="example">Printing the elements of an array and their position within the array</font>
						<font class="bashcommand">$ declare -a ARRAY=('SUBJ0' 'SUBJ9' 'SUBJ3' 'SUBJ4' 'SUBJ3')</font>
					</p>
					
					<table>
						<tr>
							<th><b>Using a for loop</b></th>
							<th><b>Using a while loop</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">
									$ i=0 <br>
									$ for ID in ${ARRAY[@]} <br>
									&gt;  do <br>
									&gt;  echo "Subject number ${i} is ${ID}" <br>
									&gt;  ((i++)) <br>
									&gt;  done <br>
									<font class="bashcommand-result"> 
									Subject number 0 is SUBJ0 <br>
									Subject number 1 is SUBJ9 <br>
									Subject number 2 is SUBJ3 <br>
									Subject number 3 is SUBJ4 <br>
									Subject number 4 is SUBJ3 
									</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ SIZE=${#ARRAY[@]} <br>
									$ i=0 <br>
									$ while [ ${i} -lt ${SIZE} ] <br>
									&gt;  do <br>
									&gt;  echo "Subject number ${i} is ${ARRAY[$i]}" <br>
									&gt;  ((i++)) <br>
									&gt;  done <br>
									<font class="bashcommand-result">
									Subject number 0 is SUBJ0 <br>
									Subject number 1 is SUBJ9 <br>
									Subject number 2 is SUBJ3 <br>
									Subject number 3 is SUBJ4 <br>
									Subject number 4 is SUBJ3 
									</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">Printing the first five files in the current directory</font>
						Previously we learned that the following loop would echo the path of all the files in the current directory: 
					</p>
					
					<p>
						<font class="bashcommand">
						$ for f in $( ls ) <br>
						&gt; do <br>
						&gt; echo "Do something with this file: ${f}" <br>
						&gt; done 
						</font>
					</p>
					
					<p>In this case, it makes no sense to use the while loop. However, if instead of echoing all the files inside the current directory you wanted to echo only the first five files, then you must use the while loop.</p>
					
					<table>
						<tr>
							<th><b>Preferably use a for loop</b></th>
							<th><b>Preferably use a while loop</b></th>
						</tr>
						
						<tr>
							<td>
								<p>This loop will print <b>all</b> the files in the current directory:</p>
								<p>
									<font class="bashcommand">
										$ for f in $( ls ) <br>
										&gt; do <br>
										&gt; echo ${f} <br>
										&gt; done <br>
										<font class="bashcommand-result">
										Applications <br>
										Library <br>
										Network <br>
										System <br>
										Users <br>
										Volumes <br>
										cores <br>
										dev <br>
										net <br>
										opt <br>
										bin <br>
										tmp 
										</font>
									</font>
								</p>
							</td>
							<td>
								<p>This loop will print <b>the first five</b> files in the current directory:</p>
								<p>
									<font class="bashcommand">
										$ i=0 <br>
										$ ARRAY=($( ls )) <br>
										$ while [ ${i} -le 4 ] <br>
										&gt; do <br>
										&gt; echo ${ARRAY[${i}]} <br>
										&gt; ((i++)) <br>
										&gt; done <br>
										<font class="bashcommand-result">
										Applications <br>
										Library <br>
										Network <br>
										System <br>
										Users 
										</font>
									</font>
								</p>
							</td>
						</tr>
						
						<tr>
							<td>
								<p>This loop will rename <b>all</b> the files in the current directory that end in .nii.gz. Before and after the loop I am printing the content of the folder to visualize the change. Command ls prints the content of the current directory:  </p>
								<p>
									<font class="bashcommand">
										$ ls <br>
										<font class="bashcommand-result">
										10132423423.nii.gz <br> 
										25675756756.nii.gz <br>
										36787686767.nii.gz <br>
										37456456456.nii.gz <br>
										39756756756.nii.gz <br>
										41786786677.nii.gz <br>
										</font>
										$ i=1 <br>
										$ for f in ./*.nii.gz <br>
										&gt; do <br>
										&gt; mv ${f} Subject_${i}.nii.gz <br>
										&gt; ((i++)) <br>
										&gt; done <br>
										$ ls <br>
										<font class="bashcommand-result">
										Subject_1.nii.gz <br>
										Subject_2.nii.gz <br>
										Subject_3.nii.gz <br>
										Subject_4.nii.gz <br>
										Subject_5.nii.gz <br>
										Subject_6.nii.gz 
										</font>
									</font>
								</p>
							</td>
							<td>
								<p>This loop will rename <b>the first three</b> files in the current directory that end in .nii.gz. Before and after the loop I am printing the content of the folder to visualize the change. Command ls prints the content of the current directory:</p>
								<p>
									<font class="bashcommand">
										$ ls 
										<font class="bashcommand-result">
										10132423423.nii.gz <br>
										25675756756.nii.gz <br>
										36787686767.nii.gz <br>
										37456456456.nii.gz <br>
										39756756756.nii.gz <br>
										41786786677.nii.gz <br>
										</font>
										$ i=0 <br>
										$ ARRAY=($( ls ./*.nii.gz )) <br>
										$ while [ ${i} -le 2 ] <br>
										&gt; do <br>
										&gt; mv ${ARRAY[${i}]} ./Subject_$((++i)).nii.gz <br>
										&gt; done <br>
										$ ls <br>
										<font class="bashcommand-result">
										Subject_1.nii.gz <br>
										Subject_2.nii.gz <br>
										Subject_3.nii.gz <br>
										37456456456.nii.gz <br>
										39756756756.nii.gz <br>
										41786786677.nii.gz 
										</font>
									</font>
								</p>
							</td>
						</tr>
					</table>
					

		    	<h3>7.3. The while loop</h3>
					<h4>Using the while loop to iterate through more than one array</h4>
					
		    		<p>As previously mentioned, when you are iterating through more than one array you should use the while loop instead of the for loop.</p>
		    
					<p>
						<font class="example">Iterating through two arrays at the same time</font>
						In the following example there are two arrays (<font class="bashcommand">ID</font> and <font class="bashcommand">VISIT</font>), which contain a list of subject IDs and visit number respectively. The loop iterates through both arrays (until it reaches the end of one or the other) and saves the information extracted from both arrays into a text file. Then, it prints the content of the text file (test.txt) using the command cat, which will be explained in detail in the following chapter (File manipulation). 
					</p>
					
					<p>This while loop will run as long as the two conditions (<font class="bashcommand">[ ${i} -lt ${SIZE_ID} ]</font>, <font class="bashcommand">[ ${i} -lt ${SIZE_VISIT} ]</font>) that are being evaluated be true. This means, as long as variable <font class="bashcommand">i</font> have value less than (<font class="bashcommand">-lt</font>) the size of <font class="bashcommand">ID</font> and <font class="bashcommand">VISIT</font>. So, as soon as its value be greater than <font class="bashcommand">SIZE_ID</font> or <font class="bashcommand">SIZE_VISIT</font>, it will stop. In this case both arrays have the same size. Again, it is extremely important to not forget the line <font class="bashcommand">((i++))</font>, otherwise, it will loop forever (you can always break a loop with Control + C). </p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ID=('SUBJ0' 'SUBJ1' 'SUBJ2' 'SUBJ3' 'SUBJ4' 'SUBJ5' 'SUBJ6') <br>
							$ declare -a VISIT=('V1' 'V1' 'V2' 'V1' 'V2' 'V2' 'V3') <br>
							$ SIZE_ID=${#ID[@]} <br>
							$ SIZE_VISIT=${#VISIT[@]} <br>
							$ i=0 <br>
							$ while [ ${i} -lt ${SIZE_ID} ] && [ ${i} -lt ${SIZE_VISIT} ] <br>
							&gt; do <br>
							&gt; echo "${ID[${i}]}_${VISIT[${i}]}" &gt;&gt; test.txt <br>
							&gt; ((i++)) <br>
							&gt; done <br>
							$ cat test.txt <br>
							<font class="bashcommand-result">
							SUBJ0_V1 <br>
							SUBJ1_V1 <br>
							SUBJ2_V2 <br>
							SUBJ3_V1 <br>
							SUBJ4_V2 <br>
							SUBJ5_V2 <br>
							SUBJ6_V3 
							</font>
						</font>
					</p>
					
					<p>
						<font class="example">Inverting an array</font>
						In this example, initially there is only one array, but after the code is executed there will be two arrays. The second array will be the inversion of the first one. The code will iterate starting at the end of the array and finishing at the beginning. In each iteration it will copy the current value into the new array. It will start adding items at the beginning of the new array (in the index 0). For this purpose, there will be two variables. Variable <font class="bashcommand">i</font>, which will be initialized with value <font class="bashcommand">$(( ${#ARRAY[@]}  1 ))</font> (the size of the initial array minus one) and will represent the position in which the loop is iterating in the original array. In each loop <font class="bashcommand">i</font> will decrease its value in 1 until it reaches 0. And variable <font class="bashcommand">j</font>, which will be initialized with value 0 and will represent the position in which the loop is iterating in the inverted array. In each loop <font class="bashcommand">j</font> will increase its value until it reaches the size of the original array (when all the values would have finished being copied). So, the while will loop as long as variable <font class="bashcommand">i</font> have value greater or equal (<font class="bashcommand">-ge</font>) to 0. 
					</p>
					
					<p>Variable <font class="bashcommand">i</font> is initialized with value equal to the size of the array minus one instead of the size of the array because remember that the first index of an array is 0, so the last one is the size minus one.</p>
					
					<p>
						Order of values in the original array: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.<br>
						Order of values in the inverted array: 10, 9, 8, 7, 6, 5, 4, 3, 2, 1. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=('1' '2' '3' '4' '5' '6' '7' '8' '9' '10') <br>
							$ i=$(( ${#ARRAY[@]} - 1 )) <br>
							$ j=0 <br>
							$ while [ ${i} -ge 0 ] <br>
							&gt; do <br>
							&gt; echo "Copying element in position ${i} from the original array into position ${j} of the new array..." <br>
							&gt; INV_ARRAY[$((j++))]=${ARRAY[$((i--))]} <br>
							&gt; done <br>
							<font class="bashcommand-result">
							Copying element in position 9 from the original array into position 0 of the new array... <br>
							Copying element in position 8 from the original array into position 1 of the new array... <br>
							Copying element in position 7 from the original array into position 2 of the new array... <br>
							Copying element in position 6 from the original array into position 3 of the new array... <br>
							Copying element in position 5 from the original array into position 4 of the new array... <br>
							Copying element in position 4 from the original array into position 5 of the new array... <br>
							Copying element in position 3 from the original array into position 6 of the new array... <br>
							Copying element in position 2 from the original array into position 7 of the new array... <br>
							Copying element in position 1 from the original array into position 8 of the new array... <br>
							Copying element in position 0 from the original array into position 9 of the new array... <br>
							</font>
							$ echo ${INV_ARRAY[@]} <br>
							<font class="bashcommand-result">
							10 9 8 7 6 5 4 3 2 1 
							</font>
						</font>
					</p>
					
					<p>The command <font class="bashcommand">INV_ARRAY[$((j++))]=ARRAY[$((i--))]</font> is doing three things: assigning the element of <font class="bashcommand">ARRAY</font> in position <font class="bashcommand">i</font> to <font class="bashcommand">INV_ARRAY</font> in position <font class="bashcommand">j</font>, incrementing <font class="bashcommand">j</font> in one, and decreasing <font class="bashcommand">i</font> in one. It is equivalent to this set of instructions:</p>
					
					<p>
						<font class="bashcommand">
							INV_ARRAY[${j}]=ARRAY[${i}] <br>
							((j++)) <br>
							((i--)) 
						</font>
					</p>
					
					<h4>Using the while loop to iterate when several conditions should be met</h4>
					
					<p>In the following example there is an array of subject IDs (<font class="bashcommand">SUBJECTS</font>). Some of those subjects are controls and their ID starts with the letter C, other subjects are patients and their ID starts with the letter P. The array is organized so that the controls go before the patients. The loop will copy only the controls into a new array (<font class="bashcommand">CONTROLS</font>). So, there are two conditions to be met so that the loop continues to run: the index variable <font class="bashcommand">i</font> be less than the size of <font class="bashcommand">SUBJECTS</font> (<font class="bashcommand">${#SUBJECTS[@]}</font>), and the current element (<font class="bashcommand">SUBJECTS[${i}]</font>) start with the letter C. To get the first letter of the current element you must use the previously learned syntax to extract a sub-string: <font class="bashcommand">${STRING:START:NUM}</font>.</p>
					
					<p>
						The first condition (iterate while <font class="bashcommand">i</font> less than the size of the array <font class="bashcommand">SUBJECTS</font>) is written like this:<br>
						<font class="bashcommand">[ ${i} -lt ${#SUBJECTS[@]} ]</font>.
					</p>
					
					<p>
						The second condition (iterate while the current element in the loop starts with the letter C) is written like this:<br>
						<font class="bashcommand">
							$ declare -a SUBJECTS=('C01' 'C02' 'C03' 'C04' 'C05' 'C06' 'P07' 'P08' 'P09' 'P10') <br>
							$ i=0 <br>
							$ while [ ${i} -lt ${#SUBJECTS[@]} ] && [ "${SUBJECTS[${i}]:0:1}" == "C" ] <br>
							&gt; do <br>
							&gt; CONTROLS[${i}]=${SUBJECTS[$((i++))]} <br>
							&gt; done <br>
							$ echo ${CONTROLS[@]} <br>
							<font class="bashcommand-result">C01 C02 C03 C04 C05 C06</font>
						</font>
					</p>
			</div>
		       
		    <div id="content8" class="hidden">
		    	<h2>8. General file manipulation</h2>
		    	
		    	<h3>8.1. Basic concepts and simple commands</h3>
					<h4>The absolute path of a file</h4>

		    		<p>
						The absolute or full path of a file specifies its unique location in the file system, its name and extension. The absolute path of every file is different and constant. It will always be the same regardless of the current directory in which you are working (unless you move the file). This path follows a hierarchy of directories where the file is located, separating each directory with the delimiting character, which is the slash (<font class="bashcommand">/</font>) for Macintosh and Linux and the backslash (<font class="bashcommand">\</font>) for Windows. For example, a text file named file.txt located in the Desktop of a Mac computer, will commonly have an absolute path similar to this:<br> 
						<font class="bashcommand">/Users/user_name/Desktop/file.txt</font><br>
						To find the absolute path of a file you can drag and drop it into the Terminal. 
					</p>
					
					<p>
						For example, if this is the absolute path of a file: <br>
						<font class="bashcommand">/Users/user_name/Desktop/SomeFolder/Subfolder/file.txt</font> <br>
						It means that in the user Desktop there is a folder called <font class="bashcommand">SomeFolder</font>, inside <font class="bashcommand">SomeFolder</font> there is another folder called <font class="bashcommand">Subfolder</font>, and inside <font class="bashcommand">Subfolder</font> is located the corresponding file, with name <font class="bashcommand">file</font> and extension <font class="bashcommand">txt</font>. Inside a directory there can be two files with the same name but in this case, they must have a different extension. There cannot be two files with both the same name and same extension inside the same folder. 
					</p>
					
					<h4>The relative path of a file</h4>
					
					<p>The relative path of a file starts from the current working directory and represents the location of a specific file relative to this directory. It is always changing as it depends on what directory you are located in the terminal, but is a lot shorter than the absolute path.</p>
					
					<p>
						If the absolute path of a file is the following, meaning the file is located in the Desktop:<br>
						<font class="bashcommand">/Users/user_name/Desktop/file.txt</font><br>
						And the user current working directory is the desktop, then the relative path of the file is:<br>
						<font class="bashcommand">file.txt</font> or <font class="bashcommand">./file.txt</font><br>
						Since the file is located in the current directory, the user can use just the name and extension for the relative path. Adding <font class="bashcommand">./</font> doesn't do anything because <font class="bashcommand">./</font> represents the current directory. 
					</p>
					
					<p>
						The following relative paths represent files that are located in the current working directory: <br>
						<font class="bashcommand">
						File1.txt <br>
						File2.nii.gz <br>
						./File3.nii <br>
						./File4.docx
						</font>
					</p> 
					
					<p>
						The absolute path of these files will be something similar to this (for Mac users), if the current directory is the Desktop: <br>
						<font class="bashcommand">
						/Users/username/Desktop/File1.txt <br>
						/Users/username/Desktop/File2.nii.gz <br>
						/Users/username/Desktop/File3.nii <br>
						/Users/username/Desktop/File4.docx 
						</font>
					</p>
					
					<p>
						The same way as a dot (<font class="bashcommand">.</font>) represents the current directory in a relative path, two dots (<font class="bashcommand">..</font>) represent the parent directory. So, if the absolute path of my current working directory is the following:<br> 
						<font class="bashcommand">/Users/user_name/Desktop/SomeFolder</font><br>
						I can refer to files located in the parent directory (Desktop) using the double dots. So, all these files are located in the Desktop (the same as SomeFolder): <br>
						<font class="bashcommand">
						../FileA.txt <br>
						../FileB.txt <br>
						../FileC.txt 
						</font>
					</p>
					
					<h4>Some tips about file paths</h4>
					
					<p>Both the absolute and relative paths are used to reference files when doing operations with it, but I generally prefer to use the absolute path when writing scripts because that way my script will run with no issues independently of my working directory. Never the less, when doing fast operations in the Terminal (like renaming or copying a file), then it's faster to use the relative path.</p>
					
					<p>
						It is also recommended to not use spaces or any other special characters when naming a file, because it makes it harder to write the path of that file. For example, if I have a file named Some File.txt in my Desktop (on a Mac), this is not the absolute path:<br> 
						<font class="bashcommand">/Users/user_name/Desktop/Some File.txt</font> <br>
						Instead, the absolute path will be: <br>
						<font class="bashcommand">/Users/user_name/Desktop/Some\ File.txt</font>
					</p>
		    		
					<p>The backslash is telling us to not treat the space as a special character but instead as part of the file path. This works the same way in Linux and MacOS.</p>
					
					<p>
						The same will happen with a file which name contains the dollar sign (which is a special character). For example, if in the Desktop there is a folder named <font class="bashcommand">untitled$folder</font>, this is <b>not</b> the absolute path: <br>
						<font class="bashcommand">/Users/user_name/Desktop/untitled$folder </font> <br>
						Instead, the absolute path will be: <br>
						<font class="bashcommand">/Users/user_name/Desktop/untitled\$folder </font>
					</p>
					
					<p>Again, the backslash is indicating us to treat the special character (<font class="bashcommand">$</font>) as part of the file name and not as the beginning of a variable name (which is the normal use of <font class="bashcommand">$</font> in bash). If we don't use the backslash before the dollar sign, bash will try to find a variable called folder (<font class="bashcommand">$folder</font> normally refers to the value of folder as a variable, not a string). If that variable doesn't exist, then bash will read <font class="bashcommand">/Users/user_name/Desktop/untitled$folder</font> as <font class="bashcommand">/Users/user_name/Desktop/untitled</font>, replacing <font class="bashcommand">$folder</font> for an empty space.</p>
					
					<p>In the following sections you will learn how the absolute and relative paths are used to manipulate files in <b>MacOS and Linux</b>.</p>
					
					<h4>pwd command</h4>
					<p>Prints the absolute path of the current working directory. </p>
					
					<h4>ls command</h4>
					<p>Lists the files and folders inside the specified directory. If no directory is specified after <font class="bashcommand">ls</font>, then it prints the contents of the current folder. If no flag is used, it lists the files in bare format (without any details such as modified date and time or permissions). Depending which flag is used (or a combination of flags), then specific information about the file will be displayed. The following table is taken from manual of the ls command as displayed in the command line.</p>

					<table>
						<tr>
							<th>Flag</th>
							<th>Usage</th>
						</tr>
						<tr>
							<td><font class="bashcommand">-1</font></td>
							<td>Force output to be one entry per line.  This is the default when output is not to a terminal.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-A</font></td>
							<td>List all entries except for (<font class="bashcommand">.</font>) and (<font class="bashcommand">..</font>). Always set for the super-user.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-a</font></td>
							<td>Include directory entries whose names begin with a dot (<font class="bashcommand">.</font>). Typically, these are configuration files for applications.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-B</font></td>
							<td>Force printing of non-printable characters in file names as \xxx, where xxx is the numeric value of the character in octal.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-b</font></td>
							<td>As <font class="bashcommand">-B</font>, but use C escape codes whenever possible.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-C</font></td>
							<td>Force multi-column output; this is the default when output is to a terminal.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-c</font></td>
							<td>Directories are listed as plain files (not searched recursively).</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-F</font></td>
							<td>Display a slash (<font class="bashcommand">/</font>) immediately after each pathname that is a directory, an asterisk (<font class="bashcommand">*</font>) after each that is executable, an at sign (<font class="bashcommand">@</font>) after each symbolic link, an equal sign (<font class="bashcommand">=</font>) after each socket, a percent sign (<font class="bashcommand">%</font>) after each whiteout, and a vertical bar (<font class="bashcommand">|</font>) after each that is a FIFO.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-f</font></td>
							<td>Output is not sorted. This option turns on the <font class="bashcommand">-a</font> option.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-G</font></td>
							<td>Enable colorized output.  This option is equivalent to defining <font class="bashcommand">CLICOLOR</font> in the environment.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-H</font></td>
							<td>Symbolic links on the command line are followed. This option is assumed if none of the <font class="bashcommand">-F</font> or <font class="bashcommand">-l</font> options are specified.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-i</font></td>
							<td>For each file, print the files file serial number (inode number). Each object in the file system is represented by an inode.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-k</font></td>
							<td>If the <font class="bashcommand">-s</font> option is specified, print the file size allocation in kilobytes, not blocks. This option overrides the environment variable <font class="bashcommand">BLOCKSIZE</font>.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-L</font></td>
							<td>Follow all symbolic links to final target and list the file or directory the link references rather than the link itself. This option cancels the <font class="bashcommand">-P</font> option.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-l</font></td>
							<td>List in long format.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-l@</font></td>
							<td>Display extended attribute keys and sizes in long output.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-le</font></td>
							<td>Print the Access Control List (ACL) associated with the file, if present, in long output.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-lg</font></td>
							<td>This option is only available for compatibility with POSIX; it is used to display the group name in the long format output (the owner name is suppressed).</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-lh</font></td>
							<td>Use unit suffixes when displaying the information in long output: Byte, Kilobyte, Megabyte, Gigabyte, Terabyte and Petabyte, in order to reduce the number of digits to three or less using base 2 for sizes.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-ln</font></td>
							<td>Display user and group IDs numerically, rather than converting to a user or group name in a long output.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-lO</font></td>
							<td>Include the file flags in a long output.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-lT</font></td>
							<td>Display complete time information for the file, including month, day, hour, minute, second, and year.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-m</font></td>
							<td>Stream output format; list files across the page, separated by commas.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-o</font></td>
							<td>List in long format, but omit the group id.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-P</font></td>
							<td>If argument is a symbolic link, list the link itself rather than the object the link references. This option cancels the <font class="bashcommand">-H</font> and <font class="bashcommand">-L</font> options.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-p</font></td>
							<td>Write a slash (<font class="bashcommand">/</font>) after each filename if that file is a directory.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-q</font></td>
							<td>Force printing of non-graphic characters in file names as the interrogation character (<font class="bashcommand">?</font>); this is the default when output is to a terminal.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-R</font></td>
							<td>Recursively list subdirectories encountered.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-r</font></td>
							<td>Reverse the order of the sort to get reverse lexicographical order, or the oldest entries first (or largest files last, if combined with sort by size).</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-S</font></td>
							<td>Sort files by size.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-s</font></td>
							<td>Display the number of file system blocks actually used by each file, in units of 512 bytes, where partial units are rounded up to the next integer value.  If the output is to a terminal, a total sum for all the file sizes is output on a line before the listing. The environment variable <font class="bashcommand">BLOCKSIZE</font> overrides the unit size of 512 bytes.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-t</font></td>
							<td>Sort by time modified (most recently modified first) before sorting the operands by lexicographical order.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-u</font></td>
							<td>Use time of last access, instead of last modification of the file for sorting (<font class="bashcommand">-t</font>) or long printing (0<font class="bashcommand">-l</font>)</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-U</font></td>
							<td>Use time of file creation, instead of last modification for sorting (<font class="bashcommand">-t</font>) or long output (<font class="bashcommand">-l</font>).</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-v</font></td>
							<td>Force unedited printing of non-graphic characters; this is the default when output is not to a terminal.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-W</font></td>
							<td>Display whiteouts when scanning directories.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-w</font></td>
							<td>Force raw printing of non-printable characters.This is the default when output is not to a terminal.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-x</font></td>
							<td>The same as <font class="bashcommand">-C</font>, except that the multi-column output is produced with entries sorted across, rather than down the columns.</td>
						</tr>
					</table>
					
					<p>The following examples show the usage of the flags presented in the previous table and details on the results that can be obtained when using the command ls together with those flags.</p>
					
			    		<p><font class="example">ls with no flags</font></p>
			    
			    		<p>Show the list of files in the current working directory:</p>
			    		<p><font class="bashcommand">
						$ ls<br>
						<font class="bashcommand-result">
						Applicationshome<br>
						Libraryinstaller.failurerequests<br>
						Networknet<br>
						Subjectsopt<br>
						Usersprivate<br>
						Volumessbin<br>
						binmp<br>
						coresusr<br>
						devvar<br>
						etc 
						</font>
					</font></p>
			    
			    		<p><font class="example">Show the list of files in a different directory using the absolute path of that directory</font></p>
			    
			    		<p><font class="bashcommand">
						$ ls /Volumes/MyExternalDrive<br>
						<font class="bashcommand-result">
						ArticlesMRIdata SharedFolder 
						</font>
			    		</font></p>
			    
			    		<p><font class="example">Show the list of files in a subfolder (Applications) using the relative path</font></p>
			    
			    		<p><font class="bashcommand">
						$ ls Applications/<br>
						<font class="bashcommand-result">
						Calculator.app<br>
						Calendar.app<br>
						Chess.app<br>
						Dashboard.app<br> 
						Dictionary.app<br>
						EndNote X7<br>
						EndNote X8<br>
						FaceTime.app<br>
						Firefox.app<br>
						IBM<br>
						Image Capture.app<br>
						Launchpad.app<br>
						MATLAB_R2014b.app 
						</font>
					</font></p>
			    
			    		<p><font class="example">ls -l</font></p>
			    
			    		<p>When using the flag <font class="bashcommand">-l</font>, bash will not only show the list of files but also a description for each file. The output will be organized in columns, each one with a specific meaning. Most of these meanings will be discussed later as they are part of more advanced topics related to file manipulation.</p>
			    
			    		<p>
						<font class="bashcommand">
							$ ls -l /Volumes/MyExternalDrive<br> 
							<font class="bashcommand-result">Total 0</font>
						</font>
						<table class="ghostTable">
							<tr>
								<td><font class="bashcommand bashcommand-result">drwxr-xr-x</font></td>
								<td><font class="bashcommand bashcommand-result">22</font></td>
								<td><font class="bashcommand bashcommand-result">myUser</font></td>
								<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
								<td><font class="bashcommand bashcommand-result">714</font></td>
								<td><font class="bashcommand bashcommand-result">Sep 4</font></td>
								<td><font class="bashcommand bashcommand-result">11:40</font></td>
								<td><font class="bashcommand bashcommand-result">Articles</font></td>
							</tr>

							<tr>
								<td><font class="bashcommand bashcommand-result">-rw-r--r--@</font></td>
								<td><font class="bashcommand bashcommand-result">1</font></td>
								<td><font class="bashcommand bashcommand-result">myUse</font></td>
								<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
								<td><font class="bashcommand bashcommand-result">51620</font></td>
								<td><font class="bashcommand bashcommand-result">Jan 14</font></td>
								<td><font class="bashcommand bashcommand-result">2017</font></td>
								<td><font class="bashcommand bashcommand-result">CV.docx</font></td>
							</tr>

							<tr>
								<td><font class="bashcommand bashcommand-result">-rw-r--r--</font></td>
								<td><font class="bashcommand bashcommand-result">1</font></td>
								<td><font class="bashcommand bashcommand-result">myUser</font></td>
								<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
								<td><font class="bashcommand bashcommand-result">137195</font></td>
								<td><font class="bashcommand bashcommand-result">Jan 14</font></td>
								<td><font class="bashcommand bashcommand-result">2017</font></td>
								<td><font class="bashcommand bashcommand-result">CV.pdf</font></td>
							</tr>

							<tr>
								<td><font class="bashcommand bashcommand-result">drwxr-xr-x</font></td>
								<td><font class="bashcommand bashcommand-result">28</font></td>
								<td><font class="bashcommand bashcommand-result">myUser</font></td>
								<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
								<td><font class="bashcommand bashcommand-result">952</font></td>
								<td><font class="bashcommand bashcommand-result">Sep 10</font></td>
								<td><font class="bashcommand bashcommand-result">09:04</font></td>
								<td><font class="bashcommand bashcommand-result">MRIdata</font></td>
							</tr>

							<tr>
								<td><font class="bashcommand bashcommand-result">drwxrwxrwx</font></td>
								<td><font class="bashcommand bashcommand-result">5</font></td>
								<td><font class="bashcommand bashcommand-result">myUser</font></td>
								<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
								<td><font class="bashcommand bashcommand-result">170</font></td>
								<td><font class="bashcommand bashcommand-result">Sep 4</font></td>
								<td><font class="bashcommand bashcommand-result">11:15</font></td>
								<td><font class="bashcommand bashcommand-result">SharedFolder</font></td>
							</tr>
						</table>
			    		</p>
			    
			    		<table>
						<tr>
							<th>Column #</th>
							<th>Column name</th>
							<th>Meaning</th>
						</tr>
						
						<tr>
							<td>1</td>
							<td>File type + permissions</td>
							<td>See below for the explanation of the output presented in this column (file type and permissions from the <font class="bashcommand">ls -l</font> command).<td>
						</tr>
						
						<tr>
							<td>2</td>
							<td>Link count</td>
							<td>The meaning of the output presented in this column will be discussed in the section "Symbolic links" of "File manipulation".<td>
						</tr>
						
						<tr>
							<td>3</td>
							<td>Owner name</td>
							<td>The meaning of the output presented in this column will be discussed in the chapter "File permissions". If the owner is unknown, the number ID is displayed.<td>
						</tr>
						
						<tr>
							<td>4</td>
							<td>Group name</td>
							<td>The meaning of the output presented in this column will be discussed in the chapter "File permissions". If the owner is unknown, the number ID is displayed.<td>
						</tr>
						
						<tr>
							<td>5</td>
							<td>File Size</td>
							<td>Number of bytes in the file. See the flag <font class="bashcommand">-lh</font> to output the size of the file in human-readable format. <td>
						</tr>
						
						<tr>
							<td>6</td>
							<td>Last modified date</td>
							<td>Abbreviated month and day-of-month when the file was last modified.<td>
						</tr>
						
						<tr>
							<td>7</td>
							<td>Last modified time</td>
							<td>Abbreviated hour and minute when the file was last modified in military format (24 hours). If the file was last modified more than six months before, then the year of the last modification is displayed instead of the hour and minute.<td>
						</tr>
						
						<tr>
							<td>8</td>
							<td>File name</td>
							<td>Name of the file with its extension.<td>
						</tr>
			    		</table>
			    
			    		<p>File type and permissions from the ls -l command:</p>
			    
			    		<p>The first character of the first column, where the file type and permissions are specified, describes the type of file. It is one of the following characters:</p>
			    
			    		<table>
						<tr>
							<th>Character</th>
							<th>File type</th>
						</tr>
						
						<tr>
							<td><font class="bashcommand">b</font></td>
							<td>Block special file: provide access to hardware devices.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">c</font></td>
							<td>Character special file: provide access to hardware devices.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">d</font></td>
							<td>Directory.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">l</font></td>
							<td>Symbolic link: a file that points to another file (a shortcut). It does not contain the data in the target file; it simply contains a pointer somewhere in the file system.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">s</font></td>
							<td>Socket link: file used for communication between processes.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">p</font></td>
							<td>FIFO: special file that can be opened by various processes for exchanging data.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">-</font></td>
							<td>Regular file.</td>
						</tr>
			    		</table>
			    
			    		<p>
						The next three characters show the owner permissions (the things that the user listed as the owner can do):<br>
						2<sup>nd</sup> character: will have value <font class="bashcommand">r</font> if the owner can read the file, <font class="bashcommand">-</font> otherwise.<br>
						3<sup>rd</sup> character: will have value <font class="bashcommand">w</font> if the file can be written by the owner, <font class="bashcommand">-</font> otherwise.<br>
						4<sup>th</sup> character: will have value <font class="bashcommand">-</font> if the file is not executable by the owner. It will have value <font class="bashcommand">x</font>, <font class="bashcommand">s</font> or <font class="bashcommand">S</font> if it is executable by the owner or if that user can search the directory. 
			    		</p>
			    
			    		<p>
						The following three characters show the group permissions:<br>
						5<sup>th</sup> character: will have value <font class="bashcommand">r</font> if the users that are part of the group listed in the group name column can read the file, <font class="bashcommand">-</font> otherwise.<br>
						6<sup>th</sup> character: will have value <font class="bashcommand">w</font> if the users that are part of the group listed in the group name column can write the file, <font class="bashcommand">-</font> otherwise.<br>
						7<sup>th</sup> character: will have value <font class="bashcommand">-</font> if the file is not executable by the users that are part of the group listed in the group name column can write the file. It will have value <font class="bashcommand">x</font>, <font class="bashcommand">s</font> or <font class="bashcommand">S</font> if it is executable by these users of if they can search the directory. 
			    		</p>
			    
			    		<p>The rest of the characters represent other permissions or whether the file has extended attributes or security information. The permissions can be modified for any file, this will be explained in the chapter File permissions. Additionally, the total number of 512-byte blocks used by the files in the directory is displayed on a line by itself, immediately before the lines that contain the information of each file in the directory.</p>
			    
			    		<p>In the previous example, the first line of the result is, this means that the folder occupies less than one 512-block.</p>
			    
			    		<p>The second line is the following:</p>
					
			    		<font class="bashcommand-result"> 
						<table class="ghostTable">
							<tr>
								<td><font class="bashcommand">drwxr-xr-x</font></td>
								<td><font class="bashcommand">22</font></td>
								<td><font class="bashcommand">myUser</font></td>
								<td><font class="bashcommand">UserGroup</font></td>
								<td><font class="bashcommand">714</font></td>
								<td><font class="bashcommand">Sep 4</font></td>
								<td><font class="bashcommand">11:40</font></td>
								<td><font class="bashcommand">Articles</font></td>
							</tr>
						</table>
					</font>
			    
			    		<p>This means that <font class="bashcommand-result">Articles</font> is a directory, modified the last on September 4 of the current year at 11:40am (if it was pm, the value would be 23:40 instead of 11:40). This folder is owned by the user <font class="bashcommand-result">myUser</font>. This user can read, write and navigate through the folder. The other users can read and navigate the folder but cannot write on it.</p>
			    
				<p><font class="example">ls -l</font></p>

				<p>The information displayed in the 5<sup>th</sup> column (file size) of the previous example is difficult to interpret by a human. In order to see this information in a human-readable format, it is only necessary to add an <font class="bashcommand">h</font> to the <font class="bashcommand">-l</font> flag.</p>
		    	
				<font class="bashcommand bashcommand-result">
					$ ls -lh /Volumes/MyExternalDrive<br>
					Total 0<br>
				</font>
				<table class="ghostTable">
					<tr>
						<td><font class="bashcommand bashcommand-result">drwxr-xr-x</font></td>
						<td><font class="bashcommand bashcommand-result">22</font></td>
						<td><font class="bashcommand bashcommand-result">myUser</font></td>
						<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
						<td><font class="bashcommand bashcommand-result">714B</font></td>
						<td><font class="bashcommand bashcommand-result">Sep 4</font></td>
						<td><font class="bashcommand bashcommand-result">11:40</font></td>
						<td><font class="bashcommand bashcommand-result">Articles</font></td>
					</tr>
					<tr>
						<td><font class="bashcommand bashcommand-result">-rw-r--r--@</font></td>
						<td><font class="bashcommand bashcommand-result">1</font></td>
						<td><font class="bashcommand bashcommand-result">myUser</font></td>
						<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
						<td><font class="bashcommand bashcommand-result">50K</font></td>
						<td><font class="bashcommand bashcommand-result">Jan 14</font></td>
						<td><font class="bashcommand bashcommand-result">2017</font></td>
						<td><font class="bashcommand bashcommand-result">CV.docx</font></td>
					</tr>
					<tr>
						<td><font class="bashcommand bashcommand-result">-rw-r--r--</font></td>
						<td><font class="bashcommand bashcommand-result">1</font></td>
						<td><font class="bashcommand bashcommand-result">myUser</font></td>
						<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
						<td><font class="bashcommand bashcommand-result">134K</font></td>
						<td><font class="bashcommand bashcommand-result">Jan 14</font></td>
						<td><font class="bashcommand bashcommand-result">2017</font></td>
						<td><font class="bashcommand bashcommand-result">CV.pdf</font></td>
					</tr>
					<tr>
						<td><font class="bashcommand bashcommand-result">drwxr-xr-x</font></td>
						<td><font class="bashcommand bashcommand-result">28</font></td>
						<td><font class="bashcommand bashcommand-result">myUser</font></td>
						<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
						<td><font class="bashcommand bashcommand-result">952B</font></td>
						<td><font class="bashcommand bashcommand-result">Sep 10</font></td>
						<td><font class="bashcommand bashcommand-result">09:04</font></td>
						<td><font class="bashcommand bashcommand-result">MRIdata</font></td>
					</tr>
					<tr>
						<td><font class="bashcommand bashcommand-result">drwxrwxrwx</font></td>
						<td><font class="bashcommand bashcommand-result">5</font></td>
						<td><font class="bashcommand bashcommand-result">myUser</font></td>
						<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
						<td><font class="bashcommand bashcommand-result">170B</font></td>
						<td><font class="bashcommand bashcommand-result">Sep 4</font></td>
						<td><font class="bashcommand bashcommand-result">11:15</font></td>
						<td><font class="bashcommand bashcommand-result">SharedFolder</font></td>
					</tr>
				</table>

				<p>When using the <font class="bashcommand">-lh</font> flag, the size of the file will be followed by a letter which represents the units:</p>

				<table>
					<tr>
						<th>Letter</th>
						<th>Unit</th>
						<th>Number of bytes per unit</th>
					</tr>
					<tr>
						<td>B</td>
						<td>Bytes</td>
						<td>2<sup>0</sup> bytes</td>
					</tr>
					<tr>
						<td>K</td>
						<td>Kilobytes</td>
						<td>2<sup>10</sup> bytes</td>
					</tr>
					<tr>
						<td>M</td>
						<td>Megabyte</td>
						<td>2<sup>20</sup> bytes</td>
					</tr>
					<tr>
						<td>G</td>
						<td>Gigabyte</td>
						<td>2<sup>30</sup> bytes</td>
					</tr>
					<tr>
						<td>T</td>
						<td>Terabyte</td>
						<td>2<sup>40</sup> bytes</td>
					</tr>
					<tr>
						<td>P</td>
						<td>Petabyte</td>
						<td>2<sup>50</sup> bytes</td>
					</tr>
				</table>

				<p><font class="example">Using more than one flag</font></p>

				<p>Most of the flags can be combined, except for the following group of flags which override each other (either partially or fully). If used together, only the last one specified will be the format used to display the information. Or if possible they will be applied in the order specified.</p>

				<ul>
					<li><font class="bashcommand">-1</font>, <font class="bashcommand">-C</font>, <font class="bashcommand">-x</font>, and <font class="bashcommand">-l</font></li>
					<li><font class="bashcommand">-c</font> and <font class="bashcommand">-u</font></li>
					<li><font class="bashcommand">-B</font>, <font class="bashcommand">-b</font>, <font class="bashcommand">-w</font>, and <font class="bashcommand">-q</font></li>
					<li><font class="bashcommand">-H</font>, <font class="bashcommand">-L</font> and <font class="bashcommand">-P</font></li>
				</ul>

				<p>Combine <font class="bashcommand">-lh</font>, <font class="bashcommand">-o</font>, and <font class="bashcommand">-r</font> to print the information in long format, using human readable file sizes (<font class="bashcommand">-lh</font>), omitting the group id (<font class="bashcommand">-o</font>) and in reverse lexicographical order (<font class="bashcommand">-r</font>):</p>

				<p>
					<font class="bashcommand">$ ls -lhor /Volumes/MyExternalDrive</font><br>
					<font class="bashcommand bashcommand-result">Total 0</font><br>
					<table class="ghostTable">
						<tr>
							<td><font class="bashcommand bashcommand-result">drwxrwxrwx</font></td>
							<td><font class="bashcommand bashcommand-result">5</font></td>
							<td><font class="bashcommand bashcommand-result">myUser</font></td>
							<td><font class="bashcommand bashcommand-result">170B</font></td>
							<td><font class="bashcommand bashcommand-result">Sep 4</font></td>
							<td><font class="bashcommand bashcommand-result">11:15</font></td>
							<td><font class="bashcommand bashcommand-result">SharedFolder</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand bashcommand-result">drwxr-xr-x</font></td>
							<td><font class="bashcommand bashcommand-result">28</font></td>
							<td><font class="bashcommand bashcommand-result">myUser</font></td>
							<td><font class="bashcommand bashcommand-result">952B</font></td>
							<td><font class="bashcommand bashcommand-result">Sep 10</font></td>
							<td><font class="bashcommand bashcommand-result">09:05</font></td>
							<td><font class="bashcommand bashcommand-result">MRIdata</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand bashcommand-result">-rw-r--r-- </font></td>
							<td><font class="bashcommand bashcommand-result">1</font></td>
							<td><font class="bashcommand bashcommand-result">myUser</font></td>
							<td><font class="bashcommand bashcommand-result">134K</font></td>
							<td><font class="bashcommand bashcommand-result">Jan14</font></td>
							<td><font class="bashcommand bashcommand-result">2017</font></td>
							<td><font class="bashcommand bashcommand-result">CV.pdf</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand bashcommand-result">-rw-r--r--@</font></td>
							<td><font class="bashcommand bashcommand-result">1</font></td>
							<td><font class="bashcommand bashcommand-result">myUser</font></td>
							<td><font class="bashcommand bashcommand-result">50K</font></td>
							<td><font class="bashcommand bashcommand-result">Jan 14</font></td>
							<td><font class="bashcommand bashcommand-result">2017</font></td>
							<td><font class="bashcommand bashcommand-result">CV.docx</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand bashcommand-result">drwxr-xr-x</font></td>
							<td><font class="bashcommand bashcommand-result">22</font></td>
							<td><font class="bashcommand bashcommand-result">myUser</font></td>
							<td><font class="bashcommand bashcommand-result">714B</font></td>
							<td><font class="bashcommand bashcommand-result">Sep 4</font></td>
							<td><font class="bashcommand bashcommand-result">11:40</font></td>
							<td><font class="bashcommand bashcommand-result">Articles</font></td>
						</tr>
					</table>
				</p>
			<h3>8.2. Listing files using patterns</h3>
		    		<p>You can print information about a group of files based on patterns or characters using wildcards.</p>

				<table>
					<tr>
						<th>Wildcard</th>
						<th>Meaning</th>
					</tr>
					<tr>
						<td><font class="bashcommand">*</font></td>
						<td>Matches any number of characters</td>
					</tr>
					<tr>
						<td><font class="bashcommand">?</font></td>
						<td>Matches any single character</td>
					</tr>
					<tr>
						<td>[character_class]</td>
						<td>
							Matches any character that is a member of the specified character class.<br><br>
							
							Character Classes:<br>
							<font class="bashcommand">[:alnum:]</font> Alphanumeric characters<br>
							<font class="bashcommand">[:alpha:]</font> Alphabetic characters<br>
							<font class="bashcommand">[:digit:]</font> Numerals<br>
							<font class="bashcommand">[:upper:]</font> Uppercase alphabetic characters<br>
							<font class="bashcommand">[:lower:]</font> Lowercase alphabetic characters 
						</td>
					</tr>
					<tr>
						<td>[!character_class]</td>
						<td>Matches any character that is not a member of the specified character class</td>
					</tr>
				</table>

				<table>
					<tr>
						<th>Pattern</th>
						<th>Matches</th>
					</tr>
					<tr>
						<td>AB*</td>
						<td>List all the filenames that begin with "AB"</td>
					</tr>
					<tr>
						<td>*AB</td>
						<td>List all the filenames that end with "AB"</td>
					</tr>
					<tr>
						<td>AB*.txt</td>
						<td>List all the filenames that begin with "AB" and end with ".txt"</td>
					</tr>
					<tr>
						<td>AB???</td>
						<td>List all the filenames that begin with "AB" followed by exactly three characters</td>
					</tr>
					<tr>
						<td>[aA]*</td>
						<td>List all the filenames that begin with "a" or "A"</td>
					</tr>
					<tr>
						<td>[aA]?.txt</td>
						<td>List all the filenames that begin with "a" or "A" followed by one character and ".txt"</td>
					</tr>
					<tr>
						<td>[[:upper:]]*</td>
						<td>List any filenames that begin with an uppercase letter</td>
					</tr>
					<tr>
						<td>[![:upper:]]*</td>
						<td>List any filenames that do not begin with an uppercase letter</td>
					</tr>
				</table>

				<p>
					<font class="bashcommand">
					$ ls /Volumes/MyDrive/MyFolder/Articles/p*<br>
					<font class="bashcommand-result">
					/Volumes/MyDrive/MyFolder/Articles/patel and shen.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/perez 2013.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/pnas-0502843102.pdf<br> 
					/Volumes/MyDrive/MyFolder/Articles/pnas.201604898.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/pnas01522-0696.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/poldrack ROI analysis.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/pone.0088419.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/pone.0113807.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/pq004724.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/pq008939.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/precuneus.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/prefrontalCortex.pdf 
					</font>
					</font>
				</p>
			
			<h3>8.3. Changing the working directory</h3>
				<p>Content of cd command</p>

		    	<h3>8.4. Frequently used commands for file manipulation</h3>
		    		<p>Content of section 8.3</p>
		    		
		    	<h3>8.5. Writing files</h3>
		    		<p>Content of 8.4</p>
		    		
		    	<h3>8.6. Reading files</h3>
		    		<p>Content of 8.5</p>
		    </div>
		       
		    <div id="content9" class="hidden">
		    	<h2>9. Manipulating text and csv files</h2>
		    	
		    	<h3>9.1. The awk command</h3>
		    		<p>Content 9.1</p>
		    		
		    	<h3>9.2. The grep command</h3>
		    		<p>Content 9.2</p>
		    </div>
		       
		    <div id="content10" class="hidden">
		    	<h2>10. Manipulating image files</h2>
		    		<p>Content of section 10</p>
		    </div>
		       
		    <div id="content11" class="hidden">
		    	<h2>11. Writing more complex bash scripts</h2>
		    	
		    	<h3>11.1. Reading arguments</h3>
		    		<p>Content 11.1</p>
		    		
		    	<h3>11.2. Using functions</h3>
		    		<p>Content 11.2</p>
		    		
		    	<h3>11.3. Creating/importing libraries</h3>
		    		<p>Content 11.3</p>
		    		
		    	<h3>11.4. Scripting processes in parallel</h3>
		    		<p>Content 11.4</p>
		    </div>
		       
		    <div id="content12" class="hidden">
		    	<h2>12. Remote shell</h2>
		    		<p>Content of section 12</p>
		    </div>
		       
		    <div id="content13" class="hidden">
		    	<h2>13. Cluster jobs</h2>
		    		<p>Content of section 13</p>
		    </div>
		       
		    <div id="content14" class="hidden">
		    	<h2>14. Downloading files from the web</h2>
		    		<p>Content section 14</p>
		    </div>
		       
		    <div id="content15" class="hidden">
		    	<h2>15. Creating backups</h2>
		    		<p>Content section 15</p>
		    </div>
		       
		    <div id="content16" class="hidden">
		    	<h2>16. File permissions</h2>
		    		<p>Content of section 16</p>
		    </div>
		       
		    <div id="content17" class="hidden">
		    	<h2>17. Using aliases</h2>
		    		<p>Content of section 17</p>
		    </div>
		       
		    <div id="content18" class="hidden">
		    	<h2>18. keyboard shortcuts</h2>
		    		<p>Content of section 18</p>
		    </div>
		       
		    <div id="content19" class="hidden">
		    	<h2>19. MySQL</h2>
		    		<p>Content of section 19</p>
		    </div>
		       
		    <div id="content20" class="hidden">
		    	<h2>20. Report an error in the tutorial</h2>
					<h3>Thanks for helping me improve this free tutorial!</h3>
					<p>Please, let me know where and what type of error did you find. I will do my best to fix it as soon as I can.</p>
					
			    	<form name="input" action="https://formspree.io/mgcgithub@gmail.com" target="_blank" method="POST">
						Chapter:<br>
						<select onclick="showErrSec()" id="chaperror" name="chaperror">
						  <option value="0">Select a chapter</option>
						  <option value="1">1. Introduction to shell scripting</option>
						  <option value="2">2. Creating simple bash scripts</option>
						  <option value="3">3. Variables</option>
						  <option value="4">4. Arithmetic calculations</option>
						  <option value="5">5. Arrays</option>
						  <option value="6">6. Condition-testing</option>
						</select><br><br>
						
						<div id="secerror1" class="hidden">
							Section:<br>
							<select id="section1" name="section1">
								<option value="0">Select a section</option>
								<option value="1">1.1. Shell scripting</option>
							</select><br><br>
						</div>
						
						<div id="secerror2" class="hidden">
							Section:<br>
							<select id="section2" name="section2">
								<option value="0">Select a section</option>
								<option value="1">2.1. The vi editor</option>
								<option value="2">2.2. Other editors</option>
								<option value="3">2.3. Tips for writing scripts</option>
								<option value="4">2.4. Running a script</option>
							</select><br><br>
						</div>
						
						<div id="secerror3" class="hidden">
							Section:<br>
							<select id="section3" name="section3">
								<option value="0">Select a section</option>
								<option value="1">3.1. Utility, declaration and accessing variables</option>
								<option value="2">3.2. Rules for assigning variable names</option>
								<option value="3">3.3. Reading user input into a variable</option>
								<option value="4">3.4. Using &lt;&lt;&lt; to get input from a different source</option>
							</select><br><br>
						</div>
						
						<div id="secerror4" class="hidden">
							Section:<br>
							<select id="section4" name="section4">
								<option value="0">Select a section</option>
								<option value="1">4.1. Integer calculations</option>
								<option value="2">4.2. Non-integer calculations</option>
							</select><br><br>
						</div>
						
						<div id="secerror5" class="hidden">
							Section:<br>
							<select id="section5" name="section5">
								<option value="0">Select a section</option>
								<option value="1">5.1. Declaring and assigning values</option>
								<option value="2">5.2. Array operations</option>
							</select><br><br>
						</div>
						
						<div id="secerror6" class="hidden">
							Section:<br>
							<select id="section6" name="section6">
								<option value="0">Select a section</option>
								<option value="1">6.1. Condition-testing to check files</option>
								<option value="2">6.2. Condition-testing to compare/evaluate strings</option>
								<option value="3">6.3. Condition-testing to compare numbers</option>
								<option value="4">6.4. Condition-testing to compare arrays</option>
								<option value="5">6.5. Combining different expressions for condition-testing</option>
							</select><br><br>
						</div>
						
						<div onclick="showOther()" id="errtype">
							Error type:<br>
							<select id="etype" name="etype">
								<option value="0">Select error type</option>
								<option value="1">An error in a bash command</option>
								<option value="2">An error in the html code</option>
								<option value="3">Something in this section is not true</option>
								<option value="4">A spelling or grammatical error</option>
								<option value="5">Other</option>
							</select><br><br>
						</div>
						
						<div id="other" class="hidden">
							Please specify: <input type="text" id="othererror" name="othererror"><br><br>
						</div>
						
						<input type="submit" value="Submit">
						<input type="hidden" name="_subject" value="New submission from github"/>
					</form> 
		    </div>
		  </article>
		</section>
		
		<footer>
			<p>
				Last update: August 24 / 2020<br>
				All the content from this tutorial was originally created by the author<br>
				Author: <a href="http://linkedin.com/in/monicakeithmri" target="_blank">Monica Keith</a>
			</p>
		</footer>
	</body>
</html>

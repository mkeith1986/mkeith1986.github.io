<!DOCTYPE html>
<html>
	<title>Bash Tutorial</title> 

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Bash programming tutorial">
		<meta name="keywords" content="bash, tutorial">
		<meta name="author" content="Monica Keith">	
		
		<link rel="stylesheet" type="text/css" href="styles.css">
		<script src="functions.js"></script>
		<noscript>Sorry, your browser does not support JavaScript. This page needs to have JavaScript enabled.</noscript>
	</head>
	
	<body>
		<header>
		  <h2>Bash Tutorial</h2>
		</header>
		
		<section>
		  <nav>
		    <ul>
		     	<li><a onclick="showContent(1);">1. Introduction to shell scripting</a></li>
		      	<li><a onclick="showContent(2);">2. Creating simple bash scripts</a></li>
		      	<li><a onclick="showContent(3);">3. Variables</a></li>
		      	<li><a onclick="showContent(4);">4. Arithmetic calculations</a></li>
		      	<li><a onclick="showContent(5);">5. Arrays</a></li>
		      	<li><a onclick="showContent(6);">6. Condition-testing</a></li>
		      	<li><a onclick="showContent(7);">7. Iteration</a></li>
		      	<li><a onclick="showContent(8);">8. General file manipulation</a></li>
		      	<li><a onclick="showContent(9);">9. Manipulating text and csv files</a></li>
		      	<li><a onclick="showContent(10);">10. Manipulating image and video files</a></li>
		      	<li><a onclick="showContent(11);">11. Writing more complex bash scripts</a></li>
				<li><a onclick="showContent(12);">12. Remote shell</a></li>
				<li><a onclick="showContent(13);">13. Cluster jobs</a></li>
				<li><a onclick="showContent(14);">14. Downloading files from the web</a></li>
				<li><a onclick="showContent(15);">15. Creating backups</a></li>
				<li><a onclick="showContent(16);">16. File permissions</a></li>
				<li><a onclick="showContent(17);">17. Using aliases</a></li>
				<li><a onclick="showContent(18);">18. Keyboard shortcuts</a></li>
				<li><a onclick="showContent(19);">19. MySQL</a></li>
				<li><a onclick="showContent(20);">20. Report an error in the tutorial</a></li>
		    </ul>
		  </nav>
		  
		  <article>
		  	<div id="content1">
				test8<br>
				<iframe src="content1.html"></iframe>
		    	</div>
		    
		    <div id="content2" class="hidden">
			    <h2>2. Creating simple bash scripts</h2>
			    <h3>2.1. The vi editor</h3>
				    <p>
						There are an unlimited number of editors available for writing shell scripts in Linux and Mac. A few are 
						installed by default; some are used through the terminal and some others use a graphical interface (GUI). 
						They all have pros and cons and the decision to use one or another is totally personal. In this section I will 
						explain how to use the editor vi, which is installed by default in both Linux and MacOS and can be accessed and 
						used through the terminal window. 
					</p>
					
					These are some of the advantages of vi:
					<ul>
						<li>
							It is available in all Unix systems and any type of terminal.
						</li>
						
						<li>
							It doesn't require a lot of memory to run. So, if you are running many heavy programs in your computer, 
							vi is a good option because it won't slow down the machine anymore and will still load very fast.
						</li>
						
						<li>
							Even though there are a lot of commands that you must learn to become skilled in using this program, once 
							you learn them you can use very short and fast commands to accomplish a lot of things. For example, you 
							can delete all the characters from your current cursor location to the end of the line, just by pressing two 
							times the d in your keyboard (while in command mode). Below you will find a chart with the most commonly used 
							shortcuts in vi.
						</li>
						
						<li>
							You can use it to code in different languages (i.e. it also works for Python, HTML, etc.).
						</li>
						
						<li>
							Some editors add special characters to the text and when you run scripts written in those editors, they could
							fail. vi doesn't add any special characters, and if it did, they are visible in the editor.
						</li>
						
						<li>
							If you don't like using your mouse too much, or you don't have a mouse, or your mouse doesn't work 
							properly, then vi editor is a good choice because you rarely need to use the mouse. Most things are 
							accomplished using the keyboard.
						</li>
					</ul>
					
					However, there are some disadvantages too:
					<ul>
						<li>
							The learning curve can be steep, especially for people who are new to programming and not very comfortable 
							with computers. If you're new to bash, you not only need to learn the language, but also a whole set of 
							commands specific to this program. 
						</li>
						
						<li>
							Not being able to use your mouse can end up wasting your time while you learn all the commands that are used 
							to scroll around the file or jump from one line to another.
						</li>
						
						<li>
							It doesn't give you any error messages or explanation of why it's not doing what you want. If you type the 
							wrong command, it will just do nothing (or do the wrong thing).
						</li>
					</ul>
					
					<p>
						Generally, many people with relatively good experience programming love this editor. In my opinion, it's a good 
						tool to use once you are familiar with shell and have been programming for a while. However, it might be a great 
						option for you if you like challenges or if you are already somehow familiar with shell.
					</p>
					
					<p>
						To create a new file, type (on the command line) 
						<font class="bashcommand">vi &lt;filePath&gt;/&lt;filename&gt;</font>. For example, if you want to create a file 
						called test.sh in the desktop, you should type <font class="bashcommand">vi ~/Desktop/test.sh</font>. The vi 
						editor will open in the current terminal.
					</p>
					
					<p>
						This program runs in two modes, the command mode and the typing mode. By default, it opens in command mode. 
						What this means is that anything you type is not actually being registered in the file but are commands. For 
						example, if you type <font class="bashcommand">:q!</font> as soon as you open the file, it will quit without 
						saving (because <font class="bashcommand">:q!</font> is the command for ignoring any modifications and exiting. 
						If you type <font class="bashcommand">:w</font> it will save changes to the file (or if you haven't write 
						anything, it will just create an empty file). To change to typing mode, type <font class="bashcommand">a</font> 
						(<font class="bashcommand">a</font> is the command for entering typing mode). After you type a (in lower case), 
						you can start editing your file. To go back to command mode (for example to save changes), press the key 
						<font class="bashcommand">esc</font> (top left corner of the keyboard).
					</p>
					
					<p>
						<font class="example">Using the vi editor for the first time</font>
						Open the vi editor, create a script that prints "Hello Word", and save it with the file name helloword.sh
					</p>
					
					<p>
						Step 1: Open the vi editor<br><br>
						<img src="vi_1.png"/>
					</p>
					
					<p>
						Step 2: Type <font class="bashcommand">a</font> to start editing the file. You will see that an 
						<b>--Insert--</b> message in the bottom of the terminal appears. This means that now you are in typing mode.<br><br>
						<img src="vi_2.png"/>
					</p>
					
					<p>
						Step 3: Start typing commands. The simplest command, to print a message such as 
						<font class="bashcommand">"Hello World"</font> (or any other) is <font class="bashcommand">echo</font>. The 
						syntax of this command is the word <font class="bashcommand">echo</font> followed by the message you want to 
						print out between quotation marks (in this case <font class="bashcommand">"Hello World!"</font>).<br><br>
						<img src="vi_3.png"/>
					</p>
					
					<p>
						Step 4: Once you finish your script, press the <font class="bashcommand">esc</font> key to enter command mode. 
						You will see that the <b>--Insert--</b> message at the bottom of the terminal disappears (this means that now 
						you are in command mode).<br><br>
						<img src="vi_4.png"/>
					</p>
					
					<p>
						Step 5: Save changes and exit the vi editor. In order to do this, type <font class="bashcommand">:wq</font> 
						(to write (<font class="bashcommand">w</font>) and quit (<font class="bashcommand">q</font>) at the same time). 
						The table below will show you the most commonly used commands for vi.<br><br>
						<img src="vi_5.png"/>
					</p>
					
					<p>
						Step 6: To be able to execute the script, you will have to give it running permissions. The topic of 
						permissions is a lot more complicated, so I will not go into details now (I will talk about it later). For now, 
						all you need to know is that to give running permissions to your script you have to type 
						<font class="bashcommand">chmod 775 helloword.sh</font><br><br>
						<img src="vi_6.png"/>
					</p>
					
					<p>The following table shows a list of vi commands that can be used in command mode and the action that will 
						happen in each case. In general, a number preceding any vi command will tell vi to repeat the command that 
						number of times. For example, <font class="bashcommand">p</font> is the command for pasting. If you write 
						(in command mode) <font class="bashcommand">2p</font>, then vi will paste whatever you copied two times where 
						the cursor is currently located.</p>
					
					<table>
						<caption>List of vi commands</caption>
						<tr>
							<th style="width:30%"><b>Key/command</b></th>
							<th style="width:70%"><b>Action</b></th>
						</tr>
						<tr>
							<td><font class="bashcommand">[ESC]</font></td>
							<td>Switch to command mode</td>
						</tr>
						<tr>
							<td><font class="bashcommand">[ctrl] b</font></td>
							<td>Scroll backward one screen</td>
						</tr>
						<tr>
							<td><font class="bashcommand">[ctrl] d</font></td>
							<td>Scroll down half screen</td>
						</tr>
						<tr>
							<td><font class="bashcommand">[ctrl] f</font></td>
							<td>Scroll forward one screen</td>
						</tr>
						<tr>
							<td><font class="bashcommand">[ctrl] u</font></td>
							<td>Scroll up half screen</td>
						</tr>
						<tr>
							<td><font class="bashcommand">.</font></td>
							<td>Repeat last command</td>
						</tr>
						<tr>
							<td><font class="bashcommand">$</font></td>
							<td>Go to end of line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">? string</font></td>
							<td>Search backward for <font class="bashcommand">string</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">/ string</font></td>
							<td>Search forward for string</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:0</font></td>
							<td>Go to beginning of line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N</font></td>
							<td>Go to line <font class="bashcommand">N</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N,Md</font></td>
							<td>Delete lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N,MmP</font></td>
							<td>Move lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font> and paste them after line <font class="bashcommand">P</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N,MtP</font></td>
							<td>Copy lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font> and paste them after line <font class="bashcommand">P</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand">:N,Mw file</font></td>
							<td>Save lines <font class="bashcommand">N</font> to <font class="bashcommand">M</font> to file</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:q</font></td>
							<td>Quit (does not save any changes)</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:q!</font></td>
							<td>Ignore any modifications made and quit</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:%s/old/new/option</font></td>
							<td>
							Searches and replaces the string <font class="bashcommand">old</font> by the string 
							<font class="bashcommand">new</font> in the entire file<br>
							The following letters can be added in the field <font class="bashcommand">option</font>:<br>
							<font class="bashcommand">c</font> to prompt for confirmation<br>
							<font class="bashcommand">g</font> to replace all the occurrences of the string
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:s/old/new/option</font></td>
							<td>
							Searches and replaces the string <font class="bashcommand">old</font> by the string 
							<font class="bashcommand">new</font> in the line in which the cursor is located</br>
							The following letters can be added in the field <font class="bashcommand">option</font>:</br>
							<font class="bashcommand">c</font> to prompt for confirmation<br>
							<font class="bashcommand">g</font> to replace all the occurrences of the string
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:set ignorecase</font></td>
							<td>Ignore case sensitivity during search</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:set noignorecase</font></td>
							<td>Restore case sensitivity during search</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:set number</font></td>
							<td>Turn on line numbering</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:set nonumber</font></td>
							<td>Turn off line numbering</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:syntax on</font></td>
							<td>Turn on syntax colors in the text</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:syntax off</font></td>
							<td>Turn off syntax colors in the text</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:w</font></td>
							<td>Save changes</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:w file</font></td>
							<td>Save changes to file</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:wq</font></td>
							<td>Save changes and quit</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:x</font></td>
							<td>Save changes and quit</td>
						</tr>
						<tr>
							<td><font class="bashcommand">a</font></td>
							<td>Switch to editing mode and continue writing where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">A</font></td>
							<td>Switch to editing mode and continue writing at the end of the line where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">i</font></td>
							<td>Switch to editing mode and continue writing where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">I</font></td>
							<td>Switch to editing mode and continue writing at the beginning of the line where the cursor is
							located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">cw</font></td>
							<td>Delete the rest of the word in which the cursor is located (keeps the characters located before the 
							cursor)</td>
						</tr>
						<tr>
							<td><font class="bashcommand">D</font></td>
							<td>Delete the rest of the line in which the cursor is located (keeps the characters and words located 
							before the cursor)</td>
						</tr>
						<tr>
							<td><font class="bashcommand">dd</font></td>
							<td>Delete the entire line where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">dw</font></td>
							<td>Delete the whole word in which the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">J</font></td>
							<td>Put the next line at the end of the line where the cursor is located</td>
						</tr>
						<tr>
							<td><font class="bashcommand">o</font></td>
							<td>Open line below cursor</td>
						</tr>
						<tr>
							<td><font class="bashcommand">O</font></td>
							<td>Open line above cursor</td>
						</tr>
						<tr>
							<td><font class="bashcommand">p</font></td>
							<td>Paste below current line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">P</font></td>
							<td>Paste above current line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:u</font></td>
							<td>Undo previous command</td>
						</tr>
						<tr>
							<td><font class="bashcommand">:U</font></td>
							<td>Undo all changes to line</td>
						</tr>
						<tr>
							<td><font class="bashcommand">x</font></td>
							<td>Delete text at cursor</td>
						</tr>
						<tr>
							<td><font class="bashcommand">X</font></td>
							<td>Delete (backspace) text at cursor</td>
						</tr>
						<tr>
							<td><font class="bashcommand">yy</font></td>
							<td>Copy line in which the cursor is located</td>
						</tr>
					</table>
				
				<h3>2.2. Other editors</h3>	
					<p>
						As I previously mentioned, there is an unlimited number of editors and the choice of which to use is totally 
						personal. The following editors are available for both Linux and MacOS: vim, emacs, gedit (which is also 
						installed by default in Linux and uses a GUI, great for beginners), and Eclipse (among many others). Eclipse 
						is a lot more than an editor; it is a development environment used for programming in many other languages 
						(mainly Java) and for software development and modeling. The following are editors available only for MacOS: 
						Xcode, TextWrangler, TextMate, Notepad++, and Atom (among many others).
					</p>
					
				<h3>2.3. Tips for writing scripts</h3>
					<ol>
						<li>
						Albeit not mandatory, the first line of any bash script should be the shebang 
						(<font class="bashcommand">#!/bin/bash</font>). This line indicates that the script is written in bash 
						(instead of tcsh, for example) and that the bash interpreter should execute it.<br><br>
						</li>
						
						<li>
						Be organized when writing scripts. As you start writing longer and more complicated programs, this 
						will become more important. Try to comment as often as possible so that other people can understand what 
						your script is doing, which parameters are needed and what they mean or to understand the output. 
						Commenting will also help you fix errors or keep track of the version, changes, authorship, etc, or to 
						remember what your script does if you don't use it for a while. To insert a comment, you simply start the 
						line with a hash (<font class="bashcommand">#</font>). Any line that starts with this symbol will not be 
						executed (except for the shebang). Also try to use indentation to know where pieces of code start and end 
						(for example when doing loops). If you don't indentate, understanding your own code will be very 
						difficult. Part of being organized is also using appropriate variable names. Use names that are associated 
						to the structure you're using (for example, if you're creating an array, naming it 
						<font class="bashcommand">array</font> will help you remember that this variable is an array and not a 
						string or a number) and try to use short names (for example, instead of naming a variable 
						<font class="bashcommand">myListOfSubjects</font>, you can call it 
						<font class="bashcommand">subjList</font>).</br><br>
						</li>
						
						<li>
						It is also a good idea to use the following commands at the beginning of any script:</br>
						<font class="bashcommand">set -e</font>: This will make the program exit as soon as it encounters an error. 
						If you don't use this, then even if there's an error your code will continue to execute.<br> 
						<font class="bashcommand">set -u</font>: This will make the program exit when using undeclared variables. 
						It will prevent the program from executing the wrong commands if you misspell a variable name.<br><br>
						</li>
						
						<li>
						Use double quotes (<font class="bashcommand">"</font>) when declaring a string, single quotes 
						(<font class="bashcommand">'</font>) when declaring a character, and no quotes when declaring numbers. 
						This will prevent word splitting (when declaring a string that has spaces) and other errors in your 
						code.<br><br>
						</li>
						
						<li>
						Use functions. This topic will be covered in chapter X. Using functions will make your code more readable, 
						reusable, and will allow you to run only parts of the code without having to comment all the lines. This 
						is especially useful when debugging or re-running a script.<br><br>
						</li>
						
						<li>
						If you are declaring a variable that the value should never change, then use the word 
						<font class="bashcommand">readonly</font> before the variable name.<br> 
						For example, if I want to declare a variable called <font class="bashcommand">age</font> with value 
						<font class="bashcommand">30</font> and this value should never be replaced, then you should declare it 
						like this:<br>
						<font class="bashcommand">$ readonly age=30</font><br>
						Instead of:<br>
						<font class="bashcommand">$ age=30</font><br><br>
						
						If at some point in the script you try to replace the value of that variable, you will get an error message:
						<br>
						<font class="bashcommand">$ readonly age=30</font><br>
						<font class="bashcommand">$ age=29</font><br>
						<font class="bashcommand bashcommand-result">-bash: age: readonly variable</font>
						</li>
					</ol>
				
				<h2>2.4. Running a script</h2>
					<p>
						Running a shell script is easy. You only type the path and name of the file in the command line and then press 
						enter. For example, if your script is located in the Desktop and is called helloWord.sh, then to execute it 
						you should type the following in the command line:<br>
						<font class="bashcommand">$ ~/Desktop/helloWord.sh</font><br><br>
						If you get a Permission Denied error, this means that you must change its permissions to make it runnable. 
						The topic of permissions is a bit complicated and will be explained in detail in chapter 12. But for now, you 
						only need to know that the following command will allow you to execute the script if it's not runnable:<br>
						<font class="bashcommand">$ chmod 775 &lt;script_path_and_name&gt;</font>
					</p>
		    </div>
		    
		    <div id="content3" class="hidden">
		    	<h2>3. Variables</h2>
		    	<h3>3.1. Utility, declaration and accessing variables</h3>
		    		<p>
						A very important aspect of programming (in bash or any other language) is the ability to use a label (called 
						variable) to indicate some other quantity (a number, character, string or command). For example, I can use 
						the variable <font class="bashcommand">${desktop}</font> to represent the string 
						<font class="bashcommand">"/Users/monica/Desktop"</font>. Or the variable 
						<font class="bashcommand">${year}</font> to represent the number <font class="bashcommand">2020</font> 
						(after correctly declaring these variables). Variables can be used for many purposes, including making the 
						code more readable, short and organized and to prevent typing errors. They are also very useful in cases in 
						which the actual value of a variable is not known before executing the program, or when you need to save the 
						output of one command to use as input for another command. For example, when reading the contents of a file 
						you can read line by line in an iterative manner (which you will learn later), saving each line in a variable 
						and then doing something with it (depending the purpose of the program). 
					</p>
					
					<p>
						The easy thing about declaring variables in bash is that you don't have to specify data types. However, if 
						the value that you are assigning is a string of characters, you should use quotation marks 
						(<font class="bashcommand">"</font>) between the beginning and the end of your string (especially if the 
						string contains spaces). You must also be careful to not include any white space between the variable name, 
						the equals sign, and the value. Additionally, be aware that the quotation marks used in bash are 
						<font class="bashcommand">"</font>, which is different than those used in Microsoft Word. They look very 
						similar, but bash won't recognize the later ones. So, if you copy-paste from Microsoft Word a command that
						includes quotation marks, you will probably get an error.
					</p>
					
					<p>
						<font class="example">Declaring variables of different data types</font>
						In the following commands, I will assign a number to the variable <font class="bashcommand">YEAR</font>, a String 
						to the variables <font class="bashcommand">MONTH</font> and <font class="bashcommand">NAME</font> and a character to 
						the variable <font class="bashcommand">GENDER</font>. As you can observe, numbers, strings and characters should 
						be declared in a different manner.
					</p>
					
					<p>
						<font class="bashcommand">
						$ YEAR=2018<br>
						$ MONTH="August"<br>
						$ NAME="Monica Keith"<br>
						$ GENDER='F'
						</font>
					</p>
					
					<p>
						<font class="example">Common mistakes when declaring variables</font>
						The following commands will produce errors because there is a white space before and/or after the equal sign 
						(<font class="bashcommand">=</font>), or because the quotation marks (<font class="bashcommand">"</font>) are 
						missing when declaring a string that contains a space. Bellow each erroneous command you can see the error 
						that Bash produces.
					</p>
					
					<p>
						<font class="bashcommand">
						$ NAME ="Monica Keith"<br>
						<font class="bashcommand-result">-bash: NAME: command not found</font><br>
						$ NAME= "Monica Keith"<br>
						<font class="bashcommand-result">-bash: Monica Keith: command not found</font><br>
						$ NAME = "Monica Keith"<br>
						<font class="bashcommand-result">-bash: NAME: command not found</font><br>
						$ NAME=Monica Keith<br>
						<font class="bashcommand-result">-bash: Keith: command not found</font>
						</font>
					</p>
					
					<p>
						Once you assign a value to a variable, you can reference it with a dollar sign, located immediately before 
						the variable name. You can also reference a variable by including curly brackets 
						(<font class="bashcommand">{}</font>) at the beginning and the end of the variable name. It is better (but 
						not mandatory) to always reference variables using brackets. This will prevent errors in your code (specially 
						when referencing strings that have spaces or special characters).
					</p>
					
					<p>
						<font class="example">Referencing variables</font>
						In the following example, I will declare variable <font class="bashcommand">VAR1</font> with value 
						<font class="bashcommand">2</font>, and variable <font class="bashcommand">VAR2</font> with value 
						<font class="bashcommand">"Subject"</font>. Then, I will use the function 
						<font class="bashcommand">echo</font> to print in the command line the value of the two variables.
					</p>
					
					<p>
						<font class="bashcommand">
						$ VAR1=2<br>
						$ VAR2="Subject"<br>
						$ echo ${VAR1}<br>
						<font class="bashcommand-result">2</font><br>
						$ echo ${VAR2}<br>
						<font class="bashcommand-result">Subject</font>
						</font>
					</p>
					
					<p>
						<font class="example">Common mistakes when referencing variables</font>
						When referencing a variable, be careful not to include any space before or after the brackets. The following 
						examples will produce an error because of the inclusion of a space around the brackets:
					</p>
					
					<p>
						<font class="bashcommand">
						$ echo ${ VAR2}<br>
						<font class="bashcommand-result">-bash: ${ VAR2}: bad substitution</font><br>
						$ echo ${VAR2 }<br>
						<font class="bashcommand-result">-bash: ${VAR2 }: bad substitution</font><br>
						$ echo ${ VAR2 }<br>
						<font class="bashcommand-result">-bash: ${ VAR2 }: bad substitution</font>
						</font>
					</p>
					
					<p>
						The following erroneous reference (with a space between the dollar sign and the first bracket) will not cause 
						an error but will not substitute <font class="bashcommand">${VAR2}</font> for the correct value. It will just 
						print <font class="bashcommand">$ {VAR2}</font> instead of <font class="bashcommand">Subject</font>.
					</p>
					
					<p>
						<font class="bashcommand">
						$ echo $ {VAR2}<br>
						$ {VAR2}
						</font>
					</p>
					
					<p>
						<font class="example">Concatenating variables</font>
						You can concatenate different variables and characters to form new strings. To do this, you will need to 
						reference the variables using the curly brackets and use quotation marks at the beginning and the end of your 
						final string. For example, if you want to use the previously declared variables 
						<font class="bashcommand">VAR1</font> and <font class="bashcommand">VAR2</font> to generate the String 
						<font class="bashcommand">Subject_02</font>, you can concatenate them the following way:
					</p>
					
					<p>
						<font class="bashcommand">
						$ echo ${VAR2}<br>
						<font class="bashcommand-result">Subject</font><br>
						$ echo ${VAR1}<br>
						<font class="bashcommand-result">2</font><br>
						$ echo "${VAR2}_0${VAR1}"<br>
						<font class="bashcommand-result">Subject_02</font>
						</font>
					</p>
					
					<p>Here are a few more examples on how to declare and concatenate variables:</p>
					
					<p>
						<font class="bashcommand">
						$ ID="Subject_202"<br>
						$ VOLUME=20<br>
						$ MEASURE="mm"<br>
						$ echo "${ID}: ${VOLUME}${MEASURE}"<br>
						<font class="bashcommand-result">Subject_202: 20mm</font>
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
						$ VAR1="MacOS"<br>
						$ VAR2="Linux"<br>
						$ VAR3="Windows"<br>
						$ echo "(${VAR1},${VAR2},${VAR3})"<br>
						<font class="bashcommand-result">(MacOS,Linux,Windows)</font>
						</font>
					</p>
					
					<p>
						<font class="example">A common mistake when concatenating variables</font>
						It is very common when you are referencing many variables or concatenating variables to create a long string 
						to forget the closing quotation mark. For example, writing<br>
						<font class="bashcommand">$ echo "(${VAR1},${VAR2},${VAR3})</font><br>
						instead of<br>
						<font class="bashcommand">$ echo "(${VAR1},${VAR2},${VAR3})"</font>
					</p>
					
					<p>
						When that happens and you click enter in the keyboard, the command line won't allow you to enter any more 
						commands. You will see the symbol <font class="bashcommand">></font> and if you continue pressing enter it 
						will do nothing. This is because the command line is waiting for you to close the open String. To close the 
						string just add the missing quotation mark or cancel and ignore what you have written so far in the current 
						line by pressing CTR+C. 
					</p>
					
				<h3>3.2. Rules for assigning variable names</h3>
					<p>You can assign any value to a variable. However, a variable cannot have just any name. There are a few 
					rules for assigning variable names.</p>
					
					<ol>
						<li>
							A variable name should not be a number.<br>
							This type of variable is only used to read arguments on a shell script. For example, 
							<font class="bashcommand">$1</font> refers to the first argument of a script, 
							<font class="bashcommand">$2</font> to the second argument, etc. Later you will learn the meaning and use 
							of script arguments.
						</li><br>
						
						<li>
							Variable names must start with an alphabetical letter or an underscore.<br>
							Variable names can contain any number, but it should not be located at the beginning.
						</li><br>
						
						<li>
							Do not use <font class="bashcommand">$</font> or <font class="bashcommand">${}</font> to declare a 
							variable. These characters are used only to reference variables (not to declare).
						</li><br>
						
						<li>
							Do <u>NOT</u> assign the name <font class="bashcommand">PATH</font> to any variable.<br>
							If you do so, you won't get any error right away. But it will mess up the execution of other programs. 
							<font class="bashcommand">PATH</font> is a system variable that specifies a set of directories where 
							executable programs are located. For example, when you install a software that runs in the command line 
							(i.e. FSL), the path to the executable of that program will be included in the system variable 
							<font class="bashcommand">PATH</font>. So, if you rename that variable, you won't be able to execute the 
							program again in the current terminal. If you forget about this rule and mistakenly re-write the value 
							of this variable, close the current terminal and open a new one. Every time you open a new terminal, 
							this system variable will be re-set to the correct value (which is stored in the bash_profile, we will 
							talk about this file in a later chapter). At any moment you can know the value of your 
							<font class="bashcommand">PATH</font> by typing <font class="bashcommand">echo ${PATH}</font>. You will 
							see something like this (although this will significantly varies between one computer and the other 
							depending which programs you have installed and referenced in the bash_profile):<br><br>
							
							<font class="bashcommand">
							$ echo ${PATH}<br>
							<font class="bashcommand-result">/usr/local/fsl/bin:/Applications/freesurfer/bin:/Applications/freesurfer/fsfast/bin:/Applications/freesurfer/tktools:/usr/local/fsl/bin:/Applications/freesurfer/mni/bin:/Users/bunbury/bin:/Applications/MATLAB_R2018a.app/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin</font>
							</font><br><br>
							
							Another Unix reserved name that you should not use is <font class="bashcommand">BASH</font>. There is a long list 
							of Unix reserved words that I will not include here but you will learn as you get more experienced.
						</li><br>
						
						<li>
							Avoid using the following reserved characters from appearing in variable names:
							<font class="bashcommand">/ &gt; &lt; | : &amp; . *</font>	
						</li><br><br>
						
						<font class="example">Some valid and invalid variable names</font><br>
						<table>
							<caption>Valid and invalid variable names</caption>
							<tr>
								<th style="width:50%"><b>Valid variable names</b></th>
								<th style="width:50%"><b>Invalid variable names</b></th>
							</tr>
							<tr>
								<td>V</td>
								<td>1</td>
							</tr>
							<tr>
								<td>VAR</td>
								<td>1VAR</td>
							</tr>
							<tr>
								<td>VAR1</td>
								<td>2_VAR</td>
							</tr>
							<tr>
								<td>VAR_1</td>
								<td>.VAR</td>
							</tr>
							<tr>
								<td>_VAR1</td>
								<td>$VAR</td>
							</tr>
							<tr>
								<td>_1VAR</td>
								<td>${VAR}</td>
							</tr>
							<tr>
								<td>VARIABLE_NAME</td>
								<td>{VAR}</td>
							</tr>
							<tr>
								<td>PATH1</td>
								<td>PATH</td>
							</tr>
							<tr>
								<td>BASH1</td>
								<td>BASH</td>
							</tr>
						</table>
						
						<p>
							Variable names can be in lower and/or upper case. However, they are case sensitive. If you declare a 
							variable as <font class="bashcommand">VAR1</font>, but you reference it as 
							<font class="bashcommand">${var1}</font>, bash will not recognize the value. You must reference it as 
							<font class="bashcommand">${VAR1}</font>.
						</p>
					</ol>
					
				<h3>3.3. Reading user input into a variable</h3>
					<p>
						The command <font class="bashcommand">read</font> is the counterpart of <font class="bashcommand">echo</font>. 
						Instead of printing things in the terminal the way <font class="bashcommand">echo</font> does, 
						<font class="bashcommand">read</font> reads input from the user and saves it in the specified variable (in 
						this case <font class="bashcommand">VAR</font>). The word read is followed by the name of the variable where 
						you want to save the information. In the following example, I am going to read the input from the user and 
						save it in the variable <font class="bashcommand">VAR</font>. Generally, Bash will read everything that is 
						written until the user presses the Enter key and save all the information in the corresponding variable.
					</p>
					
					<p>
						<font class="example">Saving user input into a new variable</font>
						<font class="bashcommand">
						$ echo "Username:"<br>
						<font class="bashcommand-result">Username:</font><br>
						$ read VAR<br>
						<font class="bashcommand-result">Noemi</font><br>
						$ echo "You typed: ${VAR}"<br>
						<font class="bashcommand-result">You typed: Noemi</font>
						</font>
					</p>
					
					<p>
						There are some flags (options) that can be added to the command read to change the way in which information is 
						displayed or captured:
					</p>
					
					<table>
						<caption>Options for reading user input</caption>
						<tr>
							<th style="width:30%"><b>Flag</b></th>
							<th style="width:70%"><b>Usage</b></th>
						</tr>
						<tr>
							<td><font class="bashcommand">-s</font></td>
							<td>
							Silent mode. The characters that the user inputs are not displayed (used specially when asking the user to 
							input a password).
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-p "MESSAGE"</font></td>
							<td>
								Displays the <font class="bashcommand">MESSAGE</font> where the user must write the input.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-n NUM_CHARS</font></td>
							<td>
							The input line ends after reading <font class="bashcommand">NUM_CHARS</font> characters, rather than waiting for the 
							user to press Enter in the keyboard.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-d 'CHAR_NEW_LINE'</font></td>
							<td>
							<font class="bashcommand">CHAR_NEW_LINE</font> is used to determine the end of the input line (if different than Enter).
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-r</font></td>
							<td>
								Backslash does not act as an escape character but instead is part of the line.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-t NSECONDS</font></td>
							<td>
							Bash will stop reading the user input after <font class="bashcommand">NSECONDS</font>. Whatever was entered in that 
							time is captured as the input line.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-a ARRAY_NAME</font></td>
							<td>
							The words that the user inputs are assigned to sequential indices of the array 
							<font class="bashcommand">ARRAY_NAME</font>. The array is emptied before assigning the values if it 
							already exists.
							</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-u FILEDESCRIPTOR</font></td>
							<td>
							Read input from <font class="bashcommand">FILEDESCRIPTOR</font>.
							</td>
						</tr>
					</table>
					
					<p>
						The following examples will show how to use the flags mentioned in the previous table. Be aware on how the 
						variable name is always written at the end of the command. In this section, I will not explain the use of 
						flags <font class="bashcommand">-a</font> and <font class="bashcommand">-u</font> because we haven't learned 
						yet about arrays or file manipulation. Some of the examples will also show common mistakes that will make bash 
						show an error.
					</p>
					
					<p>
						<font class="example">read -s</font>
						In the following example, the flag <font class="bashcommand">-s</font> causes the user input to be silenced, 
						so when the user writes the password, it is not shown in the screen. If the user input is 
						<font class="bashcommand">ThisIsMyPassword</font>, then that string is saved in the variable 
						<font class="bashcommand">PASSWORD</font>. While the user is writing its password and until it presses Enter, 
						you will see the following symbol underneath <font class="bashcommand">$ read -s PASSWORD </font>:
						<img src="pwd.png"/>. Afterwards, the symbol will disappear.
					</p>
					
					<p>
						In the example of a wrong syntax, the mistake is that the variable <font class="bashcommand">PASSWORD</font> 
						is written before the flag <font class="bashcommand">-s</font>. The variable must go at the end of the command 
						independently of which flags are used. As a result, bash is not silencing the user input, is giving the invalid 
						identifier error, and is not saving any string in the variable.
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
								$ read -s PASSWORD<br>
								<img src="pwd.png"/><br>
								$ echo ${PASSWORD}</br>
								<font class="bashcommand-result">ThisIsMyPassword</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
								$ read PASSWORD -s<br>
								ThisIsMyPassword<br>
								<font class="bashcommand-result">-bash: read: `-s': not a valid identifier</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">read -p</font>
						The flag <font class="bashcommand">-p</font> is useful if you want to prompt a message so that the user 
						knows what the input should be. The examples in the following table combine the flags 
						<font class="bashcommand">-p</font> and <font class="bashcommand">-s</font> to indicate the user to input a 
						password and hide the password while its being typed. The prompt message should go right after the flag 
						<font class="bashcommand">-p</font>.
					</p>
					
					<p>
						The following table shows some examples of commands written using a wrong syntax (as well as the correct way 
						to write them). In the first example, the error is that the prompt message is not located right after the flag 
						<font class="bashcommand">-p</font> (instead, it is located after the flag <font class="bashcommand">-s</font>). 
						In the second example, the error is that the variable <font class="bashcommand">PASSWORD</font> is not located 
						at the end of the command. In the third example, the problem is that the prompt message 
						(<font class="bashcommand">Please input your password</font>) is not surrounded by quotation marks. So, for 
						bash only the first word of that sentence (<font class="bashcommand">Please</font>) is the prompt message, and 
						the next word (<font class="bashcommand">input</font>) is read as the variable name. The rest of the command 
						(<font class="bashcommand">your password</font>) is ignored. That is why when reading 
						<font class="bashcommand">${PASSWORD}</font>, nothing is echoed, the variable is empty because nothing was 
						saved with that variable name. Instead, the input was saved in <font class="bashcommand">${input}</font>. This 
						is the reason why the prompt message should always be surrounded by quotation marks.
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -p "Please input your password" -s PASSWORD<br>
									<font class="bashcommand-result">Please input your password</font> <img src="pwd.png"/><br>
									$ echo ${PASSWORD}<br> 
									<font class="bashcommand-result">ThisIsMyPassword</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read -p -s "Please input your password" PASSWORD<br>
									<font class="bashcommand-result">-s</font><br>
									<font class="bashcommand-result">-bash: read: `Please input your password': not a valid identifier</font>
								</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -p "Please input your password" -s PASSWORD<br>
									<font class="bashcommand-result">Please input your password</font> <img src="pwd.png"/><br>
									$ echo ${PASSWORD}<br> 
									<font class="bashcommand-result">ThisIsMyPassword</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read PASSWORD -s -p "Please input your password"<br>
									ThisIsMyPassword<br>
									<font class="bashcommand-result">-bash: read: `-s': not a valid identifier</font>
								</font>
							</td>
						</tr>
						<tr>
							<td>
							</td>
							<td>
								<font class="bashcommand">
									$ read -s -p Please input your password<br>
									ThisIsMyPassword<br>
									$ echo $PASSWORD<br>
									<br>
									$ echo ${input}<br>
									<font class="bashcommand-result">ThisIsMyPassword</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">read -n</font>
						In the following example, <font class="bashcommand">-n 1</font> forces bash to accept only one character in the 
						input. So, the terminal will finish reading after one character. Here we are combining flags 
						<font class="bashcommand">-n</font> and <font class="bashcommand">-p</font> to also prompt a message to the 
						user.
					</p>
					
					<p>
						In the wrong syntax, <font class="bashcommand">1</font> (the number of characters to be accepted) and the 
						prompt message are located in the wrong place. The number of characters accepted should always go after 
						<font class="bashcommand">-n</font> and the prompt message should always go after 
						<font class="bashcommand">-p</font>. 
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -n 1 -p "Do you wish to continue? (y/n)" VAR<br>
									<font class="bashcommand-result">Do you wish to continue? (y/n)y</font><br>
									$ echo $VAR<br>
									<font class="bashcommand-result">y</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read -n -p 1 "Do you wish to continue? (y/n)" VAR<br>
									<font class="bashcommand-result">-bash: read: -p: invalid number</font>
								</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -p "Do you wish to continue? (y/n)" -n 1 VAR<br>
									<font class="bashcommand-result">Do you wish to continue? (y/n)y</font><br>
									$ echo $VAR<br>
									<font class="bashcommand-result">y</font>					
								</font>
							</td>
							<td>
								<font class="bashcommand">
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">read -d</font>
						In the following example the end of the line is determined by the character <font class="bashcommand">#</font> 
						instead of Enter (using the flag <font class="bashcommand">-d</font>). As soon as the user types 
						<font class="bashcommand">#</font>, bash finishes reading and saves the input in the variable 
						<font class="bashcommand">VAR</font>.
					</p>
					
					<p>
						In the wrong syntax, the command is missing the apostrophes (<font class="bashcommand">'</font>) around the 
						character <font class="bashcommand">#</font>.
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Correct syntax:</b></th>
							<th style="width:50%"><b>Wrong syntax:</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -d '#' VAR<br>
									$ echo $VAR<br>
									<font class="bashcommand-result">SomeText</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read -d # VAR<br>
									<font class="bashcommand-result">-bash: read: -d: option requires an argument</font><br>
									<font class="bashcommand-result">read: usage: read [-ers] [-u fd] [-t timeout] [-p prompt] [-a array] [-n nchars] [-d delim] [name ...]</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">The backslash</font>
						In bash, certain characters have special meanings. For example, the dollar sign 
						(<font class="bashcommand">$</font>) is used to reference a variable. When you type 
						<font class="bashcommand">${VAR}</font>, it will print the value of 
						<font class="bashcommand">VAR</font> instead of the actual string 
						"<font class="bashcommand">${VAR}</font>". The backslash (<font class="bashcommand">\</font>) is used to remove 
						those special meanings from the character followed by it. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ VAR="Some text"<br>
							$ echo ${VAR}<br>
							<font class="bashcommand-result">Some text</font><br>
							$ echo \${VAR}<br>
							${VAR}
						</font>
					</p>
					
					<p>
						When using the flag <font class="bashcommand">-r</font>, the backslash is part of the line instead of being 
						used as an escape character. The following table shows examples in which the user inputs the same string but it 
						is read differently because in one case the flag is used (first column) but not in the other (second column).
					</p>
					
					<table>
						<tr>
							<th style="width:50%"><b>Examples using flag -r</b></th>
							<th style="width:50%"><b>Examples without the flag -r</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -r VAR<br>
									<font class="bashcommand-result">C:\Documents\Newsletters\Summer2018.pdf</font><br>
									$ echo ${VAR}<br>
									<font class="bashcommand-result">C:\Documents\Newsletters\Summer2018.pdf</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read VAR<br>
									<font class="bashcommand-result">C:\Documents\Newsletters\Summer2018.pdf</font><br>
									$ echo ${VAR}<br>
									<font class="bashcommand-result">C:DocumentsNewslettersSummer2018.pdf</font>
									</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ read -r MESSAGE<br>
									<font class="bashcommand-result">In HTML \n is used to indicate a new line</font><br>
									$ echo ${MESSAGE}<br>
									<font class="bashcommand-result">In HTML \n is used to indicate a new line</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ read MESSAGE<br>
									<font class="bashcommand-result">In HTML \n is used to indicate a new line</font><br>
									$ echo ${MESSAGE}<br>
									<font class="bashcommand-result">In HTML n is used to indicate a new line</font>
								</font>
							</td>
						</tr>
					</table>
				
				<h3>3.4. Using &lt;&lt;&lt; to get input from a different source</h3>
					<p>
						So far, we have used the command <font class="bashcommand">read</font> to save the user input into a variable. 
						This command can also be used to read from other sources (i.e. other variables or files).
					</p>
					
					<p>
						<font class="example">Reading content from a variable</font>
						In the following example, <font class="bashcommand">read</font> reads the content of the variable 
						<font class="bashcommand">VAR</font>, but only keeps the first character (because it is using the 
						<font class="bashcommand">-n 1</font> flag):
					</p>
					
					<p>
						<font class="bashcommand">
						$ VAR=yes<br>
						$ read -n 1 R &lt;&lt;&lt; ${VAR}<br>
						$ echo ${R}<br>
						<font class="bashcommand-result">y</font>
						</font>
					</p>
					
					<p>
						<font class="example">Reading and saving the output of a function</font>	
						<font class="bashcommand">read</font> also allows you to read the output of a function and save it in a variable. 
						In this example, we are saving the output of the <font class="bashcommand">pwd</font> function into the variable 
						<font class="bashcommand">CURRENT_DIR</font>. <font class="bashcommand">pwd</font> is a function that prints the 
						current folder in which you are located in the command line. 
					</p>
					
					<p>
						<font class="bashcommand">
						$ pwd<br>
						<font class="bashcommand-result">/Users/myUserName</font><br>
						$ read CURRENT_DIR &lt;&lt;&lt; $(pwd)<br>
						$ echo ${CURRENT_DIR}<br>
						<font class="bashcommand-result">/Users/myUserName</font>
						</font>
					</p>
					
					<p>
						<font class="example">**Example specific for people doing neuroimaging**</font>
						<b>WARNING:</b> If you have never analyzed MRI brain images, the following paragraph might sound like written in 
						extraterrestrial language, and it probably will not work in your computer since you need neuroimaging software
						to execute it.
					</p>
					
					<p>	
						In this example, we are reading the output of a function and saving it in the variable 
						<font class="bashcommand">VOL</font>. The output of this function (<font class="bashcommand">fslstats -V</font>) 
						consists of two values separated by a space. The first value is the volume of a region of interest (ROI) from 
						an MRI file in number of voxels, and the second value is the volume in mm<sup>3</sup>. Because we are using the 
						flag <font class="bashcommand">-d ' '</font>, it will read only until the first space (which is the character 
						we are choosing to indicate the end of line). So, bash will save in the variable 
						<font class="bashcommand">VOL</font> only the volume in number of voxels and not in mm<sup>3</sup>. 
					</p>
					
					<p>
						<font class="bashcommand">
						$ fslstats /Users/myUserName/Desktop/MRI/subject001/LGN_L.nii.gz -V<br>
						<font class="bashcommand-result">196 186.920166</font><br>
						$ read -d ' ' VOL &lt;&lt;&lt; $(fslstats /Users/myUserName/Desktop/MRI/subject001/LGN_L.nii.gz -V)<br>
						$ echo $VOL<br>
						<font class="bashcommand-result">196</font>
						</font>
					</p>					
		    </div>
		    
		    <div id="content4" class="hidden">
		    	<h2>4. Arithmetic calculations</h2>
		    	<h3>4.1. Integer calculations</h3>
			    	<p>In order to compute arithmetic calculations with integers you can use one of the following syntaxes:</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Syntax</b></th>
							<th style="width:70%"><b>Usage</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">$(( OPERATION ))</font>
							</td>
							<td>
								Evaluates <font class="bashcommand">OPERATION</font>. This can be any arithmetic operation with 
								integer numbers. Including addition (<font class="bashcommand">+</font>), subtraction 
								(<font class="bashcommand">-</font>), multiplication (<font class="bashcommand">*</font>), division 
								(<font class="bashcommand">&#247;</font>), square root (<font class="bashcommand">sqrt(NUM)</font>), 
								exponentiation (<font class="bashcommand">NUM**EXP</font>), etc.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((++NUM))</font>
							</td>
							<td>
								Increases variable <font class="bashcommand">NUM</font> in 1 <u>before</u> evaluating any expression that 
								contains <font class="bashcommand">++NUM</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((NUM++))</font>
							</td>
							<td>
								Increases variable <font class="bashcommand">NUM</font> in 1 <u>after</u> evaluating any expression 
								that contains <font class="bashcommand">NUM++</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((--NUM))</font>
							</td>
							<td>
								Decreases variable <font class="bashcommand">NUM</font> in 1 <u>before</u> evaluating any expression 
								that contains <font class="bashcommand">--NUM</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((NUM--))</font>
							</td>
							<td>
								Decreases variable <font class="bashcommand">NUM</font> in 1 <u>after</u> evaluating any expression 
								that contains <font class="bashcommand">NUM--</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((VAR+=NUM))</font>
							</td>
							<td>
								Increases variable <font class="bashcommand">VAR</font> in <font class="bashcommand">NUM</font>. 
								Equivalent to <font class="bashcommand">VAR=$(( $VAR + $NUM ))</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">((VAR-=NUM))</font>
							</td>
							<td>
								Decreases variable <font class="bashcommand">VAR</font> in <font class="bashcommand">NUM</font>. 
								Equivalent to <font class="bashcommand">VAR=$(( $VAR - $NUM ))</font>.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">(( $i % 2 ))</font>
							</td>
							<td>
								<font class="bashcommand">true</font> if <font class="bashcommand">i</font> is an odd number, 
								<font class="bashcommand">false</font> if <font class="bashcommand">i</font> is even.
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">Usage of $(( OPERATION ))</font>
					</p>
					
					<table>
					<tr>
						<th style="width:30%"><b>Example</b></th>
						<th style="width:70%"><b>Explanation</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ echo $(( 2 + 1 ))<br>
								<font class="bashcommand-result">3</font>
							</font>
						</td>
						<td>2 + 1</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
							$ A=2<br>
							$ echo $(( ${A} + 1 ))<br>
							<font class="bashcommand-result">3</font>
							</font>
						</td>
						<td>A + 1</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( ${A} + ${B} ))<br>
								<font class="bashcommand-result">3</font>
							</font>
						</td>
						<td>A + B</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( ${A} - ${B} ))<br>
								<font class="bashcommand-result">1</font>
							</font>
						</td>
						<td>A - B</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( ${A} * ${B} ))<br>
								<font class="bashcommand-result">2</font>
							</font>
						</td>
						<td>A x B</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( ${A} / ${B} ))<br>
								<font class="bashcommand-result">2</font>
							</font>
						</td>
						<td>A &#247; B</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( $(( ${A} + ${B} )) * $(( ${A} - ${B} )) ))<br>
								<font class="bashcommand-result">3</font>
							</font>
						</td>
						<td>(A + B) x (A - B)</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=1<br>
								$ echo $(( ${B} / ${A} ))<br>
								<font class="bashcommand-result">0</font>
							</font>
						</td>
						<td>
							B &#247; A<br>
							The result is zero because this syntax is used for integer numbers. So, if the result of the operation 
							is not an integer, it will be rounded to the nearest integer. In the following section you will learn 
							how to operate with non-integer numbers. 
						</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ echo $(( ${A} ** 3 ))<br>
								<font class="bashcommand-result">8</font>
							</font>
						</td>
						<td>A<sup>3</sup></td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=2<br>
								$ B=4<br>
								$ echo $(( ${A} ** ${B} ))<br>
								<font class="bashcommand-result">16</font>
							</font>
						</td>
						<td>A<sup>B</sup></td>
					</tr>
					</table>
					
					<p>
						<font class="example">Usage of ((++NUM)) and ((NUM++))</font>
						In order to increment the value of a variable by one, there are a couple of options. Some of these options will be 
						very useful when doing iterations (which you will learn later on).
					</p>
					
					<table>
					<tr>
						<th style="width:33%"><b>${NUM} + 1</b></th>
						<th style="width:34%"><b>((++NUM))</b></th>
						<th style="width:33%"><b>((NUM++))</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
							$ NUM=1<br>
							$ echo $(( ${NUM} + 1 ))<br>
							<font class="bashcommand-result">2</font><br>
							$ echo ${NUM}<br>
							<font class="bashcommand-result">1</font><br><br>
							</font>
								
							The command echo <font class="bashcommand">$(( ${NUM} + 1 ))</font> prints the result of 
							<font class="bashcommand">NUM</font> plus one, but it does not modify the value of 
							<font class="bashcommand">NUM</font>. For that reason, when <font class="bashcommand">NUM</font> is 
							echoed at the end, it still has value 1 (instead of 2).
						</td>
						<td>
							<font class="bashcommand">
								$ NUM=1<br>
								$ echo $((++NUM))<br>
								<font class="bashcommand-result">2</font><br>
								$ echo ${NUM}<br>
								<font class="bashcommand-result">2</font><br><br>
							</font>
							
							The command <font class="bashcommand">echo $((++NUM))</font> is equivalent to this sequence of 
							instructions:<br><br>
							
							<font class="bashcommand">
								$ NUM=$(( ${NUM} + 1 ))<br>
								$ echo ${NUM}<br><br>
							</font>
							
							First, increases the value of variable <font class="bashcommand">NUM</font> in one, and then it echoes 
							the result. Opposite to the example in the left, here the variable value is actually modified. And 
							opposite to the example in the right, the variable value is modified before the other instruction 
							(<font class="bashcommand">echo</font>).
						</td>
						<td>
							<font class="bashcommand">
								$ NUM=1<br>
								$ echo $((NUM++))<br>
								<font class="bashcommand-result">1</font><br>
								$ echo ${NUM}<br>
								<font class="bashcommand-result">2</font><br><br>
							</font>
							
							The command echo <font class="bashcommand">$((NUM++))</font> is equivalent to this sequence of 
							instructions:<br><br>
							
							<font class="bashcommand">
								$ echo ${NUM}<br>
								$ NUM=$(( ${NUM} + 1 ))<br><br>
							</font>
							
							First echoes the value of <font class="bashcommand">NUM</font>. Then, it increases the value of the 
							variable. 
						</td>		
					</tr>
					</table><br>
					
					<table>
					<tr>
						<th style="width:33%"><b>${NUM} + 1</b></th>
						<th style="width:34%"><b>((++NUM))</b></th>
						<th style="width:33%"><b>((NUM++))</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ NUM=1<br>
								$ A=$(( ${NUM} + 1 ))<br>
								$ echo ${A}<br>
								<font class="bashcommand-result">2</font><br>
								$ echo ${NUM}<br
								<font class="bashcommand-result">1</font><br><br>
							</font>
							
							The command <font class="bashcommand">A=$(( ${NUM} + 1 ))</font> assigns to 
							<font class="bashcommand">A</font> the value of <font class="bashcommand">NUM</font> plus one, but it 
							does not modify the value of <font class="bashcommand">NUM</font>.
						</td>
						<td>
							<font class="bashcommand">
								$ NUM=1<br>
								$ A=$((++NUM))<br>
								$ echo ${A}<br>
								<font class="bashcommand-result">2</font><br>
								$ echo ${NUM}<br>
								<font class="bashcommand-result">2</font><br><br>
							</font>
							
							The command <font class="bashcommand">A=$((++NUM))</font> is equivalent to this sequence of 
							instructions:<br><br>
							
							<font class="bashcommand">
								$ NUM=$(( ${NUM} + 1 ))<br>
								$ A=${NUM}<br><br>
							</font>
							
							First increases the value of variable <font class="bashcommand">NUM</font> in one, and then it assigns 
							the new value to <font class="bashcommand">A</font>. So, after the operation both variables 
							(<font class="bashcommand">A</font> and <font class="bashcommand">NUM</font>) will have value 2.
						</td>
						<td>
							<font class="bashcommand">
								$ NUM=1<br>
								$ A=$((NUM++))<br>
								$ echo ${A}<br>
								<font class="bashcommand-result">1</font><br>
								$ echo ${NUM}<br>
								<font class="bashcommand-result">2</font><br><br>
							</font>
							
							The command <font class="bashcommand">A=$((NUM++))</font> is equivalent to this sequence of 
							instructions:<br><br>
							
							<font class="bashcommand">
								$ A=${NUM}<br>
								$ NUM=$(( ${NUM} + 1 ))<br><br>
							</font>
							
							First assigns the value of <font class="bashcommand">NUM</font> to the new variable <font class="bashcommand">A</font>. 
							After that, it increases the value of <font class="bashcommand">NUM</font>. So, if the initial value of 
							<font class="bashcommand">NUM</font> was 1, after the operation <font class="bashcommand">A</font> will equal 1 and 
							<font class="bashcommand">NUM</font> will equal 2.
						</td>
					</tr>
					</table>
					
					<p>
						<font class="example">Usage of ((--NUM)) and ((NUM--))</font>
						Expressions <font class="bashcommand">((--NUM))</font> and <font class="bashcommand">((NUM--))</font> work in 
						a very similar way than the previous ones, but instead of increasing the value of
						 <font class="bashcommand">NUM</font> by one, they decrease the value of <font class="bashcommand">NUM</font> 
						 by one. These expressions will also be very useful once you learn iteration. 
					</p>
					
					<table>
						<tr>
							<th style="width:33%"><b>${NUM} - 1</b></th>
							<th style="width:34%"><b>((--NUM))</b></th>
							<th style="width:33%"><b>((NUM--))</b></th>
						</tr>
						<tr>
							<td>
							<font class="bashcommand">
								$ NUM=1<br>
								$ echo $(( ${NUM} - 1 ))<br>
								<font class="bashcommand-result">0</font><br>
								$ echo ${NUM}<br>
								<font class="bashcommand-result">1</font><br><br>		
							</font>
		
							The command echo <font class="bashcommand">$(( ${NUM} - 1 ))</font> prints the result of 
							<font class="bashcommand">NUM</font> minus one, but it does not modify the value of 
							<font class="bashcommand">NUM</font>. For that reason, when <font class="bashcommand">NUM</font> is echoed 
							at the end, it still has value 1 (instead of 0).
							</td>
							
							<td>
							<font class="bashcommand">
								$ NUM=1<br>
								$ echo $((--NUM))<br>
								<font class="bashcommand-result">0</font><br>
								$ echo ${NUM}<br>
								<font class="bashcommand-result">0</font><br><br>
							</font>
		
							The command echo <font class="bashcommand">$((--NUM))</font> is equivalent to this sequence of instructions:<br><br>
		
							<font class="bashcommand">
								$ NUM=$(( ${NUM} - 1 ))<br>
								$ echo ${NUM}<br><br>
							</font>
		
							First, decreases the value of variable <font class="bashcommand">$NUM</font> in one, and then it echoes the 
							result. Opposite to the example in the left, here the variable value is actually modified. And opposite to 
							the example in the right, the variable value is modified before the other instruction 
							(<font class="bashcommand">=</font>).
							</td>
							
							<td>
								<font class="bashcommand">
									$ NUM=1<br>
									$ echo $((NUM--))<br>
									<font class="bashcommand-result">1</font><br>
									$ echo ${NUM}<br>
									<font class="bashcommand-result">0</font><br><br>
								</font>
			
								The command echo <font class="bashcommand">$((NUM--))</font> is equivalent to this sequence of 
								instructions:<br><br>
			
								<font class="bashcommand">
									$ echo ${NUM}<br>
									$ NUM=$(( ${NUM} - 1 ))<br><br>
								</font>
			
								First, echoes the value of <font class="bashcommand">NUM</font>. Then, it decreases the value of the 
								variable. 
							</td>
						</tr>
					</table><br>
					
					<table>
						<tr>
							<th style="width:33%"><b>${NUM} - 1</b></th>
							<th style="width:34%"><b>((--NUM))</b></th>
							<th style="width:33%"><b>((NUM--))</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ NUM=1<br>
									$ A=$(( ${NUM} - 1 ))<br>
									$ echo ${A}<br>
									<font class="bashcommand-result">0</font><br>
									$ echo ${NUM}<br>
									<font class="bashcommand-result">1</font><br><br>
								</font>
								
								The command <font class="bashcommand">A=$(( ${NUM} - 1 ))</font> assigns to 
								<font class="bashcommand">A</font> the value of <font class="bashcommand">NUM</font> minus one, but it 
								does not modify the value of <font class="bashcommand">NUM</font>.
							</td>
							<td>
								<font class="bashcommand">
									$ NUM=1<br>
									$ A=$((--NUM))<br>
									$ echo ${A}<br>
									<font class="bashcommand-result">0</font><br>
									$ echo ${NUM}<br>
									<font class="bashcommand-result">0</font><br><br>
								</font>
								
								The command <font class="bashcommand">A=$((--NUM))</font> is equivalent to this sequence of 
								instructions:<br><br>
								
								<font class="bashcommand">
									$ NUM=$(( ${NUM} - 1 ))<br>
									$ A=${NUM}<br><br>
								</font>			
								
								First, decreases the value of variable <font class="bashcommand">NUM</font> in one, and then it assigns 
								the new value to <font class="bashcommand">A</font>. So, after the operation both variables 
								(<font class="bashcommand">A</font> and <font class="bashcommand">NUM</font>) will have value 0.			
							</td>
							<td>
								<font class="bashcommand">
									$ NUM=1<br>
									$ A=$((NUM--))<br>
									$ echo ${A}<br>
									<font class="bashcommand-result">1</font><br>
									$ echo ${NUM}<br>
									<font class="bashcommand-result">0</font><br><br>
								</font>
								
								The command <font class="bashcommand">A=$((NUM--))</font> is equivalent to this sequence of 
								instructions:<br><br>
								
								<font class="bashcommand">
									$ A=${NUM}<br>
									$ NUM=$(( ${NUM} - 1 ))<br><br>
								</font>
								
								First, assigns the value of <font class="bashcommand">NUM</font> to the new variable 
								<font class="bashcommand">A</font>. After that, it increases the value of 
								<font class="bashcommand">NUM</font>. So, if the initial value of <font class="bashcommand">NUM</font> was 
								1, after the operation <font class="bashcommand">A</font> will equal 1 and 
								<font class="bashcommand">NUM</font> will equal 2.
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">Usage of ((VAR+=NUM))</font>
						This expression is a compact way of writing <font class="bashcommand">VAR=$(( ${VAR} + ${NUM} ))</font>
					</p>
					
					<table>
					<tr>
						<th style="width:30%"><b>Compact expression</b></th>
						<th style="width:70%"><b>Extended equivalent</b></th>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ ((A+=2))<br>
								$ echo ${A}<br>
								<font class="bashcommand-result">3</font><br><br>
							</font>				
						</td>
						<td>
							<font class="bashcommand">((A+=2))</font> is equivalent to:<br><br>
		
							<font class="bashcommand">A=$(( ${A} + 2 ))</font>
						</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ B=$((A+=2))<br>
								$ echo ${A}<br>
								<font class="bashcommand-result">3</font><br>
								$ echo ${B}<br>
								<font class="bashcommand-result">3</font><br>
							</font>
						</td>
						<td>
							<font class="bashcommand">B=$((A+=2))</font> is equivalent to this sequence of instructions:<br><br>
		
							<font class="bashcommand">
								$ A=$(( ${A} + 2 ))<br>
								$ B=${A}
							</font>
						</td>
					</tr>		
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ B=9<br>
								$ ((A+=B))<br>
								$ echo ${A}<br>
								<font class="bashcommand-result">10</font><br>
								$ echo ${B}<br>
								<font class="bashcommand-result">9</font>
							</font>					
						</td>
						<td>
							<font class="bashcommand">((A+=B))</font> is equivalent to:<br><br>
		
							<font class="bashcommand">$ A=$(( ${A} + ${B} ))</font><br><br>
		
							The value of <font class="bashcommand">B</font> is not being modified.
						</td>
					</tr>
					<tr>
						<td>
							<font class="bashcommand">
								$ A=1<br>
								$ B=9<br>
								$ B=$((A+=B))<br>
								$ echo ${A}<br>
								<font class="bashcommand-result">10</font><br>
								$ echo ${B}<br>
								<font class="bashcommand-result">10</font>
							</font>
						</td>
						<td>
							<font class="bashcommand">B=$((A+=B))</font> is equivalent to this sequence of instructions:<br><br>
	
							<font class="bashcommand">
								$ A=$(( ${A} + ${B} ))<br>
								$ B=${A}<br><br>
							</font>
	
							In this case, the value of <font class="bashcommand">B</font> is being modified because the result of 
							<font class="bashcommand">((A+=B))</font> is being assigned to it (opposite to the previous example).
						</td>
					</tr>	
					</table>
					
					<p>
						<font class="example">Usage of ((VAR-=NUM))</font>
						This expression is a compact way of writing: <font class="bashcommand">VAR=$(( ${VAR} - ${NUM} ))</font>
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Compact expression</b></th>
							<th style="width:70%"><b>Extended equivalent</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ A=1<br>
									$ ((A-=2))<br>
									$ echo ${A}<br>
									<font class="bashcommand-result">-1</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">((A-=2))</font> is equivalent to:<br><br>
	
								<font class="bashcommand">A=$(( ${A} - 2 ))</font>
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ A=1<br>
									$ B=$((A-=2))<br>
									$ echo ${A}<br>
									<font class="bashcommand-result">-1</font><br>
									$ echo ${B}<br>
									<font class="bashcommand-result">-1</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">B=$((A-=2))</font> is equivalent to this sequence of instructions:<br><br>
	
								<font class="bashcommand">
									$ A=$(( ${A} - 2 ))<br>
									$ B=${A}	
								</font>				
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ A=1<br>
									$ B=9<br>
									$ ((A-=B))<br>
									$ echo ${A}<br>
									<font class="bashcommand-result">-8</font><br>
									$ echo ${B}<br>
									<font class="bashcommand-result">9</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">((A-=B))</font> is equivalent to:<br><br>
	
								<font class="bashcommand">$ A=$(( ${A} - ${B} ))</font><br><br>
								
								The value of <font class="bashcommand">B</font> is not being modified.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">
									$ A=1<br>
									$ B=9<br>
									$ B=$((A-=B))<br>
									$ echo ${A}<br>
									<font class="bashcommand-result">-8</font><br>
									$ echo ${B}<br>
									<font class="bashcommand-result">-8</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">B=$((A-=B))</font> is equivalent to this sequence of instructions:<br><br>
	
								<font class="bashcommand">
									$ A=$(( ${A} - ${B} ))<br>
									$ B=${A}<br><br>
								</font>
								
								In this case, the value of B is being modified because the result of 
								<font class="bashcommand">((A-=B))</font> is being assigned to it (opposite to the previous 
								example).
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">Usage of (( $i % 2 ))</font>
						<font class="bashcommand">
							$for i in $(seq 10)<br>
							&gt; do<br>
							&gt; if (( $i % 2 ))<br>
							&gt; then<br>
							&gt; echo $i is odd<br>
							&gt; else<br>
							&gt; echo $i is even<br>
							&gt; fi<br>
							&gt; done<br>
							<font class="bashcommand-result">
							1 is odd<br>
							2 is even<br>
							3 is odd<br>
							4 is even<br>
							5 is odd<br>
							6 is even<br>
							7 is odd<br>
							8 is even<br>
							9 is odd<br>
							10 is even
							</font>
						</font>
					</p>
					
				<h3>4.2. Non-integer calculations</h3>
					<p>
						When programming in bash, you will often need to do mathematical operations that involve non-integer 
						calculations. To do this, you will need the <font class="bashcommand">bc</font> utility. You can use this 
						utility also for integer calculations, but it is normally left for advanced math.
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Syntax</b></th>
							<th style="width:70%"><b>Usage</b></th>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">echo "OPERATION" | bc</font>
							</td>
							<td>
								Evaluates <font class="bashcommand">OPERATION</font>. This can be any arithmetic operation with 
								integer or non-integer numbers. Including addition (<font class="bashcommand">+</font>), 
								subtraction (<font class="bashcommand">-</font>), multiplication 
								(<font class="bashcommand">*</font>), division (<font class="bashcommand">/</font>), square root 
								(<font class="bashcommand">sqrt(NUM)</font>), exponentiation 
								(<font class="bashcommand">NUM**EXP</font>), etc. It will round the result to the closest 
								integer.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">echo "OPERATION" | bc -l</font>
							</td>
							<td>
								Flag <font class="bashcommand">-l</font> will not round the result. Instead, will print it with 
								all the decimals.
							</td>
						</tr>
						<tr>
							<td>
								<font class="bashcommand">echo "scale=NDECIMALS; OPERATION" | bc -l</font>
							</td>
							<td>
								Will only print <font class="bashcommand">NDECIMALS</font> instead of all the decimals.
							</td>
						</tr>
					</table><br>
					
					<font class="example">echo "OPERATION" | bc</font>
					<p>
						<font class="bashcommand">
							$ echo "2.34 / 1.895" | bc<br>
							<font class="bashcommand-result">1</font><br>
							$ echo "2 / 3" | bc<br>
							<font class="bashcommand-result">0</font>
						</font>
					</p>
					
					<font class="example">echo "OPERATION" | bc -l</font>
					<p>
						<font class="bashcommand">
							$ echo "2.34 / 1.895" | bc -l<br>
							<font class="bashcommand-result">1.23482849604221635883</font><br>
							$ echo "2 / 3" | bc -l<br>
							<font class="bashcommand-result">.66666666666666666666</font>
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ A=$(echo "2.34 / 1.895" | bc)<br>
							$ B=$(echo "2.34 / 1.895" | bc -l)<br>
							$ echo ${A}<br>
							<font class="bashcommand-result">1</font><br>
							$ echo ${B}<br>
							<font class="bashcommand-result">1.23482849604221635883</font><br>
							$ echo "${A} + ${B}" | bc -l<br>
							<font class="bashcommand-result">2.23482849604221635883</font><br>
							$ echo "${A} + ${B}"<br>
							<font class="bashcommand-result">1 + 1.23482849604221635883</font>
						</font>
					</p>
					
					<p>
						Look at the difference between the last two expressions. They are almost the same except for the 
						<font class="bashcommand">| bc -l</font> at the end of the first expression. Yet, the results are very 
						different. That is because in the second case we are just printing the text 
						<font class="bashcommand">"${A} + ${B}"</font>, while in the first one we are evaluating the expression 
						written in that text, with the use of the <font class="bashcommand">bc</font> utility. The following 
						example may clarify this concept:
					</p>
					
					<p>
						<font class="bashcommand">
							$ echo "${A} + ${B}=$(echo "${A} + ${B}" | bc -l)"<br>
							<font class="bashcommand-result">1 + 1.23482849604221635883=2.23482849604221635883</font>
						</font>
					</p>
					
					<p>
						To find the square root of a number you use the expression <font class="bashcommand">sqrt()</font>, like 
						in many other programming languages.
					</p>
					
					<font class="example">finding the square root of 10 and saving it in variable A</font>
					<p>
						<font class="bashcommand">
							$ A=$(echo "sqrt (10)" | bc -l)<br>
							$ echo ${A}<br>
							<font class="bashcommand-result">3.16227766016837933199</font>
						</font>
					</p>
					
					<p>
						Knowing this, you can do any type of operations with non-integer numbers. Just by writing the desired 
						expression between the quotation marks, or combine integer and non-integer calculations. Let’s look at 
						a few more examples:
					</p>
					
					<font class="bashcommand">
						<p>
							$ echo "(2.34 / 1.895) + sqrt (10)" | bc -l<br>
							<font class="bashcommand-result">4.39710615621059569082</font><br>
							$ echo $((2**3))<br>
							<font class="bashcommand-result">12.397106156210595690828</font><br>
							$ echo "(2.34 / 1.895) + sqrt (10) + $((2**3))" | bc -l<br>
							<font class="bashcommand-result">12.39710615621059569082</font><br>
							$ echo "(2.34 / 1.895) + sqrt (10) + 2^3" | bc -l<br>
							<font class="bashcommand-result">12.39710615621059569082</font><br>
							$ echo "2 + 2" | bc -l<br>
							<font class="bashcommand-result">4</font><br>
							$ echo "2 + 2"<br>
							<font class="bashcommand-result">2 + 2</font><br>
							$ echo "2 + 2 = $(echo "2 + 2" | bc -l)"<br>
							<font class="bashcommand-result">2 + 2 = 4</font>
						</p>	
							
						<p>
							$ A=$(echo "(2.34 / 1.895) + sqrt (10)" | bc -l)<br>
							$ echo ${A}<br>
							<font class="bashcommand-result">4.39710615621059569082</font><br>
							$ echo $(echo "(2.34 / 1.895) + sqrt (10)" | bc -l)<br>
							<font class="bashcommand-result">4.39710615621059569082</font><br>
							$ echo "(2.34 / 1.895) + sqrt (10)= $(echo "(2.34 / 1.895) + sqrt (10)" | bc -l)"<br>
							<font class="bashcommand-result">(2.34 / 1.895) + sqrt (10)= 4.39710615621059569082</font>				
						</p>
					</font>
					
					<font class="example">echo "scale=NDECIMALS; OPERATION" | bc -l</font>
					<p>
						Clearly, some of the results of the previous examples have way too many decimals. You can cut the number 
						of decimals using scale.
					</p>
					
					<p>
						<font class="bashcommand">
							$ echo "(2.34 / 1.895) + sqrt (10)" | bc -l<br>
							<font class="bashcommand-result">4.39710615621059569082</font><br>
							$ echo "scale=3; (2.34 / 1.895) + sqrt (10)" | bc -l<br>
							<font class="bashcommand-result">4.396</font><br>
							$ echo "scale=0; (2.34 / 1.895) + sqrt (10)" | bc -l<br>
							<font class="bashcommand-result">4</font>
						</font>
					</p>
					
					<font class="example">Comparing non-integers</font>
					<p>
						In order to compare non-integers you can use the <font class="bashcommand">awk</font> function. This 
						function will be studied more in detail in later chapters as it is mainly used for processing files and 
						strings. But as this example shows, it can also be used to deal with numbers.
					</p>
		    </div>
		    
		    <div id="content5" class="hidden">
		    	<h2>5. Arrays</h2>
		    	<h3>5.1. Declaring and assigning values</h3>
			    	<p>
						An array is a data structure that stores a group of elements and allows you to access each element 
						individually or all elements sequentially. For example, you can have an array of subject IDs. The first 
						object in the array would be the ID of your first subject; the second object would be the ID of your 
						second subject, and so on. An analogy could be a To Do List. In that case, you would have an array of 
						things to do and you can ask yourself what is the first thing in your To-Do list, the second thing, or 
						the last thing, etc. There are different ways of creating an array, as well as different ways of adding 
						elements to it:
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Syntax</b></th>
							<th style="width:70%"><b>Usage</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY[INDEX]=VAL</font>
							</td>
							<td>
								If <font class="bashcommand">ARRAY</font> hasn't been initialized, it will create the array and 
								put element <font class="bashcommand">VAL</font> in the position 
								<font class="bashcommand">INDEX</font>. The first element of an array is always in 
								<font class="bashcommand">INDEX=0</font>, instead of <font class="bashcommand">INDEX=1</font>. 
								If <font class="bashcommand">ARRAY</font> already exists, it will replace 
								<font class="bashcommand">ARRAY</font> in the position <font class="bashcommand">INDEX</font> by 
								the value <font class="bashcommand">VAL</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">declare -a ARRAY=('VAL1' 'VAL2' 'VAL3' ...)</font>
							</td>
							<td>
								Initializes <font class="bashcommand">ARRAY</font> and puts the values inside the parenthesis 
								into the array, respecting the same order. You can specify any number of values. The array is 
								emptied before assigning the values if it already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">read -a ARRAY</font>
							</td>
							<td>
								The words that the user inputs are assigned to sequential indices of 
								<font class="bashcommand">ARRAY</font>. The words must be separated by spaces. The array is 
								emptied before assigning the values if it already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">IFS='DEL' read -a ARRAY</font>
							</td>
							<td>
								Splits the user input using delimiter <font class="bashcommand">DEL</font>, which must be a 
								character or a space. Then, saves the different elements into 
								<font class="bashcommand">ARRAY</font>. The array is emptied before assigning the values if it 
								already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">IFS='DEL' read -a ARRAY &lt;&lt;&lt; STRING</font>
							</td>
							<td>
								Splits <font class="bashcommand">STRING</font> using delimiter 
								<font class="bashcommand">DEL</font>, which must be a character or a space. Then, saves the 
								different elements into <font class="bashcommand">ARRAY</font>. The array is emptied before 
								assigning the values if it already exists.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=($(seq FIRST STEP SIZE))</font>
							</td>
							<td>
								Creates an array of equally spaced numbers beginning with <font class="bashcommand">FIRST</font> 
								and separated by <font class="bashcommand">STEP</font>. It will add 
								<font class="bashcommand">SIZE</font> numbers to <font class="bashcommand">ARRAY</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=$(count -digits N FIRST LAST)</font>
							</td>
							<td>
								Creates an array of numbers, each with <font class="bashcommand">N</font> number of digits, 
								starting with <font class="bashcommand">FIRST</font> and ending with 
								<font class="bashcommand">LAST</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=$(seq N)</font>
							</td>
							<td>
								Creates an array of sequential numbers, starting with 1 and ending with 
								<font class="bashcommand">N</font>.
							</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">ARRAY=(ELEMENT1 ELEMENT3 ...)</font>
							</td>
							<td>
								Creates an array with the elements specified inside the parenthesis.
							</td>
						</tr>
					</table>
					
					<p>
						In the following examples we will use the syntax <font class="bashcommand">${ARRAY[INDEX]}</font> to 
						access the element located in the position <font class="bashcommand">INDEX</font> inside 
						<font class="bashcommand">ARRAY</font>. Remember that the first item in an array has index 0, the second 
						item has index 1, etc. I will also use the syntax <font class="bashcommand">${#ARRAY[@]}</font> to get 
						the number of non-empty values inside <font class="bashcommand">ARRAY</font>.
					</p>
					
					<font class="example">ARRAY[INDEX]=VAL</font>
					<p>
						Create an array of subjects' age where each element in the array corresponds to the age of one subject. 
						There are five subjects, so the size of the array is five. Remember, subject 1 will have its age in the 
						position 0, subject 2 in the position 1, etc. This is because <u>in bash, arrays start in the position 0 
						instead of position 1</u>. After assigning all the values to my array, I can print its contents using 
						the expression echo <font class="bashcommand">${ARRAY[@]}</font>. I can also check the size of my array 
						using <font class="bashcommand">echo ${#ARRAY[@]}</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ age[0]=59<br>
							$ age[1]=63<br>
							$ age[2]=21<br>
							$ age[3]=15<br>
							$ age[4]=94<br>
							$ echo ${age[@]}<br>
							<font class="bashcommand-result">59 63 21 15 94</font><br>
							$ echo "Array size: ${#age[@]}"<br>
							<font class="bashcommand-result">Array size: 5</font>
						</font>
					</p>
					
					<p>
						In the following example, I will start assigning values to the array in the position 1 (instead of 0). 
						That is not a problem, but the first position of my array (index=0) will remain empty, and my array will 
						have only 4 values. If I echo the item in position 0 (echo <font class="bashcommand">${ARRAY[0]}</font>), 
						I will get an empty string.
					</p>
					
					<p>
						<font class="bashcommand">
							$ age[1]=63<br>
							$ age[2]=21<br>
							$ age[3]=15<br>
							$ age[4]=94<br>
							$ echo ${age[@]}<br>
							<font class="bashcommand-result">63 21 15 94</font><br>
							$ echo "Array size: ${#age[@]}"<br>
							<font class="bashcommand-result">Array size: 4</font><br>
							$ echo "age(0): ${age[0]} "<br>
							<font class="bashcommand-result">age(0):</font>
						</font>
					</p>
					
					<p>
						<font class="example">declare -a ARRAY=('VAL1' 'VAL2' 'VAL3' ...)</font>
						It is also possible to initiate an array and assign all the values at the same time. To print an element 
						of the array, located in the position <font class="bashcommand">INDEX</font>, you must use the expression 
						<font class="bashcommand">${ARRAY[INDEX]}</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Germany' 'Spain' 'Canada')<br>
							$ echo "The element in position 0 is: ${array[0]}"<br>
							<font class="bashcommand-result">The element in position 0 is: Colombia</font><br>
							$ echo "The element in position 1 is: ${array[1]}"<br>
							<font class="bashcommand-result">The element in position 1 is: United States</font><br>
							$ echo "The element in position 2 is: ${array[2]}"<br>
							<font class="bashcommand-result">The element in position 2 is: Germany</font><br>
							$ echo "The element in position 3 is: ${array[3]}"<br>
							<font class="bashcommand-result">The element in position 3 is: Spain</font><br>
							$ echo "The element in position 4 is: ${array[4]}"<br>
							<font class="bashcommand-result">The element in position 4 is: Canada</font><br>
							$ echo "List of elements in the array: ${array[@]}"<br> 
							<font class="bashcommand-result">List of elements in the array: Colombia United States Germany Spain Canada</font><br>
							$ echo "The number of elements in the array is ${#array[@]}"<br>
							<font class="bashcommand-result">The number of elements in the array is 5</font>
						</font>
					</p>
					
					<p>
						After you declare an array, it doesn't need to stay static. You can keep adding items:
					</p>
					
					<p>
						<font class="bashcommand">
							$ array[5]="Argentina"<br>
							$ array[6]="France"<br>
							$ echo "List of elements in the array: ${array4[@]}"<br>
							<font class="bashcommand-result">List of elements in the array: Colombia United States Germany Spain Canada Argentina France</font>
						</font>
					</p>
					
					<p>
						<font class="example">read -a ARRAY</font>
						Another way of creating and initializing an array is by reading a user input. As we previously learned, 
						the command read captures the user input and saves it in a variable. By using the flag 
						<font class="bashcommand">-a</font>, the user can input more than one word (separated by a space) and bash 
						will assign each word to sequential indexes of the array, starting at 0.
					</p>
					
					<p>
						<font class="bashcommand">
							$ read -a ARRAY<br>
							<font class="bashcommand-result">Element1 Element2 Element3</font><br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">Element1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Element2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Element3</font>
						</font>
					</p>
					
					<p>
						<font class="example">IFS='DEL' read -a ARRAY</font>
						If you want to use a different delimiter other than a space to split the user input into array elements, 
						you can add <font class="bashcommand">IFS='DEL'</font> before the read command, with 
						<font class="bashcommand">DEL</font> being any character.
					</p>
					
					<font class="bashcommand">
						<p>
							$ IFS='/' read -a ARRAY<br>
							<font class="bashcommand-result">Element1/Element2/Element3</font><br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">Element1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Element2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Element3</font>
						</p>
						
						<p>
							$ IFS='.' read -a ARRAY<br>
							<font class="bashcommand-result">1.2.3</font><br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">3</font>
						</p>
					</font>
					
					<p>
						<font class="example">IFS='DEL' read -a ARRAY &lt;&lt;&lt; STRING</font>
						The same way as you can split a user input into elements of an array using a specific delimiter, you can 
						split elements of a string. This is very useful when trying to retain parts of a file path.
					</p>
					
					<p>
						<font class="bashcommand">
							$ IFS='/' read -a ARRAY &lt;&lt;&lt; "Element1/Element2/Element3"<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">Element1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Element2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Element3</font>
						</font>
					</p>
					
					<p>
						In the following example, the input string (<font class="bashcommand">/Element1/Element2/Element3</font>) 
						starts with the delimiter (<font class="bashcommand">/</font>). So, when you split it, 
						<font class="bashcommand">Element1</font> will be in position 1 (not in position 0), because the element 
						in position 0 would be the string located before the first appearance of the delimiter (which is an 
						empty string). 
					</p>
					
					<font class="bashcommand">
						<p>
							$ IFS='/' read -a ARRAY &lt;&lt;&lt; "/Element1/Element2/Element3"<br>
							$ echo ${ARRAY[0]}<br>
							<br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Element1</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Element2</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">Element3</font>
						</p>
						
						<p>
							$ IFS='/' read -a ARRAY &lt;&lt;&lt; "./Folder/Subfolder/file.txt"<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">.</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">Folder</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">Subfolder</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">file.txt</font>
						</p>
						
						<p>
							$ IFS='.' read -a ARRAY &lt;&lt;&lt; "1.2.3"<br>
							<font class="bashcommand-result">1.2.3</font><br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">2</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">3</font>
						</p>
						
						<p>
							$ IFS='.' read -a ARRAY &lt;&lt;&lt; "23.485"<br>
							$ echo "The integer part is ${ARRAY[0]}, and the decimal part is 0.${ARRAY[1]}"<br>
							<font class="bashcommand-result">The integer part is 23, and the decimal part is 0.485</font>
						</p>
					</font>
					
					<p>
						<font class="example">ARRAY=($(seq FIRST STEP SIZE))</font>
						You can also create an array of equally spaced or consecutive numbers in a very easy way using the 
						command <font class="bashcommand">seq</font>. In this example, I will create an array of numbers that go 
						from 15 to 19. The distance between each number (<font class="bashcommand">STEP</font>) is 0.5.
					</p>
					
					<p>
						<font class="bashcommand">
							$ ARRAY=($(seq 15 0.5 19))<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">15</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">15.5</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">16</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">16.5</font><br>
							$ echo ${ARRAY[4]}<br>
							<font class="bashcommand-result">17</font><br>
							$ echo ${ARRAY[5]}<br>
							<font class="bashcommand-result">17.5</font><br>
							$ echo ${ARRAY[6]}<br>
							<font class="bashcommand-result">18</font><br>
							$ echo ${ARRAY[7]}<br>
							<font class="bashcommand-result">18.5</font><br>
							$ echo ${ARRAY[8]}<br>
							<font class="bashcommand-result">19</font>
						</font>
					</p>
					
					<p>
						In this example, I will create an array of numbers that go from 1 to 10. The distance between each 
						number (<font class="bashcommand">STEP</font>) is 2. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ ARRAY=($(seq 1 2 10))<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">1</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">3</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">5</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">7</font><br>
							$ echo ${ARRAY[4]}<br>
							<font class="bashcommand-result">9</font>
						</font>
					</p>
					
					<p>
						When the step between the numbers is 1, it doesn't need to be written:<br>
	 					<font class="bashcommand">($(seq 15 1 19))</font> is the same as 
	 					<font class="bashcommand">($(seq 15 19))</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ ARRAY=($(seq 15 19))<br>
							$ echo ${ARRAY[0]}<br>
							<font class="bashcommand-result">15</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">16</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">17</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">18</font><br>
							$ echo ${ARRAY[4]}<br>
							<font class="bashcommand-result">19</font>
						</font>
					</p>
					
					<font class="example">ARRAY=(ELEMENT1 ELEMENT2 ELEMENT3 ...)</font>
					
					<p>
						<font class="bashcommand">
							$ array=(e1 e2 e3 e4 e5 e6)<br>
							$ echo ${array[0]}<br>
							<font class="bashcommand-result">e1</font><br>
							$ echo ${array[1]}<br>
							<font class="bashcommand-result">e2</font><br>
							$ echo ${array[2]}<br>
							<font class="bashcommand-result">e3</font><br>
							$ echo ${array[3]}<br>
							<font class="bashcommand-result">e4</font><br>
							$ echo ${array[4]}<br>
							<font class="bashcommand-result">e5</font><br>
							$ echo ${array[5]}<br>
							<font class="bashcommand-result">e6</font>
						</font>
					</p>
					
					<p>
						Bash and other programs have functions that return a list of elements. For example, as you will learn in 
						the section of file manipulation, the command <font class="bashcommand">ls</font> returns the list of 
						files in your current working directory. In these cases, instead of manually entering a list of elements 
						between parentheses to convert into an array, you can write the function name, and its output will be saved in the array:
					</p>
					
					<font class="bashcommand">
						<p>
							$ ls<br>
							<font class="bashcommand-result">
							<table class="ghostTable">
								<tr>
									<td>@update.afni.binaries</td>
									<td>Downloads</td>
									<td>abin</td>
								</tr>
								
								<tr>
									<td>AFNI_data5</td>
									<td>Library</td>
									<td>afni_handouts</td>
								</tr>
								
								<tr>
									<td>AFNI_data6</td>
									<td>Movies</td>
									<td>dax</td>
								</tr>
								
								<tr>
									<td>AFNI_demos</td>
									<td>Music</td>
									<td>std_meshes</td>
								</tr>
								
								<tr>
									<td>Desktop</td>
									<td>Pictures</td>
									<td>suma_demo</td>
								</tr>
								
								<tr>
									<td>Documents</td>
									<td>Public</td>
									<td>test.txt</td>
								</tr>
							</table>
							</font>
						</p>
						
						<p>
							$ array=($(ls))<br>
							$ echo ${array[0]}<br>
							<font class="bashcommand-result">@update.afni.binaries</font><br>
							$ echo ${array[1]}<br>
							<font class="bashcommand-result">AFNI_data5</font><br>
							$ echo ${array[2]}<br>
							<font class="bashcommand-result">AFNI_data6</font><br>
							$ echo ${array[3]}<br>
							<font class="bashcommand-result">AFNI_demos</font><br>
							$ echo ${array[4]}<br>
							<font class="bashcommand-result">Desktop</font>
						</p>
					</font>
					
				<h3>5.2. Array operations</h3>
					<p>Once you have initialized an array, you can do the following operations with it:</p>
					
					<table>
					<tr>
						<th style="width:30%"><b>Syntax</b></th>
						<th style="width:70%"><b>Usage</b></th>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${ARRAY[INDEX]}</font>
						</td>
						<td>
							Returns the element in position <font class="bashcommand">INDEX</font> inside 
							<font class="bashcommand">ARRAY</font>. The first index is 0, then 1, etc.<br>
							See the examples section of creating sub-strings 
							(<font class="bashcommand">${STRING:START:NUM}</font>) to know how to obtain a character in a 
							specific position inside a string instead of an array.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${#ARRAY[@]}</font><br>
							or<br>
							<font class="bashcommand">${#STRING}</font>
						</td>
						<td>
							Returns the size of <font class="bashcommand">ARRAY</font> (number of non-empty elements) or the 
							number of characters in <font class="bashcommand">STRING</font>.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${#ARRAY[INDEX]}</font>
						</td>
						<td>
							Returns the size of the element located in the position <font class="bashcommand">INDEX</font> 
							(number of characters).
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${ARRAY[@]}</font>
						</td>
						<td>
							Returns all the elements of <font class="bashcommand">ARRAY</font>.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${ARRAY[@]/OLD_ITEM/NEW_ITEM}</font>
						</td>
						<td>
							Replaces <b>all occurrences</b> of <font class="bashcommand">OLD_ITEM</font> by 
							<font class="bashcommand">NEW_ITEM</font>. You could use the symbols 
							<font class="bashcommand">*</font>, <font class="bashcommand">#</font> and 
							<font class="bashcommand">%</font> inside <font class="bashcommand">OLD_ITEM</font> to replace 
							all elements that follow a specific pattern (<a href="#ex5">see examples</a>).
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${STRING/OLD_ITEM/NEW_ITEM}</font>
						</td>
						<td>
							Replaces the <b>first occurrence</b> of <font class="bashcommand">OLD_ITEM</font> by 
							<font class="bashcommand">NEW_ITEM</font> in <font class="bashcommand">STRING</font> (a string 
							is an array of characters). You could use the symbols <font class="bashcommand">*</font>, 
							<font class="bashcommand">#</font> and <font class="bashcommand">%</font> inside 
							<font class="bashcommand">OLD_ITEM</font> to replace all elements that follow a specific pattern 
							(<a href="#ex6">see examples</a>).
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${STRING//OLD_ITEM/NEW_ITEM}</font>
						</td>
						<td>
							Replaces <b>all occurrences</b> of <font class="bashcommand">OLD_ITEM</font> by 
							<font class="bashcommand">NEW_ITEM</font> in <font class="bashcommand">STRING</font>. You could use 
							the symbols <font class="bashcommand">*</font>, <font class="bashcommand">#</font> and 
							<font class="bashcommand">%</font> inside <font class="bashcommand">OLD_ITEM</font> to replace all 
							elements that follow a specific pattern (<a href="#ex7">see examples</a>).
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">NEWARRAY=("${ARRAY[@]}")</font>
						</td>
						<td>
							Copy the elements of <font class="bashcommand">ARRAY</font> into 
							<font class="bashcommand">NEWARRAY</font>.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">NEWARRAY=("${ARRAY1[@]}" "${ARRAY2[@]}" "${ARRAY3[@]}" ...)</font>
						</td>
						<td>
							Concatenates arrays <font class="bashcommand">ARRAY1</font>, 
							<font class="bashcommand">ARRAY2</font>, and <font class="bashcommand">ARRAY3</font> into one 
							single array called <font class="bashcommand">NEWARRAY</font>. You can concatenate as many 
							arrays as you want.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">unset ARRAY</font>
						</td>
						<td>
							Deletes <font class="bashcommand">ARRAY</font> from memory.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">${ARRAY[@]:START:NUM}</font><br>
							or<br>
							<font class="bashcommand">${STRING:START:NUM}</font>
						</td>
						<td>
							Creates a sub-array from <font class="bashcommand">ARRAY</font> (or a sub-string from 
							<font class="bashcommand">STRING</font>). Beginning with the element in the position 
							<font class="bashcommand">START</font> and containing <font class="bashcommand">NUM</font> 
							number of elements.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">IFS=$'\n' sorted=($(sort &lt;&lt;&lt;"${array[*]}"))</font>
						</td>
						<td>
							Sorts in alphabetical order array and saves the result in sorted.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">IFS='+' sum=$(echo "scale=1;${array[*]}"|bc)</font>
						</td>
						<td>
							Adds all elements in array and saves the result in variable <font class="bashcommand">sum</font>.
						</td>
					</tr>
					
					<tr>
						<td>
							<font class="bashcommand">IFS='+' avg=$(echo "scale=1;(${array[*]})/${#array[@]}"|bc)</font>
						</td>
						<td>
							Calculates the average of elements in <font class="bashcommand">array</font> and saves the 
							result in variable <font class="bashcommand">avg</font>.
						</td>
					</tr>
				</table>
				
				<div id="ex1">
					<p><font class="example">${ARRAY[INDEX]}</font></p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Spain' 'Canada')<br>
							$ echo "The element of the array in position 0 is: ${array[0]}"<br>
							<font class="bashcommand-result">The element of the array in position 0 is: Colombia</font><br>
							$ echo "The element of the array in position 1 is: ${array[1]}"<br>
							<font class="bashcommand-result">The element of the array in position 1 is: United States</font>
						</font>
					</p>
				</div>
				
				<div id="ex2">
					<p><font class="example">${#ARRAY[@]}</font></p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Spain' 'Canada')<br>
							$ echo "The number of elements in the array is ${#array[@]}"<br>
							<font class="bashcommand-result">The number of elements in the array is 4</font>
						</font>
					</p>
				</div>
				
				<div id="ex3">
					<p>
						<font class="example">${#ARRAY[INDEX]}</font>
						<font class="bashcommand">${#ARRAY[INDEX]}</font> will return the number of characters of the element of 
						the array located in the specified index. <font class="bashcommand">Colombia</font> is in index 0, 
						<font class="bashcommand">United States</font> in index 1, <font class="bashcommand">Spain</font> in 
						index 2. <font class="bashcommand">Spain</font> has six characters, so 
						<font class="bashcommand">${#ARRAY[2]}=6</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Spain' 'Canada')<br>
							$ echo "The element in position 2 is ${array[2]}, and its size is ${#array[2]}"<br>
							<font class="bashcommand-result">The element in position 2 is Spain, and its size is 5</font>
						</font>
					</p>
				</div>
				
				<div id="ex4">
					<p><font class="example">${ARRAY[@]}</font></p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Spain' 'Canada')<br>
							$ echo ${array[@]}<br>
							<font class="bashcommand-result">Colombia United States Spain Canada</font>
						</font>
					</p>
				</div>
				
				<div id="ex5">
					<p>
						<font class="example">${ARRAY[@]/OLD_ITEM/NEW_ITEM}</font>
						Substitute all the instances of <font class="bashcommand">Colombia</font> 
						(<font class="bashcommand">OLD_ITEM</font>) by Spain (<font class="bashcommand">NEW_ITEM</font>) in 
						the array.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Colombia' 'United States' 'Colombia' 'Canada')<br>
							$ echo ${array[@]/Colombia/Spain}<br>
							<font class="bashcommand-result">Spain United States Spain Canada</font>
						</font>
					</p>
					
					<p>To remove an item, you simply substitute it by nothing (leave <font class="bashcommand">NEW_ITEM</font> 
					empty).</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a array=('Subject01' 'Subject01' 'Subject03' 'Subject04')<br>
							$ echo ${array[@]/Subject01/}<br>
							<font class="bashcommand-result">Subject03 Subject04</font>
						</font>
					</p>
				</div>
				
				<div id="ex6">
					<p>
						<font class="bashcommand">${STRING/OLD_ITEM/NEW_ITEM}</font>
						A string is an array of characters. So, you can replace parts of a string the same way that you do 
						with an array (without the <font class="bashcommand">[@]</font>).
					</p>
					
					<font class="bashcommand">
						<p>
							$ P="/Users/Neuro/Desktop"<br>
							$ echo ${P/Neuro/Research}<br>
							<font class="bashcommand-result">/Users/Research/Desktop</font>
						</p>
						
						<p>
							$ P="/Users/Neuro/Desktop"<br>
							$ echo ${P/Desktop/}<br>
							<font class="bashcommand-result">/Users/Neuro/</font>
						</p>
					</font>
					
					<p>
						You can use patterns to remove a group of elements from an array. For example, in the following 
						array you have three items that start by <font class="bashcommand">AA</font>, so you use as 
						<font class="bashcommand">ITEM_TO_REPLACE: AA*</font>. As you can see, the three items that start 
						with <font class="bashcommand">AA</font> are deleted.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=('AA123' 'AB345' 'AA987' 'BB098' 'AA456')<br>
							$ echo ${ARRAY[@]/AA*/}<br>
							<font class="bashcommand-result">AB345 BB098</font>
						</font>
					</p>
					
					<p>
						Below are a few more examples on how to use patterns to remove a group of items from an array:
					</p>
					
					<p>
						Delete all items that end with the letter Z (<font class="bashcommand">'HGTZ'</font> and 
						<font class="bashcommand">'ZZZZ'</font>):<br>
						<font class="bashcommand">
							$ declare -a ARRAY=('QWER' 'HGTZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ echo ${ARRAY[@]/*Z/}<br>
							<font class="bashcommand-result">QWER QRJD JHGF</font>
						</font>
					</p>
					
					<p>
						Delete all items that have an <font class="bashcommand">A</font> at the beginning and a 
						<font class="bashcommand">Z</font> at the end (<font class="bashcommand">'ASDFZ'</font>). Observe 
						that either <font class="bashcommand">'RFGHJZ'</font> nor <font class="bashcommand">'ZZZZ'</font> get 
						deleted because even though they end with a <font class="bashcommand">Z</font>, they don't start 
						with an <font class="bashcommand">A</font>, so those two strings don't follow the 
						<font class="bashcommand">A*Z</font> pattern: <br>
						<font class="bashcommand">
							$ declare -a ARRAY=('ASDFZ' 'RFGHJZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ echo ${ARRAY[@]/A*Z/}<br>
							<font class="bashcommand-result">RFGHJZ QRJD ZZZZ JHGF</font>
						</font>
					</p>
					
					<p>
						To replace the front-end occurrences of a substring within an array, you can use the following 
						syntax: <font class="bashcommand">${ARRAY[@]/#SUBSTRING_TO_REPLACE/NEW_SUBSTRING}:</font><br>
						<font class="bashcommand">
							$ declare -a ARRAY=('SUBJ0' 'SUBJ9' 'SUBJ3' 'SUBJ4' 'SUBJ3')<br>
							$ echo ${ARRAY[@]/#SUBJ/SUBJECT}<br>
							<font class="bashcommand-result">SUBJECT0 SUBJECT9 SUBJECT3 SUBJECT4 SUBJECT3</font>
						</font>
					</p>
					
					<p>
						To replace the back end occurrences of a substring within an array, use the symbol 
						<font class="bashcommand">%</font> instead of <font class="bashcommand">#</font> and the same syntax 
						as before:<br>
						<font class="bashcommand">
							$ declare -a ARRAY=('ID_001' 'AGE_001' 'GENDER_001' 'QC_001')<br>
							$ echo ${ARRAY[@]/%001/125}<br>
							<font class="bashcommand-result">ID_125 AGE_125 GENDER_125 QC_125</font>
						</font> 
					</p>
				</div>
				
				<div id="ex7">
					<p>
						<font class="example">${STRING//OLD_ITEM/NEW_ITEM}</font>
						With strings, contrary to how it happens with arrays, using the previous syntax will only replace the 
						first occurrence of <font class="bashcommand">OLD_ITEM</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ P="/Users/Neuro/Desktop/Neuro"<br>
							$ echo ${P/Neuro/Research}<br>
							<font class="bashcommand-result">/Users/Research/Desktop/Neuro</font>
						</font>
					</p>
					
					<p>In order to replace all occurrences of <font class="bashcommand">OLD_ITEM</font> you must use double 
					slash:</p>
					
					<font class="bashcommand">
						<p>
							$ P="/Users/Neuro/Desktop/Neuro"<br>
							$ echo ${P//Neuro/Research}<br>
							<font class="bashcommand-result">/Users/Research/Desktop/Research</font>
						</p>
						
						<p>
							$ P="/Users/Neuro/Desktop"<br>
							$ echo ${P//e/}<br>
							<font class="bashcommand-result">/Usrs/Nuro/Dsktop</font>
						</p>
					</font>
				</div>
				
				<div id="ex8">
					<p>
						<font class="example">NEWARRAY=("${ARRAY[@]}")</font>
						This syntax is used to copy all the elements of one array into a new one.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=('ASDFZ' 'RFGHJZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ NEWARRAY=("${ARRAY[@]}")<br>
							$ echo ${NEWARRAY[@]}<br>
							<font class="bashcommand-result">ASDFZ RFGHJZ QRJD ZZZZ JHGF</font>
						</font>
					</p>
				</div>
				
				<div id="ex9">
					<p>
						<font class="example">NEWARRAY=("${ ARRAY1[@]}" "${ARRAY2[@]}" "${ ARRAY3[@]}" ...)</font>
						Concatenating arrays is very similar to copying arrays. If you want to concatenate array 
						<font class="bashcommand">A</font> and <font class="bashcommand">B</font>, and save the result in 
						<font class="bashcommand">C</font>. You just copy <font class="bashcommand">A</font> after 
						<font class="bashcommand">B</font> (using the previous syntax) and assign it to 
						<font class="bashcommand">C</font>.
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a A=('ASDFZ' 'RFGHJZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ declare -a B=('3333' '2222' '1111')<br>
							$ C=("${A[@]}" "${B[@]}")<br>
							$ echo ${C[@]}<br>
							<font class="bashcommand-result">ASDFZ RFGHJZ QRJD ZZZZ JHGF 3333 2222 1111</font>
						</font>
					</p>
				</div>
				
				<div id="ex10">
					<p>
						<font class="example">unset ARRAY</font>
						If your script creates very big temporary arrays that won't be used again, you might want to delete them 
						to free some memory. For that you use the command unset. You might want to use unset also if you want to 
						make sure that the array is empty before you start adding elements.
					</p>
					
					<p>
						In this example, after deleting array A and echoing it again, nothing will be printed as the array is now 
						empty:
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a A=('ASDFZ' 'RFGHJZ' 'QRJD' 'ZZZZ' 'JHGF')<br>
							$ echo ${A[@]}<br>
							<font class="bashcommand-result">ASDFZ RFGHJZ QRJD ZZZZ JHGF</font><br>
							$ unset A<br>
							$ echo ${A[@]}
						</font>
					</p>
				</div>
				
				<div id="ex11">
					<p>
						<font class="example">${ARRAY[@]:START:NUM}</font>
						By using <font class="bashcommand">${ARRAY[@]:START:N}</font>, you can create a sub-array that 
						contains <font class="bashcommand">N</font> elements from the original array, starting from the 
						index <font class="bashcommand">START</font>. Remember, the index of the first item is 0. So, in the 
						following example the index of <font class="bashcommand">'Element1'</font> is 0 and the index of 
						<font class="bashcommand">'Element2'</font> is 1.
					</p>
					
					<p>
						Extract 2 items from <font class="bashcommand">ARRAY</font> starting in index 0 (items 
						<font class="bashcommand">'Element1'</font> and <font class="bashcommand">'Element2'</font>):
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=( 'Element1' 'Element2' 'Element3' 'Element4' 'Element5')<br>
							$ echo ${ARRAY[@]:0:2}<br>
							<font class="bashcommand-result">Element1 Element2</font>
						</font>
					</p>
					
					<p>
						Extract 3 items from <font class="bashcommand">ARRAY</font> starting in index 2 (items 
						<font class="bashcommand">'Element3'</font>, <font class="bashcommand">'Element4'</font> and 
						<font class="bashcommand">'Element5'</font>):
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=( 'Element1' 'Element2' 'Element3' 'Element4' 'Element5')<br>
							$ echo ${ARRAY[@]:2:3}<br>
							<font class="bashcommand-result">Element3 Element4 Element5</font>
						</font>
					</p>
					
					<p>
						Extract 4 items from <font class="bashcommand">ARRAY</font> starting in index 2. There are only 
						three elements from the item in index 2 until the end of the array. So, bash will only extract 3 
						items (there's no 4th item to extract).
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=( 'Element1' 'Element2' 'Element3' 'Element4' 'Element5')<br>
							$ echo ${ARRAY[@]:2:4}<br>
							<font class="bashcommand-result">Element3 Element4 Element5</font>
						</font>
					</p>
				</div>
				
				<div id="ex12">
					<p>
						<font class="example">${STRING:START:NUM}</font>
						Extract characters from a string. Remember, a string is also an array (an array of characters).
					</p>
					
					<p>
						<font class="bashcommand">
							$ S="Colombia"<br>
							$ echo "The first character in ${S} is ${S:0:1}"<br>
							<font class="bashcommand-result">The first character in Colombia is C</font><br>
							$ echo "The third character in ${S} is ${S:2:1}"<br>
							<font class="bashcommand-result">The third character in Colombia is l</font><br>
							$ SIZE=${#S}<br>
							$ echo $SIZE<br>
							<font class="bashcommand-result">8</font><br>
							$ echo "The last two characters in ${S} are ${S:$(( ${SIZE} - 2 )):2}"<br>
							<font class="bashcommand-result">The last two characters in Colombia are ia</font>
						</font>
					</p>
				</div>
				
				<div id="ex13">
					<p>
						<font class="example">IFS=$'\n' sorted=($(sort <<<"${array[*]}"))</font>
						Sort <font class="bashcommand">array</font> and save the output in sorted (array stays the same):
					</p>
					
					<p>
						<font class="bashcommand">
							$ array=(ewrwr dfgfgdf asda yrtytr)<br>
							$ echo ${array[@]}<br>
							<font class="bashcommand-result">ewrwr dfgfgdf asda yrtytr</font><br>
							$ IFS=$'\n' sorted=($(sort &lt;&lt;&lt;"${array[*]}"))<br>
							${sorted[@]}<br>
							<font class="bashcommand-result">asda dfgfgdf ewrwr yrtytr</font><br>
							$ echo ${array[@]}<br>
							<font class="bashcommand-result">ewrwr dfgfgdf asda yrtytr</font>
						</font>
					</p>
				</div>
		    </div>
		    
		    <div id="content6" class="hidden">
		    	<h2>6. Condition-testing</h2>
		    
		    	<p>
					Variables can be used to test if a certain condition is true or false, and therefore be able to take a 
					different course of action depending on the result of the test. For example, you might want to evaluate 
					if a file exists to decide if you can copy it into a different folder or not. For condition-testing you 
					will use the if-command. This command has the following syntax:
				</p>
				
				<p>
					if [ CONDITION_TO_EVALUATE ]<br>
					then<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&lt;INSTRUCTIONS THAT WILL RUN IF THE CONDITION IS TRUE&gt;<br>
					elif [ OTHER_CONDITION_TO_EVALUATE_IF_1ST_CONDITION_IS_FALSE ]<br>
					then<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&lt;INSTRUCTIONS THAT WILL RUN IF FIRST CONDITION IS FALSE BUT SECOND IS TRUE&gt;<br>
					else<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&lt;INSTRUCTIONS THAT WILL RUN IF ALL THE PREVIOUS CONDITIONS ARE FALSE&gt;<br>
					fi
				</p>
				
				<p>
					The CONDITION_TO_EVALUATE is an expression that follows a specific syntax depending on what you want to 
					test (checking files, string comparison, comparing numbers, or combining different expressions). Lets 
					look at the different syntaxes used in each of these situations and at some examples that will help you 
					understand this seemingly confusing subject.
				</p>
				
				<h3>6.1. Condition-testing to check files</h3>
					<p>
						In the following table, <font class="bashcommand">FILE</font> refers to the path of the file or to the 
						variable that contains the path of the file. The spaces after <font class="bashcommand">[</font> and 
						before <font class="bashcommand">]</font> are very important. If those spaces are missing, bash will 
						give an error.
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Condition</b></th>
							<th style="width:70%"><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -a FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -d FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a directory.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -e FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -f FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a regular file.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -g FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and its SGID bit is set.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -h FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a symbolic link.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -k FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and its sticky bit is set.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -p FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a named pipe (FIFO).</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -r FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is readable.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -s FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and has a size greater than zero.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -t FD ]</font>
							</td>
							<td>Tests if file descriptor <font class="bashcommand">FD</font> is open and refers to a terminal.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -u FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and its SUID (set user ID) bit is set.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -w FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is writable.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -x FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is executable.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -O FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is owned by the effective user ID.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -G FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is owned by the effective group ID.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -L FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a symbolic link.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -N FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and has been modified since it was last read.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -S FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a socket.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ FILE1 -nt FILE2 ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE1</font> has been changed more recently than <font class="bashcommand">FILE2</font>, or if <font class="bashcommand">FILE1</font> exists and <font class="bashcommand">FILE2</font> does not.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ FILE1 -ot FILE2 ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE1</font> is older than <font class="bashcommand">FILE2</font>, or is <font class="bashcommand">FILE2</font> exists and <font class="bashcommand">FILE1</font> does not.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ FILE1 -ef FILE2 ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE1</font> and <font class="bashcommand">FILE2</font> refer to the same device and inode numbers.</td>
						</tr>
					</table>
					
				<p>
					In the following section you will not find examples of the following flags because they are related to user permissions, a topic that has not been explained yet and will be explained in future chapters, or because they are less common. However, the use of these flags is the same as the ones explained below. 
				</p>
				
				<p>
					<font class="example">[ -a FILE ]:</font>
					<font class="bashcommand">
						$ FILE=/Users/MyUser/Desktop/someFile.txt<br>
						$ if [ -a "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "${FILE} exists"<br>
						&gt; else<br>
						&gt; echo "${FILE} doesn't exist"<br>
						&gt; fi 
					</font>
				</p>
				
				<p>
					<font class="bashcommand">
						$ if [ -a "/Users/MyUser/Desktop/someFile.txt" ]<br>
						&gt; then<br>
						&gt; echo "The file exists"<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist"<br>
						&gt; fi 
					</font>
				</p>
				
				<p>
					The following example shows a common mistake. Here, the quotation marks surrounding the file path are missing. Since the path has spaces, bash gives an error: 
				</p>
				
				<p>
					<font class="bashcommand">
						$ if [ -a /Users/MyUser/Desktop/some file name with spaces.txt ]<br>
						&gt; then<br>
						&gt; echo "The file exists"<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist"<br>
						&gt; fi<br>
						<font class="bashcommand-result">-bash: [: too many argument</font>
					</font>
				</p>
				
				<p>
					<font class="example">[ -d FILE ]:</font>
					<font class="bashcommand">
						$ FILE=/Users/MyUser/Desktop/someFile.txt<br>
						$ if [ -a "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "The file exists. Now I will find out if it's a directory or a regular file."<br>
						&gt; if [ -d "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "It is a directory."<br>
						&gt; else<br>
						&gt; echo "It is a regular file."<br>
						&gt; fi<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist."<br>
						&gt; fi
					</font>
				</p>
				
				<p>
					The following example shows a common mistake. Here, the spaces before and after the expression (<font class="bashcommand">-a "${FILE}"</font>) are missing. So, bash will give an error: 
				</p>
				
				<p>
					<font class="bashcommand">
						$ FILE=/Users/MyUser/Desktop/someFile.txt<br>
						$ if [-a "${FILE}"]<br>
						&gt; then<br>
						&gt; echo "The file exists. Now I will find out if it's a directory or a regular file."<br>
						&gt; if [ -d "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "It is a directory."<br>
						&gt; else<br>
						&gt; echo "It is a regular file."<br>
						&gt; fi<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist."<br>
						&gt; fi<br>
						<font class="bashcommand-result">-bash: [-a: command not found</font>
					</font>
				</p>
				
				<p>
					<font class="example">[ -f FILE ]:</font>
					<font class="bashcommand">
						$ FILE=/Users/MyUser/Desktop/someFile.txt<br>
						$ if [ -a "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "The file exists. Now I will find out if it's a directory or a regular file."<br>
						&gt; if [ -f "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "It is a regular file."<br>
						&gt; else<br>
						&gt; echo "It is a directory."<br>
						&gt; fi<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist."<br>
						&gt; fi
					</font>
				</p>
				
				<p>
					<font class="example">[ -N FILE ]:</font>
					<font class="bashcommand">
						$ if [ -N "/Users/MyUser/Desktop/someFile.txt" ]<br>
						&gt; then<br>
						&gt; echo "The file exists and has been modified since the last time it was opened."<br>
						&gt; else<br>
						&gt; echo "Either the file doesn't exist, or it hasn't been modified."<br>
						&gt; fi 
					</font>
				</p>
				
				<h3>6.2. Condition-testing to compare/evaluate strings</h3>
					<p>
						When comparing strings, it is mandatory to use the quotation marks. The spaces after <font class="bashcommand">[</font> and before <font class="bashcommand">]</font> are very important. If those spaces are missing, bash will give an error. 
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Condition</b></th>
							<th style="width:70%"><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -z "STRING" ]</font>
							</td>
							<td>Tests if the length of <font class="bashcommand">STRING</font> is zero</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -n "STRING" ]</font>
							</td>
							<td>Tests if the length of <font class="bashcommand">STRING</font> is non-zero</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" == "STRING2" ]</font>
							</td>
							<td>Tests if the strings are equal</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" != "STRING2" ]</font>
							</td>
							<td>Tests if the strings are not equal</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" \< "STRING2" ]</font>
							</td>
							<td>Tests if <font class="bashcommand">STRING1</font> sorts before <font class="bashcommand">STRING2</font></td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" \> "STRING2" ]</font>
							</td>
							<td>Tests if <font class="bashcommand">STRING1</font> sorts after <font class="bashcommand">STRING2</font></td>
						</tr>
					</table>
					
					<p>
						<font class="example">[ -z "STRING" ]:</font>
						<font class="bashcommand">
							$ if [ -z "" ]<br>
							&gt; then<br>
							&gt; echo "Empty string"<br>
							&gt; fi<br>
							<font class="bashcommand-result">Empty string</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ -n "STRING" ]:</font>
						<font class="bashcommand">
							$ VAR="Some text"<br>
							$ if [ -n "${VAR}" ]<br>
							&gt; then<br>
							&gt; echo "The string is not empty"<br>
							&gt; fi<br>
							<font class="bashcommand-result">The string is not empty</font> 
						</font>
					</p>
					
					<p>In this example, bash will show an error because I forgot to put the quotation marks around <font class="bashcommand">${VAR}</font>.</p>
					
					<p>
						<font class="bashcommand">
							$ VAR="Some text"<br>
							$ if [ -n ${VAR} ]<br>
							&gt; then<br>
							&gt; echo "The string is not empty"<br>
							&gt; fi<br>
							<font class="bashcommand-result">-bash: [: Some: binary operator expected</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ "STRING1" == "STRING2" ]:</font>
						<font class="bashcommand">
							$ QC="Good"<br>
							$ if [ "${QC}" == "Good" ]<br>
							&gt; then<br>
							&gt; echo "Quality control good"<br>
							&gt; else<br>
							&gt; echo "Image has bad quality"<br>
							&gt; fi<br>
							<font class="bashcommand-result">Quality control good</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ "STRING1" != "STRING2" ]:</font>
						<font class="bashcommand">
							$ QC="Good"<br>
							$ if [ "${QC}" != "Good" ]<br>
							&gt; then<br>
							&gt; echo "Quality control is not good"<br>
							&gt; else<br>
							&gt; echo "Image has good quality"<br>
							&gt; fi<br>
							<font class="bashcommand-result">Image has good quality</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ "STRING1" \< "STRING2" ]:</font>
						In the following example, I am comparing the strings <font class="bashcommand">"Canada"</font> with <font class="bashcommand">"Colombia"</font> and printing the one that sorts first. <font class="bashcommand">"Canada"</font> will be printed because the first letter of both words is the same but the second letter in <font class="bashcommand">"Canada"</font> (letter <font class="bashcommand">a</font>) comes before the second letter in <font class="bashcommand">"Colombia"</font> (letter <font class="bashcommand">o</font>).<br>
						<font class="bashcommand">
							$ VAR1="Canada"<br>
							$ VAR2="Colombia"<br>
							$ if [ "${VAR1}" \< "${VAR2}" ]<br>
							&gt; then<br>
							&gt; echo ${VAR1}<br>
							&gt; else<br>
							&gt; echo ${VAR2}<br>
							&gt; fi<br>
							<font class="bashcommand-result">Canada</font>
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${VAR1}" \< "${VAR2}" ] &gt;&gt; echo ${VAR1} || echo ${VAR2}<br>
							<font class="bashcommand-result">Canada</font>
						</font>	
					</p>
					
					<p>
						<font class="example">[ "STRING1" \> "STRING2" ]:</font>
						<font class="bashcommand">
							$ VAR1="Canada"<br> 
							$ VAR2="Colombia"<br>
							$ if [ "${VAR1}" \> "${VAR2}" ]<br>
							&gt; then<br>
							&gt; echo ${VAR2}<br>
							&gt; else<br>
							&gt; echo ${VAR1}<br>
							&gt; fi<br>
							<font class="bashcommand-result">Canada</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${VAR1}" \> "${VAR2}" ] &gt;&gt; echo ${VAR2} || echo ${VAR1}<br>
							<font class="bashcommand-result">Canada</font>
						</font>
					</p>
					
				<h3>6.3. Condition-testing to compare numbers</h3>
					<p>The spaces after <font class="bashcommand">[</font> and before <font class="bashcommand">]</font> are very important. If those spaces are missing, bash will give an error.</p>
					<table>
						<tr>
							<th><b>Condition</b></th>
							<th><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -eq NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is equal to <font class="bashcommand">NUM2</font></td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -ne NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is not equal to <font class="bashcommand">NUM2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -lt NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is less than <font class="bashcommand">NUM2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -le NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is less than or equal to <font class="bashcommand">NUM2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -gt NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is greater than <font class="bashcommand">NUM2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -ge NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is greater than or equal to <font class="bashcommand">NUM2</font>.</td>
						</tr>
					</table>
					
					<p>
						<font class="example">[ NUM1 -eq NUM2 ]:</font>
						<font class="bashcommand">
							$ if [ 3 -eq 3 ]<br>
							&gt; then<br>		
							&gt; echo "This makes sense, 3 equals 3."<br>					
							&gt; fi<br>			
							<font class="bashcommand-result">This makes sense, 3 equals 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ 3 -eq 3 ] &gt;&gt; echo "This makes sense, 3 equals 3."<br>
							<font class="bashcommand-result">This makes sense, 3 equals 3.</font>
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -eq "3" ]<br>
							&gt; then<br> 
							&gt; echo "This makes sense, ${A} equals 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This makes sense, 3 equals 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -eq "3" ] &gt;&gt; echo "This makes sense, ${A} equals 3."<br>
							<font class="bashcommand-result">This makes sense, 3 equals 3.</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ NUM1 -ne NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -ne "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is not equal to 3"<br> 
							&gt; else<br>
							&gt; echo "Variable A equals 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A equals 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -ne "3" ] &gt;&gt; echo "Variable A is not equal to 3" || echo "Variable A equals 3."<br>
							<font class="bashcommand-result">Variable A equals 3.</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ NUM1 -lt NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -lt "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is less than 3"<br> 
							&gt; else<br>
							&gt; echo "Variable A not less than 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A is not less than 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -lt "3" ] &gt;&gt; echo "Variable A is less than 3" || echo "Variable A not less than 3."<br>
							<font class="bashcommand-result">Variable A is not less than 3.</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ NUM1 -le NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br> 
							$ if [ "${A}" -le "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is less or equal to 3"<br>
							&gt; else<br>
							&gt; echo "Variable A greater than 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A is less or equal to 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -le "3" ] &gt;&gt; echo "Variable A is less or equal to 3" || echo "Variable A greater than 3."<br>
							<font class="bashcommand-result">Variable A is less or equal to 3.</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ NUM1 -gt NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -gt "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is greater than 3."<br>
							&gt; else<br>
							&gt; echo "Variable A not greater than 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A is not greater than 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -gt "3" ] &gt;&gt; echo "Variable A is greater than 3." || echo "Variable A not greater than 3."<br>
							<font class="bashcommand-result">Variable A is not greater than 3.</font>
						</font>	
					</p>
					
					<p>
						<font class="example">[ NUM1 -ge NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -ge "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is greater or equal to 3"<br>
							&gt; else<br>
							&gt; echo "Variable A less than 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A is greater or equal to 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -ge "3" ] &gt;&gt; echo "Variable A is greater or equal to 3" || echo "Variable A less than 3."<br>
							<font class="bashcommand-result">Variable A is greater or equal to 3.</font>
						</font>
					</p>
					
				<h3>6.4. Condition-testing to compare arrays</h3>
					<table>
						<tr>
							<th><b>Condition</b></th>
							<th><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ "${array1[*]}" == "${array2[*]}" ]</font></td>
							<td>Tests if <font class="bashcommand">array1</font> equals to <font class="bashcommand">array2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ "${array1[*]}" != "${array2[*]}" ]</font></td>
							<td>Tests if array1 is different to array2.</td>
						</tr>
					</table>
					
					<p>
						<font class="example">[ "${array1[*]}" == "${array2[*]}" ]:</font>
						<font class="bashcommand">
							$ arr1=(a b c)<br>
							$ arr2=(a b c d)<br>
							$ arr3=(a b c)<br>
							$ if [ "${arr1[*]}" == "${arr3[*]}" ]<br>
							&gt; then<br>
							&gt; echo "equal"<br>
							&gt; else<br>
							&gt; echo "different"<br>
							&gt; fi<br>
							<font class="bashcommand-result">equal</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${arr1[*]}" == "${arr3[*]}" ] &gt;&gt; echo "equal" || echo "different"<br>
							<font class="bashcommand-result">equal</font>
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ "${arr1[*]}" == "${arr2[*]}" ]<br>
							&gt; then<br>
							&gt; echo "equal"<br>
							&gt; else<br>
							&gt; echo "different"<br>
							&gt; fi<br>
							<font class="bashcommand-result">different</font>
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${arr1[*]}" == "${arr2[*]}" ] &gt;&gt; echo "equal" || echo "different"<br>
							<font class="bashcommand-result">different</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ "${arr1[*]}" != "${arr2[*]}" ]:</font>
						<font class="bashcommand">
							$ if [ "${arr1[*]}" != "${arr2[*]}" ]<br>
							&gt; then<br>
							&gt; echo "different"<br>
							&gt; else<br>
							&gt; echo "equal"<br>
							&gt; fi<br>
							<font class="bashcommand-result">different</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${arr1[*]}" != "${arr2[*]}" ] &gt;&gt; echo "different" || echo "equal"<br>
							<font class="bashcommand-result">different</font>
						</font>
					</p>
					
					<h3>6.5. Combining different expressions for condition-testing</h3>
					<table>
						<tr>
							<th><b>Condition</b></th>
							<th><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ EXPR ]</font></td>
							<td>Tests if the expression <font class="bashcommand">EXPR</font> is <b>true</b>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ ! EXPR ]</font></td>
							<td>Tests if the expression <font class="bashcommand">EXPR</font> is <b>false</b>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ EXPR1 ] || [ EXPR2 ]</font></td>
							<td>Tests if <font class="bashcommand">EXPR1</font> <b>or</b> <font class="bashcommand">EXPR2</font> are true. You can add as many expressions as desired.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ EXPR1 ] &amp;&amp; [ EXPR2 ]</font></td>
							<td>Tests if <font class="bashcommand">EXPR1</font> <b>and</b> <font class="bashcommand">EXPR2</font> are true. You can add as many expressions as desired.</td>
						</tr>
					</table>
					
					<p>
						<font class="example">[ EXPR ] vs [ ! EXPR ]</font>
						<font class="bashcommand">
							$ if [ 3 -eq 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be printed if the expression 3 equals 3 is true."<br>
							&gt; else<br>
							&gt; echo "This will be printed if the expression is false (3 is not equal to 3)."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be printed if the expression 3 equals 3 is true.</font>
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ 3 -eq 3 ] &gt;&gt;  echo "This will be printed if the expression 3 equals 3 is true." || echo "This will be printed if the expression is false (3 is not equal to 3)."<br>
							<font class="bashcommand-result">This will be printed if the expression 3 equals 3 is true.</font>
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ ! 3 -eq 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be printed if it is false that 3 equals 3 (so, if 3 is different than 3)."<br>
							&gt; else<br>
							&gt; echo "This will be printed if it is not false (it's true) that 3 equals 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be printed if it is not false (it's true) that 3 equals 3.</font>
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ ! 3 -eq 3 ] &gt;&gt; echo "This will be printed if it is false that 3 equals 3 (so, if 3 is different than 3)." || echo "This will be printed if it is not false (it's true) that 3 equals 3."<br>
							<font class="bashcommand-result">This will be printed if it is not false (it's true) that 3 equals 3.</font>
						</font>
					</p>
					
					<p>We learned that the expression <font class="bashcommand">-f FILE</font> tests if a file exists. If we want to test if a file doesn't exist, then we just need to test if <font class="bashcommand">-f FILE</font> is false.</p>

					<font class="bashcommand">
						<p>
							$ FILE="SomeFileThatExists.txt"<br>
							$ if [ -f ${FILE} ]<br>
							&gt; then<br>
							&gt; echo "The file exist"<br>
							&gt; fi <br>
							<font class="bashcommand-result">The file exist</font>
						</p>
						
						<p>
							The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
							<font class="bashcommand">$ [ -f ${FILE} ] &gt;&gt; echo "The file exist"</font><br>
							<font class="bashcommand-result">The file exist</font>
						</p>
						
						<p>
							$ FILE="SomeFileThatDoesntExist.txt"<br>
							$ if [ ! -f ${FILE} ]<br>
							&gt; then<br>
							&gt; echo "The file doesn't exist"<br>
							&gt; fi<br>
							<font class="bashcommand-result">The file doesn't exist</font>
						</p>
						
						<p>
							The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
							<font class="bashcommand">$ [ ! -f ${FILE} ] &gt;&gt; echo "The file doesn't exist"</font><br>
							<font class="bashcommand-result">The file doesn't exist</font>
						</p>
					</font>
					
					<p>
						<font class="example">[ EXPR1 ] || [ EXPR2 ]:</font>
						Test if any of the two expressions are true.
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ 2 -lt 3 ] || [ 4 -lt 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be echoed if any of the two expressions are true: 2&lt;3 OR 4&lt;3."<br>
							&gt; else<br>
							&gt; echo "This will be echoed if none of the two expressions are true"<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be echoed if any of the two expressions are true: 2&lt;3 OR 4&lt;3.</font> 
						</font>
					</p>
					
					<p>The previous example can also be written using a shorter syntax. When using multiple expressions, they will have to be encapsulated in parentheses using the following syntax: ( expressions ) &amp;&amp; what_to_do_if_true || what_to_do_if_false</p>
					
					<p>
						Shorter version:<br>
						<font class="bashcommand">
							$ ( [ 2 -lt 3 ] || [ 4 -lt 3 ] ) &amp;&amp; echo "This will be echoed if any of the two expressions are true: 2&lt;3 OR 4&lt;3." || echo "This will be echoed if none of the two expressions are true":<br>
							<font class="bashcommand-result">This will be echoed if any of the two expressions are true: 2&lt;3 OR 4&lt;3.</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ EXPR1 ] &amp;&amp; [ EXPR2 ]:</font>
						Test if the two expressions are true. The second expression, contrary to the previous example, has the negation (<font class="bashcommand">!</font>). So, the second expression is not testing if 4 is less than 3, it is testing if 4 is <b>NOT</b> less than 3. So, both of the expressions are true, because 4 is not less than 3, and 2 is less than 3. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be echoed if the two expressions are true."<br>
							&gt; else<br>
							&gt; echo "This will be echoed if one of the two expressions are false, or if both are false."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be echoed if the two expressions are true.</font> 
						</font>
					</p>
					
					<p>The previous example can also be written using a shorter syntax. Remember that when using multiple expressions, they will have to be encapsulated in parentheses using the following syntax: ( expressions ) &amp;&amp; what_to_do_if_true || what_to_do_if_false</p>
					
					<p>
						This is the shorter version:<br>
						<font class="bashcommand">
							$ ( [ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ] ) &amp;&amp; echo "This will be echoed if the two expressions are true." || echo "This will be echoed if one of the two expressions are false, or if both are false."<br>
							<font class="bashcommand-result">This will be echoed if the two expressions are true.</font> 
						</font>
					</p>
					
					<font class="example">Using the and (&amp;&amp;) and or (||) operands to test more than two conditions:</font>
					
					<p>
						Using &amp;&amp; to test more than two conditions:<br>
						You can combine more than two expressions. In the following example I am combining three. Because I am using the <b>AND</b> operator, the whole condition will test true <b>if and only if</b> all the three expressions are true. If one is false, then the whole expression will be false.  
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ] &amp;&amp; [ 4 -lt 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be echoed if all the three expressions are true."<br>
							&gt; else<br>
							&gt; echo "This will be echoed if any of the three expressions is false."<br> 
							&gt; fi<br>
							<font class="bashcommand-result">This will be echoed if any of the three expressions is false.</font> 
						</font>
					</p>
					
					<p>
						Let's take a look at why the whole expression evaluates false:<br>
						<font class="bashcommand">[ 2 -lt 3 ]</font>: This is true, 2 &lt; 3.<br>
						<font class="bashcommand">[ ! 4 -lt 3 ]</font>: This is true, 4 is not less than 3.<br> 
						<font class="bashcommand">[ 4 -lt 3 ]</font>: This is false, It is false that 4 be less than 3.<br>
						<font class="bashcommand">[ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ] &amp;&amp; [ 4 -lt 3 ]</font>: This is false because one of the three expressions is false. 
					</p>
					
					<p>The previous example can also be written using a shorter syntax. Remember that when using multiple expressions, they will have to be encapsulated in parentheses using the following syntax: ( expressions ) &amp;&amp; what_to_do_if_true || what_to_do_if_false</p>
					
					<p>
						This is the shorter version:</br>
						<font class="bashcommand">
							$ ( [ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ] &amp;&amp; [ 4 -lt 3 ] ) &amp;&amp; echo "This will be echoed if all the three expressions are true." || echo "This will be echoed if any of the three expressions is false."<br>
							<font class="bashcommand-result">This will be echoed if any of the three expressions is false.</font> 
						</font>
					</p>
					
					<p>
						Using <font class="bashcommand">||</font> to test more than two conditions:<br>
						This example is very similar than the previous one but instead of using the operator AND (<font class="bashcommand">&gt;&gt;</font>)), we are using the operator OR (<font class="bashcommand">||</font>). So, the whole expression will be true if ANY of the three expressions is true. Since the first two are true, then the result is true. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ 2 -lt 3 ] || [ ! 4 -lt 3 ] || [ 4 -lt 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be echoed if ANY of the three expressions is true."<br>
							&gt; else<br>
							&gt; echo "This will be echoed if all of the three expressions are false."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be echoed if ANY of the three expressions is true.</font>
						</font>
					</p>
					
					<p>The previous example can also be written using a shorter syntax. Remember that when using multiple expressions, they will have to be encapsulated in parentheses using the following syntax: ( expressions ) &amp;&amp; what_to_do_if_true || what_to_do_if_false</p>
					
					<p>
						This is the shorter version:<br>
						<font class="bashcommand">
							$ ( [ 2 -lt 3 ] || [ ! 4 -lt 3 ] || [ 4 -lt 3 ] ) &amp;&amp; echo "This will be echoed if ANY of the three expressions is true." || echo "This will be echoed if all of the three expressions are false."<br>
							<font class="bashcommand-result">This will be echoed if ANY of the three expressions is true.</font>
						</font>
					</p>
					
					<p>
						<font class="example">Combining &amp;&amp; and || into one expression:</font>
						When combining both operands (&amp;&amp;, ||), it is better to always use parenthesis to indicate the order in which you want the operations to be evaluated. In the following example we have three files. The path of the three files are saved in the variables <font class="bashcommand">${FILE1} ${FILE2}</font> and <font class="bashcommand">${FILE3}</font>. Files <font class="bashcommand">${FILE1}</font> and <font class="bashcommand">${FILE3}</font> exist, but <font class="bashcommand">${FILE2}</font> doesn't exist. We want to evaluate the following condition: Does <font class="bashcommand">${FILE3}</font> and one of the other two files exists?
					</p>
					
					<p>
						<font class="bashcommand">[ -f ${FILE3} ]</font> This condition is true because <font class="bashcommand">${FILE3}</font> exists.<br> 
						<font class="bashcommand">[ -f ${FILE2} ] || [ -f ${FILE1} ]</font> This condition is true because even though <font class="bashcommand">${FILE2}</font> doesn't exist, <font class="bashcommand">${FILE1}</font> does exist. And with an <font class="bashcommand">OR</font> (<font class="bashcommand">||</font>) we only need one of the expressions to be true.<br> 
						<font class="bashcommand">( [ -f ${FILE1} ] || [ -f ${FILE2} ] ) &amp;&amp; [ -f ${FILE3} ]</font> This is true because both of expressions are true.
					</p>
					
					<p>
						<font class="bashcommand">
						$ if ( [ -f ${FILE1} ] || [ -f ${FILE2} ] ) &amp;&amp; [ -f ${FILE3} ]<br>
						&gt; then<br>
						&gt; echo "The condition is true"<br>
						&gt; else<br>
						&gt; echo "The condition is false"<br>
						&gt; fi<br>
						<font class="bashcommand-result">The condition is true</font>
						</font>
					</p>
					
					<p>
						This is the shorter version for the previous command:<br>
						<font class="bashcommand">
						( [ -f ${FILE1} ] || [ -f ${FILE2} ] ) &amp;&amp; [ -f ${FILE3} ] &amp;&amp; echo "The condition is true" || echo "The condition is false"
						</font>
					</p>
					
					<p>In the following example, we want to include a subject if it is female and age less than six or male and age greater than ten. </p>
					
					<p>
						<font class="bashcommand">
							$ GENDER="MALE"<br>
							$ AGE=23<br>
							$ if ( [ "${GENDER}" == "FEMALE" ] && [ "${AGE}" -lt "6" ] ) || ( [ "${GENDER}" == "MALE" ] && [ "${AGE}" -gt "10" ] )<br>
							&gt; then<br>
							&gt; echo "Include subject"<br>
							&gt; else<br>
							&gt; echo "Exclude subject"<br>
							&gt; fi<br>
							<font class="bashcommand-result">Include subject</font>
						</font>
					</p>
 
		    </div>
		       
		    <div id="content7" class="hidden">
		    	<h2>7. Iteration</h2>
				<p>
					In the following section we will learn how to use loops to iterate through the content of arrays or through a list of files. However, we will leave the part of iterating through the content of a file for the next section (File manipulation). Iteration is basically the repetition of a process or group of commands on a list of items. For example, you might use iteration to repeat the same processing steps on the MRI images of a list of subjects, or to manipulate in the same way a list of files. It saves time because instead of typing the same command 100 times to do the exact same thing on 100 subjects, you type it just one time inside a loop. You will use loops (as well as condition-testing) in almost every script that you write.
				</p>
				
				<table>
						<tr>
							<th><b>Command</b></th>
							<th><b>Use</b></th>
							<th><b>Syntax</b></th>
						</tr>
						
						<tr>
							<td><font class="bashcommand">for</font></td>
							<td>For iterating over a series of items within a list (array).</td>
							<td>
								for item in list_of_items<br>
								do<br>
								&emsp;Commands to run on each item<br>
								done 
							</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">for</font></td>
							<td>For iterating through an index.</td>
							<td>
								for ((i=1; i<=64; i+=1))<br>
								do<br>
								&emsp;Commands to run on each iteration<br>
								done
							</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">while</font></td>
							<td>For iterating while a control expression (condition) is true.</td>
							<td>
								while condition_is_true<br>
								do<br>
								&emsp;Commands to run while the condition is true<br>
								done 
							</td>
						</tr>
				</table>
		    	
		    	<h3>7.1. The for loop</h3>
					<h4>Iterating through an array of words</h4>
		    		
					<p>
						In the following example we have an array with a list of subjects ID:<br>
						<font class="bashcommand">
						$ declare -a ARRAY=('SUBJ0' 'SUBJ9' 'SUBJ3' 'SUBJ4' 'SUBJ3') 
						</font>
					</p>
					
					<p>If we wanted to print the ID of each subject within the list without using a loop, we would have to type 5 different commands (imagine if you have 800 subjects?):</p>
					
					<p>
						<font class="bashcommand">
							$ echo ${ARRAY[0]}<br> 
							<font class="bashcommand-result">SUBJ0</font><br>
							$ echo ${ARRAY[1]}<br>
							<font class="bashcommand-result">SUBJ9</font><br>
							$ echo ${ARRAY[2]}<br>
							<font class="bashcommand-result">SUBJ3</font><br>
							$ echo ${ARRAY[3]}<br>
							<font class="bashcommand-result">SUBJ4</font><br>
							$ echo ${ARRAY[4]}<br>
							<font class="bashcommand-result">SUBJ3</font> 
						</font>
					</p>
					
					<p>If we use a loop, you will just need to write the command one time. In this example, with only five subjects it doesn’t save too much lines of code. But normally you will be working with many more subjects than five.</p>
					
					<p>
						<font class="bashcommand">
							$ for ID in ${ARRAY[@]}<br>
							&gt;  do<br>
							&gt;  echo ${ID}<br>
							&gt;  done<br>
							<font class="bashcommand-result">
							SUBJ0<br>
							SUBJ9<br>
							SUBJ3<br>
							SUBJ4<br>
							SUBJ3  
							</font>
						</font>
					</p>
		    		
					<p>What this for loop does is iterate through every item in <font class="bashcommand">${ARRAY[@]}</font> (the items that would be listed if you typed echo <font class="bashcommand">${ARRAY[@]}</font>) and assign each item to the variable <font class="bashcommand">ID</font> during the corresponding loop. So, the loop will run 5 times. The first time it runs it will assign subject <font class="bashcommand">'SUBJ0'</font> to variable <font class="bashcommand">ID</font>, the second time subject <font class="bashcommand">'SUBJ9'</font>, etc.</p>

					<p>
						<font class="bashcommand">
							$ num=0<br>
							$ for ID in ${ARRAY[@]}<br>
							&gt;  do<br>
							&gt;  echo "Subject number ${num} is ${ID}"<br>
							&gt;  ((num++))<br>
							&gt;  done<br>
							<font class="bashcommand-result">
							Subject number 0 is SUBJ0<br>
							Subject number 1 is SUBJ9<br>
							Subject number 2 is SUBJ3<br>
							Subject number 3 is SUBJ4<br>
							Subject number 4 is SUBJ3 
							</font>
						</font>
					</p>
					
					<h4>Iterating through files using patterns</h4>
					<p>
						As we learned in the Arrays section, you can use patterns to create arrays. You can also use patterns to list files which path is very similar except for a few words. For example, if you have a folder located in the following path:<br>  
						/Users/MyUserName/Desktop/MyProjectFolder<br>
						And inside this folder you have 100 files named very similarly (only vary in one character):<br>
						DTI_SUBJ1.nii.gz<br>
						DTI_SUBJ2.nii.gz<br>
						DTI_SUBJ3.nii.gz<br>
						DTI_SUBJ4.nii.gz<br>
						DTI_SUBJ5.nii.gz<br> 
						...<br>
						DTI_SUBJ100.nii.gz<br>
						Then, you could echo the list of all those files by simply typing:<br>
						<font class="bashcommand">$ echo /Users/MyUserName/Desktop/MyProjectFolder/DTI_SUBJ*.nii.gz</font><br>
						The previous command matches all the file paths that contain any characters in the position where the asterisk is located.
					</p>
					
					<p>
						Or let's suppose that you have your subject's information organized in the following way:<br>
						You have your main subjects folder located in this path:<br>
						/Users/MyUserName/Desktop/MyProjectFolder<br>
						Then, inside that folder you have one folder per subject:<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject1<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject2<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject3<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject4<br>
						...<br>
						/Users/MyUserName/Desktop/MyProjectFolder/Subject100<br>
						And inside each subject folder, you have the following files:<br>
						DTI.nii.gz<br>
						ANAT.nii.gz<br>
						LGN.nii.gz 
					</p>
					
					<p>
						So, if you wanted to obtain the list of the DTI.nii.gz files for all subjects, you could type:<br> 
						<font class="bashcommand">echo /Users/MyUserName/Desktop/MyProjectFolder/Subject*/DTI.nii.gz</font><br>
						Because the path of the DTI of all subjects is the same except for the subject number, then you create the pattern by substituting the part that changes by an asterisk <font class="bashcommand">*</font>. 
					</p>
					
					<p>
						When using the asterisk, it will select all files that contain any amount of characters in that position. But if you want to restrict the search to a specific amount of characters, you could also use the interrogation character.
					</p>
					
					<p>
						For example, let's supose you have a main folder located in the folowing path:<br>
						/MyComputer/MyUser/MyDocuments/MyFolder<br>
						And inside that folder you have 100 files named:<br>
						myFile001.txt<br>
						myFile002.txt<br>
						...<br>
						myFile099.txt<br>
						myFile100.txt
					</p>
					
					<p>You want to iterate through the files myFile001.txt to myFile009.txt. All those files have the exact same path and name except for exactly one character. So, you can replace that character by an interrogration:</p>
					
					<p>	
						<font class="bashcommand">
							$ for f in /MyComputer/MyUser/MyDocuments/MyFolder/myFile00?.txt<br>
							&gt;  do<br>
							&gt;  echo $f<br>
							&gt;  done<br>
							<font class="bashcommand-result">
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile001.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile002.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile003.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile004.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile005.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile006.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile007.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile008.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile009.txt
							</font>
						</font>
					</p>
					
					<p>
						You could choose to print the results into a file instead of the command prompt. This can be easily achieved using the symbol <font class="bashcommand">&gt;&gt;</font>. After running the following loop, you will not see any output in the command line, the path of the nine files will be saved in output.txt:<br>
						The command <font class="bashcommand">cat ${maindir}output.txt</font> prints the content of this output file.
					</p>
					
					<p>
						<font class="bashcommand">
							$ maindir=/MyComputer/MyUser/MyDocuments/MyFolder/<br>
							$ for f in ${maindir}myFile00?.txt<br>
							&gt;  do<br>
							&gt;  echo $f &gt;&gt; ${maindir}output.txt<br>
							&gt;  done<br>
							$ cat ${maindir}output.txt<br>
							<font class="bashcommand-result">
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile001.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile002.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile003.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile004.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile005.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile006.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile007.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile008.txt<br>
							/MyComputer/MyUser/MyDocuments/MyFolder/myFile009.txt
							</font>
						</font>
					</p>
					
					<h4>Iterating through files in your current directory</h4>
					<p>To know the current directory in which you are located in the command line, type <font class="bashcommand">pwd</font>. In the following example we want to we want to perform some action on all the files inside the current directory. To get the list of those files we use the command <font class="bashcommand">ls</font>.</p>
					
					<p>
						<font class="bashcommand">
						$ pwd<br>
						<font class="bashcommand-result">/path/to/my/current/directory</font><br>
						$ for f in $( ls )<br>
						&gt;  do<br>
						&gt;  echo "Do something with this file: ${f}"<br>
						&gt;  done
						</font>
					</p>
					
		    	<h3>7.2. From for to while</h3>
		    		<p>Every loop that you write using the for command, can also be written using the while command. The results will be the same but sometimes one of them will be more efficient and easier to code than the other. In general, the for command is a lot easier to use and understand. However:</p>

					<ul>
					  <li>You should use the <b>for</b> command when you want to iterate through <b>all the elements</b> of an array.</li>
					  <li>You should use the <b>while</b> command when you want to iterate through <b>a limited number of elements within the array.</b></li>
					  <li>You should use the <b>while</b> command when you want to <b>iterate through more than one array</b> or while <b>several conditions should be met</b>.</li>
					</ul>
					
					<p>The following example shows how a for loop can be converted into a while loop. The objective of this piece of code is to print the elements of an array.</p>
		    		
					<p>
						<font class="example">From for to while</font>
						<font class="bashcommand">$ declare -a ARRAY=('SUBJ0' 'SUBJ9' 'SUBJ3' 'SUBJ4' 'SUBJ3')</font>
					</p>
					
					<table>
						<tr>
							<th><b>Using a for loop</b></th>
							<th><b>Using a while loop</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">
									$ for E in ${ARRAY[@]}<br>
									&gt;  do<br>
									&gt;  echo ${E}<br>
									&gt;  done<br>
									<font class="bashcommand-result"> 
									SUBJ0<br>
									SUBJ9<br>
									SUBJ3<br>
									SUBJ4<br>
									SUBJ3  
									</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ SIZE=${#ARRAY[@]} <br>
									$ i=0 <br>
									$ while [ ${i} -lt ${SIZE} ] <br>
									&gt;  do <br>
									&gt;  echo ${ARRAY[${i}]} <br>
									&gt;  ((i++)) <br>
									&gt;  done <br>
									<font class="bashcommand-result">
									SUBJ0 <br>
									SUBJ9 <br>
									SUBJ3 <br>
									SUBJ4 <br>
									SUBJ3 
									</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>In the previous example, both loops (the one in the left using a <b>for</b> and the one in the right using a <b>while</b>) iterate through the elements of an array and echoes them in the terminal window. However, there are some important differences:</p>
					
					<ul>
						<li>The <u>for loop</u> automatically stops when iteration reaches the end of the array. The <u>while loop</u> stops when the condition (<font class="bashcommand">[ ${i} -lt ${SIZE} ]</font>) evaluates false. This means that it will iterate as long as variable <font class="bashcommand">i</font> is less (<font class="bashcommand">-lt</font>) <font class="bashcommand">SIZE</font>. In the while loop, variable <font class="bashcommand">i</font> contains the index of each item during the iteration and variable <font class="bashcommand">SIZE</font> contains the size of the array. For this reason, <font class="bashcommand">((i++))</font> is included inside the while loop. <font class="bashcommand">((i++))</font> increments the value of <font class="bashcommand">i</font> in 1 on each iteration. If you didn't include this, bash would iterate forever, because you wouldn't be increasing the value of <font class="bashcommand">i</font> and it would always equal zero. Hence, it would never be less than the size of the array, so the condition that the while evaluates will never be false. Since while iterates as long as that condition is true, it would iterate forever.</li>
						<li>In the <u>for loop</u> each element of the array is saved in variable <font class="bashcommand">E</font>. However, you don't have to assign each value to the variable, it is done automatically. In the <u>while loop</u> the element in the position <font class="bashcommand">i</font> is being referenced with <font class="bashcommand">${ARRAY[${i}]}</font>.</li>
						<li>Off course, in this case as we want to iterate through all the elements of <font class="bashcommand">ARRAY</font>, it makes no sense to use the while loop. It requires more lines of code; it is easier to make mistakes and it is harder to understand. But this is a good example to show how it works. </li>
					</ul>
					
					<p>
						<font class="example">Printing the elements of an array and their position within the array</font>
						<font class="bashcommand">$ declare -a ARRAY=('SUBJ0' 'SUBJ9' 'SUBJ3' 'SUBJ4' 'SUBJ3')</font>
					</p>
					
					<table>
						<tr>
							<th><b>Using a for loop</b></th>
							<th><b>Using a while loop</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">
									$ i=0 <br>
									$ for ID in ${ARRAY[@]} <br>
									&gt;  do <br>
									&gt;  echo "Subject number ${i} is ${ID}" <br>
									&gt;  ((i++)) <br>
									&gt;  done <br>
									<font class="bashcommand-result"> 
									Subject number 0 is SUBJ0 <br>
									Subject number 1 is SUBJ9 <br>
									Subject number 2 is SUBJ3 <br>
									Subject number 3 is SUBJ4 <br>
									Subject number 4 is SUBJ3 
									</font>
								</font>
							</td>
							<td>
								<font class="bashcommand">
									$ SIZE=${#ARRAY[@]} <br>
									$ i=0 <br>
									$ while [ ${i} -lt ${SIZE} ] <br>
									&gt;  do <br>
									&gt;  echo "Subject number ${i} is ${ARRAY[$i]}" <br>
									&gt;  ((i++)) <br>
									&gt;  done <br>
									<font class="bashcommand-result">
									Subject number 0 is SUBJ0 <br>
									Subject number 1 is SUBJ9 <br>
									Subject number 2 is SUBJ3 <br>
									Subject number 3 is SUBJ4 <br>
									Subject number 4 is SUBJ3 
									</font>
								</font>
							</td>
						</tr>
					</table>
					
					<p>
						<font class="example">Printing the first five files in the current directory</font>
						Previously we learned that the following loop would echo the path of all the files in the current directory: 
					</p>
					
					<p>
						<font class="bashcommand">
						$ for f in $( ls ) <br>
						&gt; do <br>
						&gt; echo "Do something with this file: ${f}" <br>
						&gt; done 
						</font>
					</p>
					
					<p>In this case, it makes no sense to use the while loop. However, if instead of echoing all the files inside the current directory you wanted to echo only the first five files, then you must use the while loop.</p>
					
					<table>
						<tr>
							<th><b>Preferably use a for loop</b></th>
							<th><b>Preferably use a while loop</b></th>
						</tr>
						
						<tr>
							<td>
								<p>This loop will print <b>all</b> the files in the current directory:</p>
								<p>
									<font class="bashcommand">
										$ for f in $( ls ) <br>
										&gt; do <br>
										&gt; echo ${f} <br>
										&gt; done <br>
										<font class="bashcommand-result">
										Applications <br>
										Library <br>
										Network <br>
										System <br>
										Users <br>
										Volumes <br>
										cores <br>
										dev <br>
										net <br>
										opt <br>
										bin <br>
										tmp 
										</font>
									</font>
								</p>
							</td>
							<td>
								<p>This loop will print <b>the first five</b> files in the current directory:</p>
								<p>
									<font class="bashcommand">
										$ i=0 <br>
										$ ARRAY=($( ls )) <br>
										$ while [ ${i} -le 4 ] <br>
										&gt; do <br>
										&gt; echo ${ARRAY[${i}]} <br>
										&gt; ((i++)) <br>
										&gt; done <br>
										<font class="bashcommand-result">
										Applications <br>
										Library <br>
										Network <br>
										System <br>
										Users 
										</font>
									</font>
								</p>
							</td>
						</tr>
						
						<tr>
							<td>
								<p>This loop will rename <b>all</b> the files in the current directory that end in .nii.gz. Before and after the loop I am printing the content of the folder to visualize the change. Command ls prints the content of the current directory:  </p>
								<p>
									<font class="bashcommand">
										$ ls <br>
										<font class="bashcommand-result">
										10132423423.nii.gz <br> 
										25675756756.nii.gz <br>
										36787686767.nii.gz <br>
										37456456456.nii.gz <br>
										39756756756.nii.gz <br>
										41786786677.nii.gz <br>
										</font>
										$ i=1 <br>
										$ for f in ./*.nii.gz <br>
										&gt; do <br>
										&gt; mv ${f} Subject_${i}.nii.gz <br>
										&gt; ((i++)) <br>
										&gt; done <br>
										$ ls <br>
										<font class="bashcommand-result">
										Subject_1.nii.gz <br>
										Subject_2.nii.gz <br>
										Subject_3.nii.gz <br>
										Subject_4.nii.gz <br>
										Subject_5.nii.gz <br>
										Subject_6.nii.gz 
										</font>
									</font>
								</p>
							</td>
							<td>
								<p>This loop will rename <b>the first three</b> files in the current directory that end in .nii.gz. Before and after the loop I am printing the content of the folder to visualize the change. Command ls prints the content of the current directory:</p>
								<p>
									<font class="bashcommand">
										$ ls 
										<font class="bashcommand-result">
										10132423423.nii.gz <br>
										25675756756.nii.gz <br>
										36787686767.nii.gz <br>
										37456456456.nii.gz <br>
										39756756756.nii.gz <br>
										41786786677.nii.gz <br>
										</font>
										$ i=0 <br>
										$ ARRAY=($( ls ./*.nii.gz )) <br>
										$ while [ ${i} -le 2 ] <br>
										&gt; do <br>
										&gt; mv ${ARRAY[${i}]} ./Subject_$((++i)).nii.gz <br>
										&gt; done <br>
										$ ls <br>
										<font class="bashcommand-result">
										Subject_1.nii.gz <br>
										Subject_2.nii.gz <br>
										Subject_3.nii.gz <br>
										37456456456.nii.gz <br>
										39756756756.nii.gz <br>
										41786786677.nii.gz 
										</font>
									</font>
								</p>
							</td>
						</tr>
					</table>
					

		    	<h3>7.3. The while loop</h3>
					<h4>Using the while loop to iterate through more than one array</h4>
					
		    		<p>As previously mentioned, when you are iterating through more than one array you should use the while loop instead of the for loop.</p>
		    
					<p>
						<font class="example">Iterating through two arrays at the same time</font>
						In the following example there are two arrays (<font class="bashcommand">ID</font> and <font class="bashcommand">VISIT</font>), which contain a list of subject IDs and visit number respectively. The loop iterates through both arrays (until it reaches the end of one or the other) and saves the information extracted from both arrays into a text file. Then, it prints the content of the text file (test.txt) using the command cat, which will be explained in detail in the following chapter (File manipulation). 
					</p>
					
					<p>This while loop will run as long as the two conditions (<font class="bashcommand">[ ${i} -lt ${SIZE_ID} ]</font>, <font class="bashcommand">[ ${i} -lt ${SIZE_VISIT} ]</font>) that are being evaluated be true. This means, as long as variable <font class="bashcommand">i</font> have value less than (<font class="bashcommand">-lt</font>) the size of <font class="bashcommand">ID</font> and <font class="bashcommand">VISIT</font>. So, as soon as its value be greater than <font class="bashcommand">SIZE_ID</font> or <font class="bashcommand">SIZE_VISIT</font>, it will stop. In this case both arrays have the same size. Again, it is extremely important to not forget the line <font class="bashcommand">((i++))</font>, otherwise, it will loop forever (you can always break a loop with Control + C). </p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ID=('SUBJ0' 'SUBJ1' 'SUBJ2' 'SUBJ3' 'SUBJ4' 'SUBJ5' 'SUBJ6') <br>
							$ declare -a VISIT=('V1' 'V1' 'V2' 'V1' 'V2' 'V2' 'V3') <br>
							$ SIZE_ID=${#ID[@]} <br>
							$ SIZE_VISIT=${#VISIT[@]} <br>
							$ i=0 <br>
							$ while [ ${i} -lt ${SIZE_ID} ] && [ ${i} -lt ${SIZE_VISIT} ] <br>
							&gt; do <br>
							&gt; echo "${ID[${i}]}_${VISIT[${i}]}" &gt;&gt; test.txt <br>
							&gt; ((i++)) <br>
							&gt; done <br>
							$ cat test.txt <br>
							<font class="bashcommand-result">
							SUBJ0_V1 <br>
							SUBJ1_V1 <br>
							SUBJ2_V2 <br>
							SUBJ3_V1 <br>
							SUBJ4_V2 <br>
							SUBJ5_V2 <br>
							SUBJ6_V3 
							</font>
						</font>
					</p>
					
					<p>
						<font class="example">Inverting an array</font>
						In this example, initially there is only one array, but after the code is executed there will be two arrays. The second array will be the inversion of the first one. The code will iterate starting at the end of the array and finishing at the beginning. In each iteration it will copy the current value into the new array. It will start adding items at the beginning of the new array (in the index 0). For this purpose, there will be two variables. Variable <font class="bashcommand">i</font>, which will be initialized with value <font class="bashcommand">$(( ${#ARRAY[@]} – 1 ))</font> (the size of the initial array minus one) and will represent the position in which the loop is iterating in the original array. In each loop <font class="bashcommand">i</font> will decrease its value in 1 until it reaches 0. And variable <font class="bashcommand">j</font>, which will be initialized with value 0 and will represent the position in which the loop is iterating in the inverted array. In each loop <font class="bashcommand">j</font> will increase its value until it reaches the size of the original array (when all the values would have finished being copied). So, the while will loop as long as variable <font class="bashcommand">i</font> have value greater or equal (<font class="bashcommand">-ge</font>) to 0. 
					</p>
					
					<p>Variable <font class="bashcommand">i</font> is initialized with value equal to the size of the array minus one instead of the size of the array because remember that the first index of an array is 0, so the last one is the size minus one.</p>
					
					<p>
						Order of values in the original array: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.<br>
						Order of values in the inverted array: 10, 9, 8, 7, 6, 5, 4, 3, 2, 1. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ declare -a ARRAY=('1' '2' '3' '4' '5' '6' '7' '8' '9' '10') <br>
							$ i=$(( ${#ARRAY[@]} - 1 )) <br>
							$ j=0 <br>
							$ while [ ${i} -ge 0 ] <br>
							&gt; do <br>
							&gt; echo "Copying element in position ${i} from the original array into position ${j} of the new array..." <br>
							&gt; INV_ARRAY[$((j++))]=${ARRAY[$((i--))]} <br>
							&gt; done <br>
							<font class="bashcommand-result">
							Copying element in position 9 from the original array into position 0 of the new array... <br>
							Copying element in position 8 from the original array into position 1 of the new array... <br>
							Copying element in position 7 from the original array into position 2 of the new array... <br>
							Copying element in position 6 from the original array into position 3 of the new array... <br>
							Copying element in position 5 from the original array into position 4 of the new array... <br>
							Copying element in position 4 from the original array into position 5 of the new array... <br>
							Copying element in position 3 from the original array into position 6 of the new array... <br>
							Copying element in position 2 from the original array into position 7 of the new array... <br>
							Copying element in position 1 from the original array into position 8 of the new array... <br>
							Copying element in position 0 from the original array into position 9 of the new array... <br>
							</font>
							$ echo ${INV_ARRAY[@]} <br>
							<font class="bashcommand-result">
							10 9 8 7 6 5 4 3 2 1 
							</font>
						</font>
					</p>
					
					<p>The command <font class="bashcommand">INV_ARRAY[$((j++))]=ARRAY[$((i--))]</font> is doing three things: assigning the element of <font class="bashcommand">ARRAY</font> in position <font class="bashcommand">i</font> to <font class="bashcommand">INV_ARRAY</font> in position <font class="bashcommand">j</font>, incrementing <font class="bashcommand">j</font> in one, and decreasing <font class="bashcommand">i</font> in one. It is equivalent to this set of instructions:</p>
					
					<p>
						<font class="bashcommand">
							INV_ARRAY[${j}]=ARRAY[${i}] <br>
							((j++)) <br>
							((i--)) 
						</font>
					</p>
					
					<h4>Using the while loop to iterate when several conditions should be met</h4>
					
					<p>In the following example there is an array of subject IDs (<font class="bashcommand">SUBJECTS</font>). Some of those subjects are controls and their ID starts with the letter C, other subjects are patients and their ID starts with the letter P. The array is organized so that the controls go before the patients. The loop will copy only the controls into a new array (<font class="bashcommand">CONTROLS</font>). So, there are two conditions to be met so that the loop continues to run: the index variable <font class="bashcommand">i</font> be less than the size of <font class="bashcommand">SUBJECTS</font> (<font class="bashcommand">${#SUBJECTS[@]}</font>), and the current element (<font class="bashcommand">SUBJECTS[${i}]</font>) start with the letter C. To get the first letter of the current element you must use the previously learned syntax to extract a sub-string: <font class="bashcommand">${STRING:START:NUM}</font>.</p>
					
					<p>
						The first condition (iterate while <font class="bashcommand">i</font> less than the size of the array <font class="bashcommand">SUBJECTS</font>) is written like this:<br>
						<font class="bashcommand">[ ${i} -lt ${#SUBJECTS[@]} ]</font>.
					</p>
					
					<p>
						The second condition (iterate while the current element in the loop starts with the letter C) is written like this:<br>
						<font class="bashcommand">
							$ declare -a SUBJECTS=('C01' 'C02' 'C03' 'C04' 'C05' 'C06' 'P07' 'P08' 'P09' 'P10') <br>
							$ i=0 <br>
							$ while [ ${i} -lt ${#SUBJECTS[@]} ] && [ "${SUBJECTS[${i}]:0:1}" == "C" ] <br>
							&gt; do <br>
							&gt; CONTROLS[${i}]=${SUBJECTS[$((i++))]} <br>
							&gt; done <br>
							$ echo ${CONTROLS[@]} <br>
							<font class="bashcommand-result">C01 C02 C03 C04 C05 C06</font>
						</font>
					</p>
			</div>
		       
		    <div id="content8" class="hidden">
		    	<h2>8. General file manipulation</h2>
		    	
		    	<h3>8.1. Basic concepts and simple commands</h3>
				<h4>The absolute path of a file</h4>
		    			<p>
						The absolute or full path of a file specifies its unique location in the file system, its name and extension. The absolute path of every file is different and constant. It will always be the same regardless of the current directory in which you are working (unless you move the file). This path follows a hierarchy of directories where the file is located, separating each directory with the delimiting character, which is the slash (<font class="bashcommand">/</font>) for Macintosh and Linux and the backslash (<font class="bashcommand">\</font>) for Windows. For example, a text file named file.txt located in the Desktop of a Mac computer, will commonly have an absolute path similar to this:<br> 
						<font class="bashcommand">/Users/user_name/Desktop/file.txt</font><br>
						To find the absolute path of a file you can drag and drop it into the Terminal. 
					</p>
					
					<p>
						For example, if this is the absolute path of a file: <br>
						<font class="bashcommand">/Users/user_name/Desktop/SomeFolder/Subfolder/file.txt</font> <br>
						It means that in the user Desktop there is a folder called <font class="bashcommand">SomeFolder</font>, inside <font class="bashcommand">SomeFolder</font> there is another folder called <font class="bashcommand">Subfolder</font>, and inside <font class="bashcommand">Subfolder</font> is located the corresponding file, with name <font class="bashcommand">file</font> and extension <font class="bashcommand">txt</font>. Inside a directory there can be two files with the same name but in this case, they must have a different extension. There cannot be two files with both the same name and same extension inside the same folder. 
					</p>
					
					<h4>The relative path of a file</h4>
					
					<p>The relative path of a file starts from the current working directory and represents the location of a specific file relative to this directory. It is always changing as it depends on what directory you are located in the terminal, but is a lot shorter than the absolute path.</p>
					
					<p>
						If the absolute path of a file is the following, meaning the file is located in the Desktop:<br>
						<font class="bashcommand">/Users/user_name/Desktop/file.txt</font><br>
						And the user current working directory is the desktop, then the relative path of the file is:<br>
						<font class="bashcommand">file.txt</font> or <font class="bashcommand">./file.txt</font><br>
						Since the file is located in the current directory, the user can use just the name and extension for the relative path. Adding <font class="bashcommand">./</font> doesn't do anything because <font class="bashcommand">./</font> represents the current directory. 
					</p>
					
					<p>
						The following relative paths represent files that are located in the current working directory: <br>
						<font class="bashcommand">
						File1.txt <br>
						File2.nii.gz <br>
						./File3.nii <br>
						./File4.docx
						</font>
					</p> 
					
					<p>
						The absolute path of these files will be something similar to this (for Mac users), if the current directory is the Desktop: <br>
						<font class="bashcommand">
						/Users/username/Desktop/File1.txt <br>
						/Users/username/Desktop/File2.nii.gz <br>
						/Users/username/Desktop/File3.nii <br>
						/Users/username/Desktop/File4.docx 
						</font>
					</p>
					
					<p>
						The same way as a dot (<font class="bashcommand">.</font>) represents the current directory in a relative path, two dots (<font class="bashcommand">..</font>) represent the parent directory. So, if the absolute path of my current working directory is the following:<br> 
						<font class="bashcommand">/Users/user_name/Desktop/SomeFolder</font><br>
						I can refer to files located in the parent directory (Desktop) using the double dots. So, all these files are located in the Desktop (the same as SomeFolder): <br>
						<font class="bashcommand">
						../FileA.txt <br>
						../FileB.txt <br>
						../FileC.txt 
						</font>
					</p>
					
					<h4>Some tips about file paths</h4>
					
					<p>Both the absolute and relative paths are used to reference files when doing operations with it, but I generally prefer to use the absolute path when writing scripts because that way my script will run with no issues independently of my working directory. Never the less, when doing fast operations in the Terminal (like renaming or copying a file), then it's faster to use the relative path.</p>
					
					<p>
						It is also recommended to not use spaces or any other special characters when naming a file, because it makes it harder to write the path of that file. For example, if I have a file named Some File.txt in my Desktop (on a Mac), this is not the absolute path:<br> 
						<font class="bashcommand">/Users/user_name/Desktop/Some File.txt</font> <br>
						Instead, the absolute path will be: <br>
						<font class="bashcommand">/Users/user_name/Desktop/Some\ File.txt</font>
					</p>
		    		
					<p>The backslash is telling us to not treat the space as a special character but instead as part of the file path. This works the same way in Linux and MacOS.</p>
					
					<p>
						The same will happen with a file which name contains the dollar sign (which is a special character). For example, if in the Desktop there is a folder named <font class="bashcommand">untitled$folder</font>, this is <b>not</b> the absolute path: <br>
						<font class="bashcommand">/Users/user_name/Desktop/untitled$folder </font> <br>
						Instead, the absolute path will be: <br>
						<font class="bashcommand">/Users/user_name/Desktop/untitled\$folder </font>
					</p>
					
					<p>Again, the backslash is indicating us to treat the special character (<font class="bashcommand">$</font>) as part of the file name and not as the beginning of a variable name (which is the normal use of <font class="bashcommand">$</font> in bash). If we don't use the backslash before the dollar sign, bash will try to find a variable called folder (<font class="bashcommand">$folder</font> normally refers to the value of folder as a variable, not a string). If that variable doesn't exist, then bash will read <font class="bashcommand">/Users/user_name/Desktop/untitled$folder</font> as <font class="bashcommand">/Users/user_name/Desktop/untitled</font>, replacing <font class="bashcommand">$folder</font> for an empty space.</p>
					
					<p>In the following sections you will learn how the absolute and relative paths are used to manipulate files in <b>MacOS and Linux</b>.</p>
					
					<h4>pwd command</h4>
					<p>Prints the absolute path of the current working directory. </p>
					
					<h4>ls command</h4>
					<p>Lists the files and folders inside the specified directory. If no directory is specified after <font class="bashcommand">ls</font>, then it prints the contents of the current folder. If no flag is used, it lists the files in bare format (without any details such as modified date and time or permissions). Depending which flag is used (or a combination of flags), then specific information about the file will be displayed. The following table is taken from manual of the ls command as displayed in the command line.</p>

					<table>
						<tr>
							<th>Flag</th>
							<th>Usage</th>
						</tr>
						<tr>
							<td><font class="bashcommand">-1</font></td>
							<td>Force output to be one entry per line.  This is the default when output is not to a terminal.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-A</font></td>
							<td>List all entries except for (<font class="bashcommand">.</font>) and (<font class="bashcommand">..</font>). Always set for the super-user.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-a</font></td>
							<td>Include directory entries whose names begin with a dot (<font class="bashcommand">.</font>). Typically, these are configuration files for applications.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-B</font></td>
							<td>Force printing of non-printable characters in file names as \xxx, where xxx is the numeric value of the character in octal.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-b</font></td>
							<td>As <font class="bashcommand">-B</font>, but use C escape codes whenever possible.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-C</font></td>
							<td>Force multi-column output; this is the default when output is to a terminal.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-c</font></td>
							<td>Directories are listed as plain files (not searched recursively).</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-F</font></td>
							<td>Display a slash (<font class="bashcommand">/</font>) immediately after each pathname that is a directory, an asterisk (<font class="bashcommand">*</font>) after each that is executable, an at sign (<font class="bashcommand">@</font>) after each symbolic link, an equal sign (<font class="bashcommand">=</font>) after each socket, a percent sign (<font class="bashcommand">%</font>) after each whiteout, and a vertical bar (<font class="bashcommand">|</font>) after each that is a FIFO.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-f</font></td>
							<td>Output is not sorted. This option turns on the <font class="bashcommand">-a</font> option.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-G</font></td>
							<td>Enable colorized output.  This option is equivalent to defining <font class="bashcommand">CLICOLOR</font> in the environment.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-H</font></td>
							<td>Symbolic links on the command line are followed. This option is assumed if none of the <font class="bashcommand">-F</font> or <font class="bashcommand">-l</font> options are specified.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-i</font></td>
							<td>For each file, print the files file serial number (inode number). Each object in the file system is represented by an inode.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-k</font></td>
							<td>If the <font class="bashcommand">-s</font> option is specified, print the file size allocation in kilobytes, not blocks. This option overrides the environment variable <font class="bashcommand">BLOCKSIZE</font>.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-L</font></td>
							<td>Follow all symbolic links to final target and list the file or directory the link references rather than the link itself. This option cancels the <font class="bashcommand">-P</font> option.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-l</font></td>
							<td>List in long format.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-l@</font></td>
							<td>Display extended attribute keys and sizes in long output.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-le</font></td>
							<td>Print the Access Control List (ACL) associated with the file, if present, in long output.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-lg</font></td>
							<td>This option is only available for compatibility with POSIX; it is used to display the group name in the long format output (the owner name is suppressed).</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-lh</font></td>
							<td>Use unit suffixes when displaying the information in long output: Byte, Kilobyte, Megabyte, Gigabyte, Terabyte and Petabyte, in order to reduce the number of digits to three or less using base 2 for sizes.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-ln</font></td>
							<td>Display user and group IDs numerically, rather than converting to a user or group name in a long output.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-lO</font></td>
							<td>Include the file flags in a long output.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-lT</font></td>
							<td>Display complete time information for the file, including month, day, hour, minute, second, and year.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-m</font></td>
							<td>Stream output format; list files across the page, separated by commas.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-o</font></td>
							<td>List in long format, but omit the group id.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-P</font></td>
							<td>If argument is a symbolic link, list the link itself rather than the object the link references. This option cancels the <font class="bashcommand">-H</font> and <font class="bashcommand">-L</font> options.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-p</font></td>
							<td>Write a slash (<font class="bashcommand">/</font>) after each filename if that file is a directory.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-q</font></td>
							<td>Force printing of non-graphic characters in file names as the interrogation character (<font class="bashcommand">?</font>); this is the default when output is to a terminal.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-R</font></td>
							<td>Recursively list subdirectories encountered.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-r</font></td>
							<td>Reverse the order of the sort to get reverse lexicographical order, or the oldest entries first (or largest files last, if combined with sort by size).</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-S</font></td>
							<td>Sort files by size.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-s</font></td>
							<td>Display the number of file system blocks actually used by each file, in units of 512 bytes, where partial units are rounded up to the next integer value.  If the output is to a terminal, a total sum for all the file sizes is output on a line before the listing. The environment variable <font class="bashcommand">BLOCKSIZE</font> overrides the unit size of 512 bytes.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-t</font></td>
							<td>Sort by time modified (most recently modified first) before sorting the operands by lexicographical order.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-u</font></td>
							<td>Use time of last access, instead of last modification of the file for sorting (<font class="bashcommand">-t</font>) or long printing (0<font class="bashcommand">-l</font>)</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-U</font></td>
							<td>Use time of file creation, instead of last modification for sorting (<font class="bashcommand">-t</font>) or long output (<font class="bashcommand">-l</font>).</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-v</font></td>
							<td>Force unedited printing of non-graphic characters; this is the default when output is not to a terminal.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-W</font></td>
							<td>Display whiteouts when scanning directories.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-w</font></td>
							<td>Force raw printing of non-printable characters. This is the default when output is not to a terminal.</td>
						</tr>
						<tr>
							<td><font class="bashcommand">-x</font></td>
							<td>The same as <font class="bashcommand">-C</font>, except that the multi-column output is produced with entries sorted across, rather than down the columns.</td>
						</tr>
					</table>
					
					<p>The following examples show the usage of the flags presented in the previous table and details on the results that can be obtained when using the command ls together with those flags.</p>
					
			    		<p><font class="example">ls with no flags</font></p>
			    
			    		<p>Show the list of files in the current working directory:</p>
			    		<p><font class="bashcommand">
						$ ls<br>
						<font class="bashcommand-result">
						Applicationshome<br>
						Libraryinstaller.failurerequests<br>
						Networknet<br>
						Subjectsopt<br>
						Usersprivate<br>
						Volumessbin<br>
						binmp<br>
						coresusr<br>
						devvar<br>
						etc 
						</font>
					</font></p>
			    
			    		<p><font class="example">Show the list of files in a different directory using the absolute path of that directory</font></p>
			    
			    		<p><font class="bashcommand">
						$ ls /Volumes/MyExternalDrive<br>
						<font class="bashcommand-result">
						ArticlesMRIdata SharedFolder 
						</font>
			    		</font></p>
			    
			    		<p><font class="example">Show the list of files in a subfolder (Applications) using the relative path</font></p>
			    
			    		<p><font class="bashcommand">
						$ ls Applications/<br>
						<font class="bashcommand-result">
						Calculator.app<br>
						Calendar.app<br>
						Chess.app<br>
						Dashboard.app<br> 
						Dictionary.app<br>
						EndNote X7<br>
						EndNote X8<br>
						FaceTime.app<br>
						Firefox.app<br>
						IBM<br>
						Image Capture.app<br>
						Launchpad.app<br>
						MATLAB_R2014b.app 
						</font>
					</font></p>
			    
			    		<p><font class="example">ls -l</font></p>
			    
			    		<p>When using the flag <font class="bashcommand">-l</font>, bash will not only show the list of files but also a description for each file. The output will be organized in columns, each one with a specific meaning. Most of these meanings will be discussed later as they are part of more advanced topics related to file manipulation.</p>
			    
			    		<p>
						<font class="bashcommand">
							$ ls -l /Volumes/MyExternalDrive<br> 
							<font class="bashcommand-result">Total 0</font>
						</font>
						<table class="ghostTable">
							<tr>
								<td><font class="bashcommand bashcommand-result">drwxr-xr-x</font></td>
								<td><font class="bashcommand bashcommand-result">22</font></td>
								<td><font class="bashcommand bashcommand-result">myUser</font></td>
								<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
								<td><font class="bashcommand bashcommand-result">714</font></td>
								<td><font class="bashcommand bashcommand-result">Sep 4</font></td>
								<td><font class="bashcommand bashcommand-result">11:40</font></td>
								<td><font class="bashcommand bashcommand-result">Articles</font></td>
							</tr>

							<tr>
								<td><font class="bashcommand bashcommand-result">-rw-r--r--@</font></td>
								<td><font class="bashcommand bashcommand-result">1</font></td>
								<td><font class="bashcommand bashcommand-result">myUse</font></td>
								<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
								<td><font class="bashcommand bashcommand-result">51620</font></td>
								<td><font class="bashcommand bashcommand-result">Jan 14</font></td>
								<td><font class="bashcommand bashcommand-result">2017</font></td>
								<td><font class="bashcommand bashcommand-result">CV.docx</font></td>
							</tr>

							<tr>
								<td><font class="bashcommand bashcommand-result">-rw-r--r--</font></td>
								<td><font class="bashcommand bashcommand-result">1</font></td>
								<td><font class="bashcommand bashcommand-result">myUser</font></td>
								<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
								<td><font class="bashcommand bashcommand-result">137195</font></td>
								<td><font class="bashcommand bashcommand-result">Jan 14</font></td>
								<td><font class="bashcommand bashcommand-result">2017</font></td>
								<td><font class="bashcommand bashcommand-result">CV.pdf</font></td>
							</tr>

							<tr>
								<td><font class="bashcommand bashcommand-result">drwxr-xr-x</font></td>
								<td><font class="bashcommand bashcommand-result">28</font></td>
								<td><font class="bashcommand bashcommand-result">myUser</font></td>
								<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
								<td><font class="bashcommand bashcommand-result">952</font></td>
								<td><font class="bashcommand bashcommand-result">Sep 10</font></td>
								<td><font class="bashcommand bashcommand-result">09:04</font></td>
								<td><font class="bashcommand bashcommand-result">MRIdata</font></td>
							</tr>

							<tr>
								<td><font class="bashcommand bashcommand-result">drwxrwxrwx</font></td>
								<td><font class="bashcommand bashcommand-result">5</font></td>
								<td><font class="bashcommand bashcommand-result">myUser</font></td>
								<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
								<td><font class="bashcommand bashcommand-result">170</font></td>
								<td><font class="bashcommand bashcommand-result">Sep 4</font></td>
								<td><font class="bashcommand bashcommand-result">11:15</font></td>
								<td><font class="bashcommand bashcommand-result">SharedFolder</font></td>
							</tr>
						</table>
			    		</p>
			    
			    		<table>
						<tr>
							<th>Column #</th>
							<th>Column name</th>
							<th>Meaning</th>
						</tr>
						
						<tr>
							<td>1</td>
							<td>File type + permissions</td>
							<td>See below for the explanation of the output presented in this column (file type and permissions from the <font class="bashcommand">ls -l</font> command).<td>
						</tr>
						
						<tr>
							<td>2</td>
							<td>Link count</td>
							<td>The meaning of the output presented in this column will be discussed in the section "Symbolic links" of "File manipulation".<td>
						</tr>
						
						<tr>
							<td>3</td>
							<td>Owner name</td>
							<td>The meaning of the output presented in this column will be discussed in the chapter "File permissions". If the owner is unknown, the number ID is displayed.<td>
						</tr>
						
						<tr>
							<td>4</td>
							<td>Group name</td>
							<td>The meaning of the output presented in this column will be discussed in the chapter "File permissions". If the owner is unknown, the number ID is displayed.<td>
						</tr>
						
						<tr>
							<td>5</td>
							<td>File Size</td>
							<td>Number of bytes in the file. See the flag <font class="bashcommand">-lh</font> to output the size of the file in human-readable format. <td>
						</tr>
						
						<tr>
							<td>6</td>
							<td>Last modified date</td>
							<td>Abbreviated month and day-of-month when the file was last modified.<td>
						</tr>
						
						<tr>
							<td>7</td>
							<td>Last modified time</td>
							<td>Abbreviated hour and minute when the file was last modified in military format (24 hours). If the file was last modified more than six months before, then the year of the last modification is displayed instead of the hour and minute.<td>
						</tr>
						
						<tr>
							<td>8</td>
							<td>File name</td>
							<td>Name of the file with its extension.<td>
						</tr>
			    		</table>
			    
			    		<p>File type and permissions from the ls -l command:</p>
			    
			    		<p>The first character of the first column, where the file type and permissions are specified, describes the type of file. It is one of the following characters:</p>
			    
			    		<table>
						<tr>
							<th>Character</th>
							<th>File type</th>
						</tr>
						
						<tr>
							<td><font class="bashcommand">b</font></td>
							<td>Block special file: provide access to hardware devices.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">c</font></td>
							<td>Character special file: provide access to hardware devices.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">d</font></td>
							<td>Directory.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">l</font></td>
							<td>Symbolic link: a file that points to another file (a shortcut). It does not contain the data in the target file; it simply contains a pointer somewhere in the file system.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">s</font></td>
							<td>Socket link: file used for communication between processes.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">p</font></td>
							<td>FIFO: special file that can be opened by various processes for exchanging data.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">-</font></td>
							<td>Regular file.</td>
						</tr>
			    		</table>
			    
			    		<p>
						The next three characters show the owner permissions (the things that the user listed as the owner can do):<br>
						2<sup>nd</sup> character: will have value <font class="bashcommand">r</font> if the owner can read the file, <font class="bashcommand">-</font> otherwise.<br>
						3<sup>rd</sup> character: will have value <font class="bashcommand">w</font> if the file can be written by the owner, <font class="bashcommand">-</font> otherwise.<br>
						4<sup>th</sup> character: will have value <font class="bashcommand">-</font> if the file is not executable by the owner. It will have value <font class="bashcommand">x</font>, <font class="bashcommand">s</font> or <font class="bashcommand">S</font> if it is executable by the owner or if that user can search the directory. 
			    		</p>
			    
			    		<p>
						The following three characters show the group permissions:<br>
						5<sup>th</sup> character: will have value <font class="bashcommand">r</font> if the users that are part of the group listed in the group name column can read the file, <font class="bashcommand">-</font> otherwise.<br>
						6<sup>th</sup> character: will have value <font class="bashcommand">w</font> if the users that are part of the group listed in the group name column can write the file, <font class="bashcommand">-</font> otherwise.<br>
						7<sup>th</sup> character: will have value <font class="bashcommand">-</font> if the file is not executable by the users that are part of the group listed in the group name column can write the file. It will have value <font class="bashcommand">x</font>, <font class="bashcommand">s</font> or <font class="bashcommand">S</font> if it is executable by these users of if they can search the directory. 
			    		</p>
			    
			    		<p>The rest of the characters represent other permissions or whether the file has extended attributes or security information. The permissions can be modified for any file, this will be explained in the chapter “File permissions”. Additionally, the total number of 512-byte blocks used by the files in the directory is displayed on a line by itself, immediately before the lines that contain the information of each file in the directory.</p>
			    
			    		<p>In the previous example, the first line of the result is, this means that the folder occupies less than one 512-block.</p>
			    
			    		<p>The second line is the following:</p>
					
			    		<font class="bashcommand-result"> 
						<table class="ghostTable">
							<tr>
								<td><font class="bashcommand">drwxr-xr-x</font></td>
								<td><font class="bashcommand">22</font></td>
								<td><font class="bashcommand">myUser</font></td>
								<td><font class="bashcommand">UserGroup</font></td>
								<td><font class="bashcommand">714</font></td>
								<td><font class="bashcommand">Sep 4</font></td>
								<td><font class="bashcommand">11:40</font></td>
								<td><font class="bashcommand">Articles</font></td>
							</tr>
						</table>
					</font>
			    
			    		<p>This means that <font class="bashcommand-result">Articles</font> is a directory, modified the last on September 4 of the current year at 11:40am (if it was pm, the value would be 23:40 instead of 11:40). This folder is owned by the user <font class="bashcommand-result">myUser</font>. This user can read, write and navigate through the folder. The other users can read and navigate the folder but cannot write on it.</p>
			    
				<p><font class="example">ls -l</font></p>

				<p>The information displayed in the 5<sup>th</sup> column (file size) of the previous example is difficult to interpret by a human. In order to see this information in a human-readable format, it is only necessary to add an <font class="bashcommand">h</font> to the <font class="bashcommand">-l</font> flag.</p>
		    	
				<font class="bashcommand">
				$ ls -lh /Volumes/MyExternalDrive<br>
				<font class="bashcommand bashcommand-result">
				Total 0
				</font>
				</font>
				<table class="ghostTable">
					<tr>
						<td><font class="bashcommand bashcommand-result">drwxr-xr-x</font></td>
						<td><font class="bashcommand bashcommand-result">22</font></td>
						<td><font class="bashcommand bashcommand-result">myUser</font></td>
						<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
						<td><font class="bashcommand bashcommand-result">714B</font></td>
						<td><font class="bashcommand bashcommand-result">Sep 4</font></td>
						<td><font class="bashcommand bashcommand-result">11:40</font></td>
						<td><font class="bashcommand bashcommand-result">Articles</font></td>
					</tr>
					<tr>
						<td><font class="bashcommand bashcommand-result">-rw-r--r--@</font></td>
						<td><font class="bashcommand bashcommand-result">1</font></td>
						<td><font class="bashcommand bashcommand-result">myUser</font></td>
						<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
						<td><font class="bashcommand bashcommand-result">50K</font></td>
						<td><font class="bashcommand bashcommand-result">Jan 14</font></td>
						<td><font class="bashcommand bashcommand-result">2017</font></td>
						<td><font class="bashcommand bashcommand-result">CV.docx</font></td>
					</tr>
					<tr>
						<td><font class="bashcommand bashcommand-result">-rw-r--r--</font></td>
						<td><font class="bashcommand bashcommand-result">1</font></td>
						<td><font class="bashcommand bashcommand-result">myUser</font></td>
						<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
						<td><font class="bashcommand bashcommand-result">134K</font></td>
						<td><font class="bashcommand bashcommand-result">Jan 14</font></td>
						<td><font class="bashcommand bashcommand-result">2017</font></td>
						<td><font class="bashcommand bashcommand-result">CV.pdf</font></td>
					</tr>
					<tr>
						<td><font class="bashcommand bashcommand-result">drwxr-xr-x</font></td>
						<td><font class="bashcommand bashcommand-result">28</font></td>
						<td><font class="bashcommand bashcommand-result">myUser</font></td>
						<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
						<td><font class="bashcommand bashcommand-result">952B</font></td>
						<td><font class="bashcommand bashcommand-result">Sep 10</font></td>
						<td><font class="bashcommand bashcommand-result">09:04</font></td>
						<td><font class="bashcommand bashcommand-result">MRIdata</font></td>
					</tr>
					<tr>
						<td><font class="bashcommand bashcommand-result">drwxrwxrwx</font></td>
						<td><font class="bashcommand bashcommand-result">5</font></td>
						<td><font class="bashcommand bashcommand-result">myUser</font></td>
						<td><font class="bashcommand bashcommand-result">UserGroup</font></td>
						<td><font class="bashcommand bashcommand-result">170B</font></td>
						<td><font class="bashcommand bashcommand-result">Sep 4</font></td>
						<td><font class="bashcommand bashcommand-result">11:15</font></td>
						<td><font class="bashcommand bashcommand-result">SharedFolder</font></td>
					</tr>
				</table>

				<p>When using the <font class="bashcommand">-lh</font> flag, the size of the file will be followed by a letter which represents the units:</p>

				<table>
					<tr>
						<th>Letter</th>
						<th>Unit</th>
						<th>Number of bytes per unit</th>
					</tr>
					<tr>
						<td>B</td>
						<td>Bytes</td>
						<td>2<sup>0</sup> bytes</td>
					</tr>
					<tr>
						<td>K</td>
						<td>Kilobytes</td>
						<td>2<sup>10</sup> bytes</td>
					</tr>
					<tr>
						<td>M</td>
						<td>Megabyte</td>
						<td>2<sup>20</sup> bytes</td>
					</tr>
					<tr>
						<td>G</td>
						<td>Gigabyte</td>
						<td>2<sup>30</sup> bytes</td>
					</tr>
					<tr>
						<td>T</td>
						<td>Terabyte</td>
						<td>2<sup>40</sup> bytes</td>
					</tr>
					<tr>
						<td>P</td>
						<td>Petabyte</td>
						<td>2<sup>50</sup> bytes</td>
					</tr>
				</table>

				<p><font class="example">Using more than one flag</font></p>

				<p>Most of the flags can be combined, except for the following group of flags which override each other (either partially or fully). If used together, only the last one specified will be the format used to display the information. Or if possible they will be applied in the order specified.</p>

				<ul>
					<li><font class="bashcommand">-1</font>, <font class="bashcommand">-C</font>, <font class="bashcommand">-x</font>, and <font class="bashcommand">-l</font></li>
					<li><font class="bashcommand">-c</font> and <font class="bashcommand">-u</font></li>
					<li><font class="bashcommand">-B</font>, <font class="bashcommand">-b</font>, <font class="bashcommand">-w</font>, and <font class="bashcommand">-q</font></li>
					<li><font class="bashcommand">-H</font>, <font class="bashcommand">-L</font> and <font class="bashcommand">-P</font></li>
				</ul>

				<p>Combine <font class="bashcommand">-lh</font>, <font class="bashcommand">-o</font>, and <font class="bashcommand">-r</font> to print the information in long format, using human readable file sizes (<font class="bashcommand">-lh</font>), omitting the group id (<font class="bashcommand">-o</font>) and in reverse lexicographical order (<font class="bashcommand">-r</font>):</p>

				<p>
					<font class="bashcommand">$ ls -lhor /Volumes/MyExternalDrive</font><br>
					<font class="bashcommand bashcommand-result">Total 0</font><br>
					<table class="ghostTable">
						<tr>
							<td><font class="bashcommand bashcommand-result">drwxrwxrwx</font></td>
							<td><font class="bashcommand bashcommand-result">5</font></td>
							<td><font class="bashcommand bashcommand-result">myUser</font></td>
							<td><font class="bashcommand bashcommand-result">170B</font></td>
							<td><font class="bashcommand bashcommand-result">Sep 4</font></td>
							<td><font class="bashcommand bashcommand-result">11:15</font></td>
							<td><font class="bashcommand bashcommand-result">SharedFolder</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand bashcommand-result">drwxr-xr-x</font></td>
							<td><font class="bashcommand bashcommand-result">28</font></td>
							<td><font class="bashcommand bashcommand-result">myUser</font></td>
							<td><font class="bashcommand bashcommand-result">952B</font></td>
							<td><font class="bashcommand bashcommand-result">Sep 10</font></td>
							<td><font class="bashcommand bashcommand-result">09:05</font></td>
							<td><font class="bashcommand bashcommand-result">MRIdata</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand bashcommand-result">-rw-r--r-- </font></td>
							<td><font class="bashcommand bashcommand-result">1</font></td>
							<td><font class="bashcommand bashcommand-result">myUser</font></td>
							<td><font class="bashcommand bashcommand-result">134K</font></td>
							<td><font class="bashcommand bashcommand-result">Jan14</font></td>
							<td><font class="bashcommand bashcommand-result">2017</font></td>
							<td><font class="bashcommand bashcommand-result">CV.pdf</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand bashcommand-result">-rw-r--r--@</font></td>
							<td><font class="bashcommand bashcommand-result">1</font></td>
							<td><font class="bashcommand bashcommand-result">myUser</font></td>
							<td><font class="bashcommand bashcommand-result">50K</font></td>
							<td><font class="bashcommand bashcommand-result">Jan 14</font></td>
							<td><font class="bashcommand bashcommand-result">2017</font></td>
							<td><font class="bashcommand bashcommand-result">CV.docx</font></td>
						</tr>
						<tr>
							<td><font class="bashcommand bashcommand-result">drwxr-xr-x</font></td>
							<td><font class="bashcommand bashcommand-result">22</font></td>
							<td><font class="bashcommand bashcommand-result">myUser</font></td>
							<td><font class="bashcommand bashcommand-result">714B</font></td>
							<td><font class="bashcommand bashcommand-result">Sep 4</font></td>
							<td><font class="bashcommand bashcommand-result">11:40</font></td>
							<td><font class="bashcommand bashcommand-result">Articles</font></td>
						</tr>
					</table>
				</p>
			<h3>8.2. Listing files using patterns</h3>
		    		<p>You can print information about a group of files based on patterns or characters using wildcards.</p>

				<p>
				<table>
					<tr>
						<th>Wildcard</th>
						<th>Meaning</th>
					</tr>
					<tr>
						<td><font class="bashcommand">*</font></td>
						<td>Matches any number of characters</td>
					</tr>
					<tr>
						<td><font class="bashcommand">?</font></td>
						<td>Matches any single character</td>
					</tr>
					<tr>
						<td>[character_class]</td>
						<td>
							Matches any character that is a member of the specified character class.<br><br>
							
							Character Classes:<br>
							<font class="bashcommand">[:alnum:]</font> Alphanumeric characters<br>
							<font class="bashcommand">[:alpha:]</font> Alphabetic characters<br>
							<font class="bashcommand">[:digit:]</font> Numerals<br>
							<font class="bashcommand">[:upper:]</font> Uppercase alphabetic characters<br>
							<font class="bashcommand">[:lower:]</font> Lowercase alphabetic characters 
						</td>
					</tr>
					<tr>
						<td>[!character_class]</td>
						<td>Matches any character that is not a member of the specified character class</td>
					</tr>
				</table>
				</p>

				<p>
				<table>
					<tr>
						<th>Pattern</th>
						<th>Matches</th>
					</tr>
					<tr>
						<td>AB*</td>
						<td>List all the filenames that begin with "AB"</td>
					</tr>
					<tr>
						<td>*AB</td>
						<td>List all the filenames that end with "AB"</td>
					</tr>
					<tr>
						<td>AB*.txt</td>
						<td>List all the filenames that begin with "AB" and end with ".txt"</td>
					</tr>
					<tr>
						<td>AB???</td>
						<td>List all the filenames that begin with "AB" followed by exactly three characters</td>
					</tr>
					<tr>
						<td>[aA]*</td>
						<td>List all the filenames that begin with "a" or "A"</td>
					</tr>
					<tr>
						<td>[aA]?.txt</td>
						<td>List all the filenames that begin with "a" or "A" followed by one character and ".txt"</td>
					</tr>
					<tr>
						<td>[[:upper:]]*</td>
						<td>List any filenames that begin with an uppercase letter</td>
					</tr>
					<tr>
						<td>[![:upper:]]*</td>
						<td>List any filenames that do not begin with an uppercase letter</td>
					</tr>
				</table>
				</p>

				<p>
					<font class="bashcommand">
					$ ls /Volumes/MyDrive/MyFolder/Articles/p*<br>
					<font class="bashcommand-result">
					/Volumes/MyDrive/MyFolder/Articles/patel and shen.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/perez 2013.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/pnas-0502843102.pdf<br> 
					/Volumes/MyDrive/MyFolder/Articles/pnas.201604898.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/pnas01522-0696.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/poldrack ROI analysis.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/pone.0088419.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/pone.0113807.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/pq004724.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/pq008939.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/precuneus.pdf<br>
					/Volumes/MyDrive/MyFolder/Articles/prefrontalCortex.pdf 
					</font>
					</font>
				</p>

				<p>
					<font class="bashcommand">
					$ ls /Volumes/MyExternalDrive/Shared/Articles/[pr]*<br>
					<font class="bashcommand-result">
					/Volumes/MyExternalDrive/Shared/Articles/patel and shen.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/perez 2013.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/pnas-0502843102.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/pnas.201604898.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/pnas01522-0696.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/poldrack ROI analysis.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/pone.0088419.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/pone.0113807.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/pq004724.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/pq008939.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/precuneus.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/prefrontalCortex.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/raz 2004.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/read1_Brain-2006-Ciccarelli-1859-71.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/read2_6165.pdf 
					</font>
					</font>
				</p>

				<p>
					<font class="bashcommand">
					$ ls /Volumes/MyExternalDrive/Shared/Articles/[pr]*.pdf<br>
					<font class="bashcommand-result">
					/Volumes/MyExternalDrive/Shared/Articles/patel and shen.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/perez 2013.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/pnas-0502843102.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/pnas.201604898.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/pnas01522-0696.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/poldrack ROI analysis.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/pone.0088419.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/pone.0113807.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/pq004724.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/pq008939.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/precuneus.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/prefrontalCortex.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/raz 2004.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/read1_Brain-2006-Ciccarelli-1859-71.pdf<br>
					/Volumes/MyExternalDrive/Shared/Articles/read2_6165.pdf 
					</font>
					</font>
				</p>

				<p>
					<font class="bashcommand">
					$ ls /Volumes/MyExternalDrive/Shared/Articles/[pr]????????.pdf<br>
					<font class="bashcommand-result">
					/Volumes/MyExternalDrive/Shared/Articles/precuneus.pdf
					</font>
					</font>
				</p>
			
			<h3>8.3. Changing the working directory</h3>
				<h4>The cd command</h4>

				<table>
					<tr>
						<th>Option</th>
						<th>Usage</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">cd ~</font></td>
						<td>Goes to the home directory</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">cd dir</font></td>
						<td>Goes to <font class="bashcommand">dir</font>, which is a sub directory located in the current directory</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">cd /dir</font></td>
						<td>Goes to <font class="bashcommand">dir</font>, which is a sub directory located in the home directory</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">cd ..</font></td>
						<td>Goes to the parent directory</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">cd -</font></td>
						<td>Goes to the previous directory</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">cd ~username</font></td>
						<td>Goes to the user home directory</td>
					</tr>
				</table>

				<p><font class="bashcommand">cd</font> changes the current working directory. The syntax is <font class="bashcommand">cd new_path</font>, where <font class="bashcommand">new_path</font> can be the absolute or relative path of the new working directory.</p>

				<p>Absolute paths are file locations with respect to the home directory and start with <font class="bashcommand">/</font>. Relative paths are file locations with respect to the current directory.</p>

				<p> 
					<font class="example">Go to the parent directory</font>
					Remember that double points (<font class="bashcommand">..</font>) represent the parent directory. If my current working directory is <font class="bashcommand">/Users/user_name/Desktop/SomeFolder</font>, after typing <font class="bashcommand">cd ..</font> the new working directory will be <font class="bashcommand">/Users/user_name/Desktop</font> (one folder up). If you type again <font class="bashcommand">cd ..</font>, now the working directory will be: <font class="bashcommand">/Users/user_name</font> (another folder up), etc. 
				</p>

				<p>
					<font class="bashcommand">
					$ pwd<br>
					<font class="bashcommand-result">/Users/user_name/Desktop/SomeFolder</font><br>
					$ cd ..<br>
					$ pwd<br>
					<font class="bashcommand-result">/Users/user_name/Desktop</font><br>
					$ cd ..<br>
					$ pwd<br>
					<font class="bashcommand-result">/Users/user_name</font><br>
					$ cd ..<br> 
					$ pwd<br>
					<font class="bashcommand-result">/Users</font><br>
					$ cd ..<br>
					$ pwd<br>
					<font class="bashcommand-result">/</font><br>
					</font>
				</p>

				<p><font class="bashcommand">/</font> represents the home directory and you cannot go up any more folders.</p>

				<p>
					<font class="example">Go to a folder specified by its absolute path</font>
					In this example, I am using the absolute path of a folder to jump from my current directory to that folder: 
				</p>

				<p>
					<font class="bashcommand">
					$ pwd<br>
					<font class="bashcommand-result">/Users/user_name/Desktop/SomeFolder</font><br>
					$ cd /Volumes/Shared<br>
					$ pwd<br>
					<font class="bashcommand-result">/Volumes/Shared</font>
					</font>
				</p>

				<p><font class="example">Go to the parent directory of my parent directory</font></p>

				<p>
					<font class="bashcommand">
					$ pwd<br>
					<font class="bashcommand-result">/Users/user_name/Desktop/SomeFolder</font><br>
					$ cd ../..<br>
					$ pwd<br>
					<font class="bashcommand-result">/Users/user_name</font>
					</font>
				</p>

				<p>
					<font class="example">Using other relative paths to change directory</font><br>
					If inside my current directory (<font class="bashcommand">/Users/user_name/Desktop/SomeFolder</font>) there is another folder (i.e. <font class="bashcommand">AnotherFolder</font>), I can go to that folder using its relative path: 
				</p>

				<p>
					<font class="bashcommand">
					$ pwd<br>
					<font class="bashcommand-result">/Users/user_name/Desktop/SomeFolder</font><br>
					$ cd AnotherFolder<br>
					<font class="bashcommand-result">/Users/user_name/Desktop/SomeFolder/AnotherFolder</font>
					</font>
				</p>

				<p>
					<font class="bashcommand">
					$ pwd<br>
					<font class="bashcommand-result">/Users/user_name/Desktop/SomeFolder</font><br>
					$ cd ./AnotherFolder<br>
					<font class="bashcommand-result">/Users/user_name/Desktop/SomeFolder/AnotherFolder</font>
					</font>
				</p>

				<p>
					<font class="example">Jumping to the previous directory</font><br>
					In this example, the first working directory is <font class="bashcommand">/Volumes/Shared</font>, then I jump to <font class="bashcommand">/Volumes/Shared/Articles</font> using the command <font class="bashcommand">cd</font>. Finally, I go back to the first working directory <font class="bashcommand">/Volumes/Shared</font>) using <font class="bashcommand">cd -</font>. 
				</p>

				<p>
					<font class="bashcommand">
					$ pwd<br>
					<font class="bashcommand-result">/Volumes/Shared</font><br>
					$ cd Articles<br>
					$ pwd<br>
					<font class="bashcommand-result">/Volumes/Shared/Articles</font><br>
					$ cd -<br>
					$ pwd<br>
					<font class="bashcommand-result">/Volumes/Shared</font>
					</font>
				</p>

		    	<h3>8.4. Other frequently used commands for file manipulation</h3>
				<h4>cp command</h4>
				Syntax: <font class="bashcommand">cp source target</font>
		    		
				<p>
				<font class="example">Copy the file /Users/MyUser/Desktop/test.txt into folder /Volumes/MyExternalDrive</font>
				<font class="bashcommand">$ cp /Users/MyUser/Desktop/test.txt /Volumes/MyExternalDrive</font>
				</p>

				<p>
				<font class="example">Copy file /Users/MyUser/Desktop/test.txt into folder /Volumes/MyExternalDrive, but save it with a different name in the new directory (i.e. test2.txt instead of test1.txt)</font>
				<font class="bashcommand">$ cp /Users/MyUser/Desktop/test.txt /Volumes/MyExternalDrive/test2.txt</font>
				</p>

				<p>
				As you can observe in the previous two examples, if you specify a folder as a target in the <font class="bashcommand">cp</font> command, then it will copy the file with the same name. If you specify a regular file as a target, then it will rename the file in the destination (not in the source, the source file will stay untouched). The source file need not have the same extension. For example, the following command will copy the file <font class="bashcommand">/Users/MyUser/Desktop/subjectFolder/534534.bvals</font> into the folder <font class="bashcommand">/Volumes/MyExternalDrive</font>, will rename it and delete the extension (now it has no extension).<br>
				<font class="bashcommand">$ cp /Users/MyUser/Desktop/subjectFolder/534534.bvals /Volumes/MyExternalDrive/bvals</font>
				</p>

				<p>
				Caution! If a file with the same name exists in the source, it will be re-written and this action cannot be undone. For example, if you run the following command:<br>
				<font class="bashcommand">$ cp /Users/MyUser/Desktop/test.txt /Volumes/MyExternalDrive/test2.txt</font>
				</p>

				<p>And a file with the same source path (<font class="bashcommand">/Volumes/MyExternalDrive/test2.txt</font>) already existed, then that file will be replaced by test.txt. You will not be able to recover the replaced file.</p>

				<h4>mv command</h4>
				Syntax: <font class="bashcommand">mv source target</font>

				<p>The <font class="bashcommand">mv</font> command works the same way was the <font class="bashcommand">cp</font> command. The difference is that the source file is moved instead of copied.</p>

				<font class="example">Renaming a file</font>
				Rename file <font class="bashcommand">test1.txt</font> to <font class="bashcommand">test2.txt</font> in the current directory.

				<p><font class="bashcommand">
				$ ls<br>
				<font class="bashcommand-result">
				Applications<br> 
				Library<br>
				Volumes<br> 
				bin<br>
				test1.txt<br>
				</font>
				$ mv test1.txt test2.txt<br>
				$ ls<br>
				<font class="bashcommand-result">
				Applications<br>
				Library<br>
				Volumes<br> 
				bin<br>
				test2.txt 
				</font>
				</font></p>

				<h4>rm / rmdir commands</h4>

				<h4>mkdir command</h4>

				<h4>touch command</h4>

				<h4>find command</h4>

				<font class="example">Moving a file from one directory to another</font>
				Move <font class="bashcommand">test1.txt</font> from directory <font class="bashcommand">/Users/MyUser/</font> to directory <font class="bashcommand">/Volumes/MyExternalDrive</font>.

				<p><font class="bashcommand">
				$ ls /Volumes/MyDrive<br>
 				<br>
				$ mv /Users/MyUser/Desktop/test1.txt /Volumes/MyDrive <br>
				$ ls /Volumes/MyDrive<br>
				<font class="bashcommand-result">test1.txt</font>
				</font></p>
		    </div>
		       
		    <div id="content9" class="hidden">
		    	<h2>9. Manipulating text and csv files</h2>
			    
			<h3>9.1. Writing files</h3>
				<h4>echo</h4>
				<p>So far we have used echo to print text into the terminal. You can also use this utility to print text into a file (and create a new file if it doesn't exist):</p>
		    		
				<p>
				The following command will append <font class="bashcommand">"some text"</font> in a new line of <font class="bashcommand">someFile.txt</font> and add the new line character at the end. If someFile.txt didn’t exist, the file is created.<br>
				<font class="bashcommand">echo "some text" >> someFile.txt</font>
				</p>

				<p>
				If you add the flag <font class="bashcommand">-n</font>, bash won't print the trailing newline character:<br> 
				<font class="bashcommand">echo -n "some text" >> someFile.txt</font>
				</p>

				<p>If you add the flag <font class="bashcommand">-e</font> it will interpret the character scape sequences in the text (see table below in the <font class="bashcommand">printf</font> section for a list of scape sequences).</p>

				<p>If you use <font class="bashcommand">&gt;</font> instead of <font class="bashcommand">&gt;&gt;</font>, the previous contents of the file (if it existed) will be erased and replaced with the new text that you are echoing.</p>

				<h4>printf</h4>
				<p><font class="bashcommand">printf</font> is a powerful tool that allows you to format the information before printing it in a file, the command line or another variable. For example, you can specify the format of any number that you print and the number of decimal points you want to use. You could even use this tool to change the format of a variable (i.e. from scientific notation to float) and save the result in a new variable instead of a file. You can also add tab or any character scape sequence to your text.</p>

				<p>Syntax: <font class="bashcommand">printf &lt;format&gt; &lt;arguments&gt;</font></p>

				<p><font class="bashcommand">printf</font> uses the format specified in <font class="bashcommand">&lt;format&gt;</font> to print the objects (strings, numbers or variables) specified in <font class="bashcommand">&lt;arguments&gt;</font>. <font class="bashcommand">&lt;format&gt;</font> is a string that contains alphanumerical characters, character scape sequences and format specifications, each of which causes printing of the next successive argument. In contrast with the <font class="bashcommand">echo</font> command, <font class="bashcommand">printf</font> does not print the text in a new line by default, in order to add a new line the following character scape sequence should be added at the end of <font class="bashcommand">&lt;format&gt;</font>: <font class="bashcommand">\n</font>.</p>
		    	
				<table>
					<tr>
					<th>Character scape sequence</th>
					<th>Meaning</th>
					</tr>

					<tr>
					<td><font class="bashcommand">\b</font></td>
					<td>
						<p>Do not print the previous character (backspace).</p>
						<p><font class="bashcommand">
							$ printf "%b" "abcdef"<br>
							<font class="bashcommand-result">abcdef</font>
						</font></p>
						<p><font class="bashcommand">
							$ printf "%b" "abc\bdef"<br>
							<font class="bashcommand-result">abdef</font>
						</font></p>
					</td>
					</tr>

					<tr>
					<td><font class="bashcommand">\c</font></td>
					<td> </td>
					</tr>

					<tr>
					<td><font class="bashcommand">\n</font></td>
					<td> 
						<p>Write a new-line character.</p>
						<p><font class="bashcommand">
							$ printf "%b" "abc\ndef"<br>
							<font class="bashcommand-result">
							abc<br>
							def
							</font>
						</font></p>
					</td>
					</tr>

					<tr>
					<td><font class="bashcommand">\r</font></td>
					<td>Write a &lt;carriage return&gt; character.</td>
					</tr>

					<tr>
					<td><font class="bashcommand">\t</font></td>
					<td> 
						<p>Write a &lt;tab&gt; character.</p>
						<p><font class="bashcommand">
							$ printf "%b" "abc\tdef"<br>
							<font class="bashcommand-result">abc   def</font>
						</font></p>
					</td>
					</tr>

					<tr>
					<td><font class="bashcommand">\v</font></td>
					<td> 
						<p>Write a &lt;vertical tab&gt; character.</p>
						<p><font class="bashcommand">
							$ printf "%b" "abc\vdef"<br>
							<font class="bashcommand-result">
							abc<br>
							   def 
							</font>
						</font></p>
					</td>
					</tr>

					<tr>
					<td><font class="bashcommand">\'</font></td>
					<td>Write a single quote character.</td>
					</tr>

					<tr>
					<td><font class="bashcommand">\\</font></td>
					<td>Write a backslash character.</td>
					</tr>

					<tr>
					<td><font class="bashcommand">\num</font></td>
					<td>Write a byte whose value is the 1-, 2-, or 3-digit octal number <font class="bashcommand">num</font>. Multibyte characters can be constructed using multiple \num sequences.</td>
					</tr>
				</table>

				<p>Each format specification is introduced by the percent character (<font class="bashcommand">%</font>), followed by the following fields (in the exact order). You must use one format specification for each argument (in the same order):</p>
			
				<table>
					<tr>
						<th>Flag</th>
						<th>Meaning</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">#</font></td>
						<td> 
							<p>When printing an octal number: Inserts a 0 prefix.</p>
							<p>(234)<sub>10</sub> = (352)<sub>8</sub></p>
							<p><font class="bashcommand">
								$ printf "%o\n%#o\n" 234 234<br>
								<font class="bashcommand-result">
								352<br>
								0352 
								</font>
							</font></p>
							<p>When printing a hexadecimal number: Inserts a 0x prefix.</p>
							<p>Given that (234)<sub>10</sub> = (EA)<sub>16</sub></p>
							<p><font class="bashcommand">
								$ printf "%x\n%#x\n" 234 234<br>
								<font class="bashcommand-result">
								ea<br>
								0xea 
								</font>
							</font></p>
							<p>When printing numbers using formats e (E), f (F) or g (G): Show the decimal point.</p>
						</td>
					</tr>	
					
					<tr>
						<td><font class="bashcommand">-</font></td>
						<td>Left justify.</td>
					</tr>	
					
					<tr>
						<td><font class="bashcommand">+</font></td>
						<td>Place a sign before the number when using signed formats.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand"> </font></td>
						<td>&lt;blank space&ht; Positive values begin with a blank. </td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">0</font></td>
						<td>Field is padded with zeros instead of blanks.</td>
					</tr>
				</table>

				<p>Field width or precision: An integer number preceded by a period (<font class="bashcommand">.</font>) or an asterisk (<font class="bashcommand">*</font>). If a number is given, it will represent the number of characters or digits to print if the argument is a string or a number (respectively). If an asterisk is given instead of a number, the field width or precision will be specified as another argument.</p>

				<p><font class="bashcommand">
				$ printf "%s\n" "qwertyuiop"<br>
				<font class="bashcommand-result">qwertyuiop</font>
				</font></p>

				<p><font class="bashcommand">
				$ printf "%.4s\n" "qwertyuiop"<br>
				<font class="bashcommand-result">qwer</font>
				</font></p>

				<p><font class="bashcommand">
				$ printf "%.*s\n" 6 "qwertyuiop"<br>
				<font class="bashcommand-result">qwerty</font>
				</font></p>
				
				<p>Format: This is a character that indicates the type of format that should be used to print the arguments. The character options are listed in the following table.</p>

				<table>
					<tr>
						<th>Character</th>
						<th>Format</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">%</font></td>
						<td> 
							<p>Prints the symbol <font class="bashcommand">%</font>. No argument is used</p>
							<p><font class="bashcommand">
							$ printf "%%"<br>
							<font class="bashcommand-result">%</font>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%% %s" "Some string"<br>
							<font class="bashcommand-result">% Some string</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">a</font> or <font class="bashcommand">A</font></td>
						<td>Prints the argument in floating-point, hexadecimal form. The style used is <font class="bashcommand">[-h.hhh+-pd]</font>. Most probably you will never need to use this format other than for technical purposes.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">b</font></td>
						<td> 
							<p>Same as <font class="bashcommand">s</font>, but interprets the character scape sequences instead of reading them as literal strings.</p>
							<p><font class="bashcommand">
							$ printf "%s" "text\ntext"<br> 
							<font class="bashcommand-result">text\ntext</font><br>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%b" "text\ntext"<br>
							<font class="bashcommand-result">
							text<br>
							text 
							</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">c</font></td>
						<td>
							<p>The first byte of the argument is printed. Which will correspond to the first character if the argument is a string, or the first digit if it is a number.</p>
							<p><font class="bashcommand">
							$ printf "%c %c" "some string" 199<br>
							<font class="bashcommand-result">s 1</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">d</font> or <font class="bashcommand">i</font></td>
						<td> 
							<p>The argument must be a positive or negative integer. If no precision is specified, it just prints the number, otherwise it adds zeros before the integer to achieve the number of digits specified in the precision.</p>
							<p><font class="bashcommand">
							$ printf "%d\n%i\n" 2 -2<br>
							<font class="bashcommand-result">
							2<br>
							-2 
							</font>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%.3d\n%.5i\n" -2 2<br>
							<font class="bashcommand-result">
							-002<br>
							00002 
							</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">e</font> or <font class="bashcommand">E</font></td>
						<td> 
							<p>Writes the number in the argument in scientific notation, with format <font class="bashcommand">[-]d.ddde+-dd</font>. There will be one digit before the decimal point and six digits after the decimal point if no precision is specified (or the number of digits specified in the precision). Infinity is printed as <font class="bashcommand">inf</font> and <font class="bashcommand">NaN</font> as <font class="bashcommand">nan</font>. If the flag is in upper case, the <font class="bashcommand">e</font> of the output will be printed in capital letter.</p>
							<p>234.567 equals 2.34567 × 102 in scientific notation. So, <font class="bashcommand">printf</font> would print that number in the following way:</p>
							<p><font class="bashcommand">
							$ printf "%e" 234.567<br> 
							<font class="bashcommand-result">2.345670e+02</font>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%.1e" 234.567<br>
							<font class="bashcommand-result">2.3e+02</font>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%.1E" 234.567<br> 
							<font class="bashcommand-result">2.3E+02</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">f</font> or <font class="bashcommand">F</font></td>
						<td> 
							<p>Prints the argument as a floating-point number with the format <font class="bashcommand">[-]ddd.ddd</font>. The number of digits after the decimal point equals the precision specification for the argument or six digits if no precision was specified. Infinity is printed as <font class="bashcommand">inf</font> and <font class="bashcommand">NaN</font> as <font class="bashcommand">nan</font>.</p>
							<p><font class="bashcommand">
							$ printf "%f\n" 2.34567890123<br>
							<font class="bashcommand-result">2.345679</font>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%.3f\n" -2.34567890123<br>
							<font class="bashcommand-result">-2.346</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">g</font> or <font class="bashcommand">G</font></td>
						<td> 
							<p>The argument is printed in style <font class="bashcommand">f</font> (<font class="bashcommand">F</font>) or in style <font class="bashcommand">e</font> (<font class="bashcommand">E</font>) whichever gives full precision in minimum space.</p>
							<p><font class="bashcommand">
							$ printf "%g\n%g\n" 238.567 0.000001<br> 
							<font class="bashcommand-result">
							238.567<br> 
							1e-06 
							</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">o</font></td>
						<td> 
							<p>The argument must be a positive integer. Prints the octal value of the argument. it adds zeros before the octal to achieve the number of digits specified in the precision.</p>
							<p>Given that (234)<sub>10</sub> = (352)<sub>8</sub></p>
							<p><font class="bashcommand">
							$ printf "%o\n%.4o\n" 234 234<br> 
							<font class="bashcommand-result">
							352<br> 
							0352 
							</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">s</font></td>
						<td> 
							<p>Prints the string specified in the argument. It will stop when the number of characters specified in the precision is reached or at the end of the string if the precision is not specified (or if the string has less characters than the precision).</p>
							<p><font class="bashcommand">
							$ printf "%s" "example"<br> 
							<font class="bashcommand-result">example</font>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%.3s" "example"<br> 
							<font class="bashcommand-result">exa</font>
							</font></p>
							<p><font class="bashcommand">
							$ printf "%.10s" "example"<br> 
							<font class="bashcommand-result">example</font> 
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">u</font></td>
						<td> 
							<p>The argument must be a positive integer. If no precision is specified, it just prints the number, otherwise it adds zeros before the integer to achieve the number of digits specified in the precision.</p>
							<p><font class="bashcommand">
							$ printf "%u\n%.5u\n" 2 2<br> 
							<font class="bashcommand-result">
							2<br> 
							00002
							</font>
							</font></p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">x</font> or <font class="bashcommand">X</font></td>
						<td> 
							<p>The argument should be a positive integer. Prints the hexadecimal value of the argument. If any precision is specified, it adds zeros before the hexadecimal to achieve the number of digits specified in the precision.</p>
							<p>Given that (234)<sub>10</sub> = (EA)<sub>16</sub></p>
							<p><font class="bashcommand">
							$ printf "%x\n%X\n%.4x\n" 234 234 234<br>
							<font class="bashcommand-result">
							ea<br>
							EA<br>
							00ea 
							</font>
							</font></p>
						</td>
					</tr>
				</table>

				<p>You can save the output of <font class="bashcommand">printf</font> into a variable instead of printing it. For example, if you have a number in scientific notation and you want to convert it to floating, you can type the following:</p>
			
				<p><font class="bashcommand">
				$ FLOAT=$(printf "%f" 2.345670e+02)<br>
				$ echo $FLOAT<br>
				<font class="bashcommand-result">234.567000</font> 
				</font></p>

			<h3>9.2. Reading files</h3>
		    		<p>
				<font class="example">Read line by line using the for loop and the cat command</font>
				The <font class="bashcommand">cat</font> command, followed by the path of a file, can be used to visualize the content of the file in the command line:
				</p>

				<p><font class="bashcommand">
				$ cat /Volumes/MylDrive/MRIdata/subjectList.txt<br>
				<font class="bashcommand-result">
				AA0083277<br> 
				AA0084999<br> 
				AC0208933<br> 
				AC0148099<br> 
				AD0190300<br> 
				BB0299033<br> 
				BC0345100<br> 
				BD0365666<br> 
				CA0372599<br> 
				CA0381677<br> 
				CB0384399<br> 
				CC0384433<br> 
				DD0385444<br>
				... 
				</font>
				</font></p>

				<p>Moreover, if you want to read line by line and run a set of instructions on each line, you can combine the <font class="bashcommand">cat</font> and <font class="bashcommand">for</font> commands.</p>
		    
				<p>
				<font class="example">Read line by line the previous file</font>
				Read line by line the previous file (<font class="bashcommand">subjectList.txt</font>), which contain a list of subject IDs. And copy into a new file (<font class="bashcommand">subjectInfo.txt</font>) the subject IDs plus the group they belong to (which can be obtained from the first two letters in the subject ID). 
				</p>

				<p><font class="bashcommand">
				$ FOLDER=/Volumes/MyExternalDrive/MRIdata<br>
				$ for line in $(cat $FOLDER/subjectList.txt)<br>
				&gt; do<br>
				&gt; echo "${line:0:2},${line}" &gt;&gt; $FOLDER/subjectInfo.txt<br>
				&gt; done 
				</font></p>

				<p>In this example, I am reading one line of <font class="bashcommand">subjectList.txt</font> on every loop and assigning that line of text to the variable line (the variable could have had any other name). Then, I am extracting the first two characters in <font class="bashcommand">$line</font> (which represent the subject group) and saving that information, together with the subject ID, into a new file (<font class="bashcommand">subjectInfo.txt</font>). I am using <font class="bashcommand">${line:0:2}</font> to extract the first two characters of <font class="bashcommand">$line</font>. If I now print the content of the new file, this is what it will contain:</p>
		    
				<p><font class="bashcommand">
				$ cat /Volumes/MyExternalDrive/MRIdata/subjectInfo.txt  
				<font class="bashcommand-result">
				AA,AA0083277<br> 
				AA,AA0084999<br>
				AC,AC0208933<br>
				AC,AC0148099<br>
				AD,AD0190300<br>
				BB,BB0299033<br>
				BC,BC0345100<br>
				BD,BD0365666<br>
				CA,CA0372599<br>
				CA,CA0381677<br>
				CB,CB0384399<br>
				CC,CC0384433<br>
				DD,DD0385444 
				</font>
				</font></p>

				<p>
					<font class="example">Do statistics on the numerical values of a column from a text file</font>
					infoFile.txt is a file that contains some information from a list of subjects. This is the content of the file: 
				</p>
					<table class="ghostTable">
						<tr>
							<td>SubjectID</td>
							<td>Group</td>
							<td>Gender</td>
							<td>Ethnicity</td>
							<td>Handedness</td>
							<td>Age</td>
							<td>Movement</td>
						</tr>
						
						<tr>
							<td>AA0083277</td>
							<td>Control</td>
							<td>M</td>
							<td>Hispanic</td>
							<td>R</td>
							<td>20</td>
							<td>0.23525</td>
						</tr>
						
						<tr>
							<td>AA0084999</td>
							<td>Patient</td>
							<td>M</td>
							<td>Hispanic</td>
							<td>R</td>
							<td>18</td>
							<td>0.14564</td>
						</tr>
						
						<tr>
							<td>AC0208933</td>
							<td>Control</td>
							<td>F</td>
							<td>Hispanic</td>
							<td>R</td>
							<td>17</td>
							<td>0.18698</td>
						</tr>
						
						<tr>
							<td>AC0148099</td>
							<td>Control</td>
							<td>M</td>
							<td>NonHispanic</td>
							<td>R</td>
							<td>21</td>
							<td>0.19789</td>
						</tr>
						
						<tr>
							<td>AD0190300</td>
							<td>Patient</td>
							<td>M</td>
							<td>NonHispanic</td>
							<td>R</td>
							<td>16</td>
							<td>0.23454</td>
						</tr>
						
						<tr>
							<td>BB0299033</td>
							<td>Control</td>
							<td>F</td>
							<td>NonHispanic</td>
							<td>R</td>
							<td>22</td>
							<td>0.19752</td>
						</tr>
						
						<tr>
							<td>BC0345100</td>
							<td>Control</td>
							<td>M</td>
							<td>NonHispanic</td>
							<td>R</td>
							<td>19</td>
							<td>0.18789</td>
						</tr>
						
						<tr>
							<td>BD0365666</td>
							<td>Patient</td>
							<td>F</td>
							<td>NonHispanic</td>
							<td>R</td>
							<td>17</td>
							<td>0.14386</td>
						</tr>
						
						<tr>
							<td>CA0372599</td>
							<td>Patient</td>
							<td>F</td>
							<td>NonHispanic</td>
							<td>R</td>
							<td>20</td>
							<td>0.12384</td>
						</tr>
						
						<tr>
							<td>CA0381677</td>
							<td>Control</td>
							<td>F</td>
							<td>NonHispanic</td>
							<td>L</td>
							<td>17</td>
							<td>0.13453</td>
						</tr>
						
						<tr>
							<td>CB0384399</td>
							<td>Control</td>
							<td>F</td>
							<td>Hispanic</td>
							<td>R</td>
							<td>18</td>
							<td>0.45655</td>
						</tr>
						
						<tr>
							<td>CC0384433</td>
							<td>Control</td>
							<td>M</td>
							<td>NonHispanic</td>
							<td>R</td>
							<td>15</td>
							<td>0.13465</td>
						</tr>
						
						<tr>
							<td>DD0385444</td>
							<td>Patient</td>
							<td>M</td>
							<td>Hispanic</td>
							<td>R</td>
							<td>16</td>
							<td>0.32433</td>
						</tr>
					</table>

				<p>In this example we will calculate the minimum, maximum and average movement in the MRI scanner for the subjects in each group and gender. These values should be shown with only three decimals. There are many ways to do that, some of them a lot more efficient than the one presented here, using functions that we have not learn yet. We will use in this case the cat command to read from the file, the <font class="bashcommand">for</font> loop, and some non-integer and array operations that have been learned from previous chapters.</p>
		    
				<p>The <font class="bashcommand">for</font> will read in each loop one line of the csv file and extract the gender, group and movement values from each line. Depending the group and gender, it will add the movement to one of the following arrays:</p>

				<p>
				CM: to save the movement of all male controls.<br>
				CF: to save the movement of all female controls.<br>
				PM: to save the movement of all male patients.<br>
				PF: to save the movement of all female patients. 
				</p>

				<p>In bash it is not necessary to initialize an array. Instead, you can start adding values and the first time you add a value to a non-existent array, it will be automatically initialized. When you ask bash the size of an array that hasn’t been initialized, it will return the value zero.</p>

				<p>These are the steps to follow in order to calculate the minimum, maximum and average movement from the file:</p>

				<dl>
				<dt>1. Create a loop that reads each line of the file (except the first one which is just a heather with column names).</dt>
				<dt>2. In each loop do the following:</dt>
					<dd>2.1. Split the line using the comma as a separator and save that in a variable called <font class="bashcommand">ARRAY</font>.</dd>
					<dd>2.2. Obtain the subject group, which is located in the 2<sup>nd</sup> column (position 1 of the array). Remember, bash arrays start in the position 0 (not the position 1).</dd>
					<dd>2.3. Obtain the subject gender, which is located in the 3<sup>rd</sup> column (position 2 of the array).</dd>
					<dd>2.4. Obtain the subject movement, which is located in the 7<sup>th</sup> column (position 6 of the array).</dd>
					<dd>
						<p style="margin-left: 40px">
						&bull; If group equals "Control" and gender equals "M" (Male):<br>
						Add the movement at the end of the array CM. If CM has zero values, the new item should be added to the position 0, if CM has one value, the new item should be added to the position 1 (because the existent item in the array will be in the position 0), and so on. So, every new item is added to the position that is equal to the current size of the array. As a reminder, the size of an array can be obtained with <font class="bashcommand">${#array[@]}</font>.
						</p>
					</dd>
					<dd>
						<p style="margin-left: 40px">
						&bull; If group equals "Control" and gender equals "F" (Female):<br>
						Add the movement at the end of the array CF.
						</p>
					</dd>
					<dd>
						<p style="margin-left: 40px">
						&bull; If group equals "Patient" and gender equals "M":<br>
						Add the movement at the end of the array PM.
						</p>
					</dd>
					<dd>
						<p style="margin-left: 40px">
						&bull; If group equals "Patient" and gender equals "F":<br>
						Add the movement at the end of the array PF. 
						</p>
					</dd>
				<dt>3. Sort the four arrays with the previously learned command: <font class="bashcommand">IFS=$'\n' sorted=($(sort <<<"${array[*]}"))</font></dt>
				<dt>4. Show the minimum, maximum and average value of each array. Use <font class="bashcommand">printf</font> instead of <font class="bashcommand">echo</font> in order to show only three decimals per number:</dt>
					<dd><u>Minimum value</u>: will be the first value in the sorted array.</dd>
					<dd><u>Maximum value</u>: will be the last value in the sorted array (in the position <font class="bashcommand">SIZE_ARRAY</font> – 1).</dd>
					<dd><u>Average value</u>: will equal to the sum of all values divided by the size of the array. As a reminder, this is the general command used to calculate the average of an array, as shown in previous chapters: <font class="bashcommand">IFS='+' avg=$(echo "scale=1;(${array[*]})/${#array[@]}"|bc)</font>.</dd>
				</dl>

				<p><font class="bashcommand">
				$ n=0<br>
				$ for line in $(cat infoFile.csv)<br>
				&gt; do<br>
				&gt; if [ $((n++)) -gt 0 ]<br>
				&gt; then<br>
				&gt; IFS=',' read -a ARRAY &lt;&lt;&lt; "${line}"<br>
				&gt; GRP=${ARRAY[1]}<br>
				&gt; GEN=${ARRAY[2]}<br>
				&gt; MOV=${ARRAY[6]}<br>
				&gt; if [ "$GRP" == "Control" ] && [ "$GEN" == "M" ]<br>
				&gt; then<br>
				&gt; CM[${#CM[@]}]=${MOV}<br>
				&gt; fi<br>
				&gt; if [ "$GRP" == "Control" ] && [ "$GEN" == "F" ]<br>
				&gt; then<br>
				&gt; CF[${#CF[@]}]=${MOV}<br>
				&gt; fi<br>
				&gt; if [ "$GRP" == "Patient" ] && [ "$GEN" == "M" ] 
				&gt; then<br>
				&gt; PM[${#PM[@]}]=${MOV}<br>
				&gt; fi<br>
				&gt; if [ "$GRP" == "Patient" ] && [ "$GEN" == "F" ]<br>
				&gt; then<br>
				&gt; PF[${#PF[@]}]=${MOV}<br>
				&gt; fi<br>
				&gt; fi<br>
				&gt; done 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedCM=($(sort &lt;&lt;&lt;"${CM[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${CM[*]})/${#CM[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedCM[0]} ${sortedCM[${#sortedCM[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedCF=($(sort &lt;&lt;&lt;"${CF[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${CF[*]})/${#CF[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedCF[0]} ${sortedCF[${#sortedCF[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedPM=($(sort &lt;&lt;&lt;"${PM[*]}"))<br> 
				$ IFS='+' avg=$(echo "scale=4;(${PM[*]})/${#PM[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedPM[0]} ${sortedPM[${#sortedPM[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedPF=($(sort &lt;&lt;&lt;"${PF[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${PF[*]})/${#PF[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedPF[0]} 
				</font></p>

				<p>The number of lines of the previous code could be reduced by simplifying the <font class="bashcommand">if</font> expressions. The code below is equivalent to the code above:</p>

				<p><font class="bashcommand">
				$ n=0<br>
				$ for line in $(cat infoFile.csv)<br>
				&gt; do<br>
				&gt; if [ $((n++)) -gt 0 ]<br>
				&gt; then<br>
				&gt; IFS=',' read -a ARRAY &lt;&lt;&lt; "${line}"<br>
				&gt; GRP=${ARRAY[1]}<br>
				&gt; GEN=${ARRAY[2]}<br>
				&gt; MOV=${ARRAY[6]}<br>
				&gt; [ "$GRP" == "Control" ] && [ "$GEN" == "M" ] && CM[${#CM[@]}]=${MOV}<br>
				&gt; [ "$GRP" == "Control" ] && [ "$GEN" == "F" ] && CF[${#CF[@]}]=${MOV}<br>
				&gt; [ "$GRP" == "Patient" ] && [ "$GEN" == "M" ] && PM[${#PM[@]}]=${MOV}<br>
				&gt; [ "$GRP" == "Patient" ] && [ "$GEN" == "F" ] && PF[${#PF[@]}]=${MOV}<br>
				&gt; fi<br>
				&gt; done 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedCM=($(sort &lt;&lt;&lt;"${CM[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${CM[*]})/${#CM[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedCM[0]} ${sortedCM[${#sortedCM[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedCF=($(sort &lt;&lt;&lt;"${CF[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${CF[*]})/${#CF[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedCF[0]} ${sortedCF[${#sortedCF[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedPM=($(sort &lt;&lt;&lt;"${PM[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${PM[*]})/${#PM[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedPM[0]} ${sortedPM[${#sortedPM[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedPF=($(sort &lt;&lt;&lt;"${PF[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${PF[*]})/${#PF[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedPF[0]} 
				</font></p>

				<p>You could reduce even more the number of lines in the code:</p>

				<p><font class="bashcommand">
				$ n=0<br>
				$ for line in $(cat infoFile.csv)<br>
				&gt; do<br>
				&gt; if [ $((n++)) -gt 0 ]<br>
				&gt; then<br>
				&gt; IFS=',' read -a ARRAY &lt;&lt;&lt; "${line}"<br>
				&gt; [ "${ARRAY[1]}" == "Control" ] && [ "${ARRAY[2]}" == "M" ] && CM[${#CM[@]}]=${ARRAY[6]}<br>
				&gt; [ "${ARRAY[1]}" == "Control" ] && [ "${ARRAY[2]}" == "F" ] && CF[${#CF[@]}]=${ARRAY[6]}<br>
				&gt; [ "${ARRAY[1]}" == "Patient" ] && [ "${ARRAY[2]}" == "M" ] && PM[${#PM[@]}]=${ARRAY[6]}<br>
				&gt; [ "${ARRAY[1]}" == "Patient" ] && [ "${ARRAY[2]}" == "F" ] && PF[${#PF[@]}]=${ARRAY[6]}<br>
				&gt; fi<br>
				&gt; done 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedCM=($(sort &lt;&lt;&lt;"${CM[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${CM[*]})/${#CM[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedCM[0]} ${sortedCM[${#sortedCM[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedCF=($(sort &lt;&lt;&lt;"${CF[*]}"))<br> 
				$ IFS='+' avg=$(echo "scale=4;(${CF[*]})/${#CF[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedCF[0]} ${sortedCF[${#sortedCF[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedPM=($(sort &lt;&lt;&lt;"${PM[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${PM[*]})/${#PM[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedPM[0]} ${sortedPM[${#sortedPM[@]} -1]} $avg 
				</font></p>

				<p><font class="bashcommand">
				$ IFS=$'\n' sortedPF=($(sort &lt;&lt;&lt;"${PF[*]}"))<br>
				$ IFS='+' avg=$(echo "scale=4;(${PF[*]})/${#PF[@]}"|bc)<br>
				$ printf "Male Controls:\nMin: %.3f\nMax: %.3f\nAve: %.3f\n" ${sortedPF[0]} 
				</font></p>

				<p>In the previous example we read line by line a file using a for loop and the cat utility. This works most of the times. However, if you try to read this way a file in which one or more of the lines contain a space, bash will read each word separated by a space as a separate line.</p>

				<p>
				For example, if file test.txt has the following content:<br>
				a b<br>
				c d<br>
				e f<br>
				g h<br>
				i j 
				</p>

				<p>When you try to read each line using a file, this is the result you will get:</p>

				<p><font class="bashcommand">
				$ for line in $(cat test.txt)<br>
				&gt; do<br>
				&gt; echo $((i++)) $line<br>
				&gt; done<br>
				<font class="bashcommand-result">
				0 a<br>
				1 b<br>
				2 c<br>
				3 d<br>
				4 e<br>
				5 f<br>
				6 g<br>
				7 h<br>
				8 i<br>
				9 j 
				</font>
				</font></p>

				<p>To fix this problem you have to tell bash that newline (<font class="bashcommand">\n</font>) is the only separator. You do this by declaring the system variable <font class="bashcommand">IFS=$'\n'</font>.</p>

				<p><font class="bashcommand">
				$ IFS=$'\n'<br>
				$ for line in $(cat test.txt)<br>
				&gt; do<br>
				&gt; echo $((i++)) $line<br>
				&gt; done<br>
				<font class="bashcommand-result">
				0 a b<br>
				1 c d<br>
				2 e f<br>
				3 g h<br>
				4 i j 
				</font>
				</font></p>
			    
			    	<p>
				<font class="example">Load the content of a file into an array and access a specific line separately</font>
				<font class="bashcommand">
				$ ARRAY=($(cat test.txt))<br>
				$ echo ${ARRAY[0]}<br>
				<font class="bashcommand-result">a b</font><br>
				$ echo ${ARRAY[1]}<br>
				<font class="bashcommand-result">c d</font><br>
				$ echo ${ARRAY[2]}<br>
				<font class="bashcommand-result">e f</font><br>
				$ echo ${ARRAY[3]}<br>
				<font class="bashcommand-result">g h</font><br>
				$ echo ${ARRAY[4]}<br>
				<font class="bashcommand-result">i j</font>
				</font>
			    	</p>
			    
			<h3>9.3. Using the read command for more complex csv files</h3>
			    	<p>So far, we have learned that using the <font class="bashcommand">for</font> loop and the cat utility you can read each line of a file and separate it into different fields using a separator. However, csv files can become very difficult to separate into fields if some of them contain a comma (the same character that is being used as a separator), a space, or both. </p>
			    
			    	<p>
				<font class="example">Example: Obtain the last field of <font class="bashcommand">$line</font> using the concepts learned before.</font>
				<font class="bashcommand">
				$ line="SUBJ20"," Age 22-30","VISIT1","1","DIAGN: Major Depressive Disorder, Single Episode, In Full Remission"<br>
				$ IFS=',' read -a ARRAY &gt;&gt;&gt; "$line"<br>
				$ echo "The last field of line is: "${ARRAY[4]}<br>
				<font class="bashcommand-result">The last field of line is: DIAGN: Major Depressive Disorder</font>
				</font>
			    	</p>
			    
			    	<p>However, this is not the correct result. The last field of <font class="bashcommand">$line</font> is <font class="bashcommand">"DIAGN: Major Depressive Disorder, Single Episode, In Full Remission"</font>. But because we are using a comma as a separator, bash is separating this field into separate columns. To solve this problem, you can read from the file descriptor and save each field in a separate variable using the <font class="bashcommand">read</font> utility.</p>
			    
			    	<p>
				The first step is to assign a file descriptor (which must be an integer number) to the input file:<br>
				<font class="bashcommand">$ exec 3&lt; $INPUT_FILE</font>
				</p>
			    
			    	<p>
				Then, to read each line of the file and save each field in a different variable:<br>
				<font class="bashcommand">$ read -u 3 a b</font>
			    	</p>
			    
			    	<p>
				The previous command will read the next line of the input file with descriptor 3 (the number following flag <font class="bashcommand">-u</font>) and save the first field in variable a and the rest of the line in variable <font class="bashcommand">b</font>.<br>
				<font class="bashcommand">$ read -u 3 a b c</font>
			    	</p>
			    
			    	<p>
				The previous command will read the next line of the input file with descriptor 3 and save the first field in variable <font class="bashcommand">a</font>, the second field in variable <font class="bashcommand">b</font>, and the rest of the line in variable <font class="bashcommand">c</font> (variable <font class="bashcommand">c</font> would be empty if there are no more fields to read). If you want to separate the fields using comma as a separator, you should use the following command instead:<br>
				<font class="bashcommand">$ IFS=',' read -u 3 a b c d</font>
			    	</p>
			    
			    	<p>
				If one of the columns contains a comma but is surrounded by quotation marks, then it will read the text inside the quotation marks as a single field. In the example before, it will read the following text as the last field: <font class="bashcommand">$ "DIAGN: Major Depressive Disorder, Single Episode, In Full Remission"</font>.<br>
				Each time you type the command <font class="bashcommand">$ FS=',' read -u 3 a b c d</font> it will read the following line. 
			    	</p>
			    
			    	<p>
				<font class="example">Read each line of a file and save the first and last fields into a new file</font>
				Given the file example.csv with the following content:<br>
				"SUBJ1","Age 22-30","VISIT1","DIAGN: Major Depressive Disorder, Single Episode"<br>
				"SUBJ2","Age 22-30","VISIT1","DIAGN: Bipolar, Schizophrenia"<br>
				"SUBJ3","Age 22-30","VISIT1","DIAGN: Major Depressive Disorder"<br>
				"SUBJ4","Age 22-30","VISIT1","DIAGN: Autism, Dyslexia, ADHD"<br>
				Read each line of the file and save the first and last fields into a new file called result.csv. 
			    	</p>
			    
			    	<p>
				<ol>
					<li>
					Assign the file descriptor 3 to example.csv for input<br>
					<font class="bashcommand">$ exec 3&lt; example.csv</font>
					</li>
					
					<li>
					Obtain the number of lines in the input file.<br>
					<font class="bashcommand">
					$ N=$(cat example.csv | wc -l)<br>
					$ echo $N 
					</font>
					</li>
					
					<li>
					Iterate through all the lines of the file saving each field in a different variable. Then, write the value of the first and last fields into the output file.<br> 
					<font class="bashcommand">
					$ i=0<br>
					$ while [ $((i++)) -lt $N ]<br> 
					&gt; do<br> 
					&gt; IFS=',' read -u 3 f1 f2 f3 f4<br> 
					&gt; echo  "$f1,$f4" &gt;&gt; result.csv<br> 
					&gt; done 
					</font>
					</li>
					
					<li>
					You must close the file descriptor using the following command (replace number 3 by the corresponding file descriptor):<br> 
					<font class="bashcommand">
					$ exec 3&lt;&- 
					</font>
					</li>
					
					<li>
					Read the content of the output file.<br> 
					<font class="bashcommand">
					$ cat result.csv<br> 
					<font class="bashcommand-result">
					"SUBJ1","Age 22-30","VISIT1","DIAGN: Major Depressive Disorder, Single Episode"<br> 
					"SUBJ2","Age 22-30","VISIT1","DIAGN: Bipolar, Schizophrenia"<br> 
					"SUBJ3","Age 22-30","VISIT1","DIAGN: Major Depressive Disorder"<br> 
					"SUBJ4","Age 22-30","VISIT1","DIAGN: Autism, Dyslexia, ADHD" 
					</font>
					</font>
					</li>
			    	</ol>
			    	</p>

			<h3>9.4 Reading comma-separated CSV files using the read utility but no file descriptor</h3>

			<p>In the following example we are going to read a csv file called example.csv. The file has five columns (five fields per line). We are going to use the <font class="bashcommand">while</font> loop to iterate through each line of the csv file and save the fields in variables <font class="bashcommand">f1</font>, <font class="bashcommand">f2</font>, <font class="bashcommand">f3</font>, <font class="bashcommand">f4</font>. Before starting to iterate, we have to tell bash that comma (<font class="bashcommand">,</font>) will be the separator in each line: <font class="bashcommand">IFS=','</font>.</p>

			<p><font class="bashcommand">
			$ IFS=','<br> 
				$ i=1<br>
				$ while read f1 f2 f3 f4<br> 
				&gt; do<br>  
				&gt; echo "Line $((i++)):"<br> 
				&gt; echo "Field 1: $f1"<br> 
				&gt; echo "Field 2: $f2"<br> 
				&gt; echo "Field 3: $f3"<br> 
				&gt; echo "Field 4: $f4"<br> 
				&gt; done &lt; example.csv<br> 
				<font class="bashcommand-result">
				Line 1:<br> 
				Field 1: "SUBJ1"<br> 
				Field 2: "Age 22-30"<br> 
				Field 3: "VISIT1"<br> 
				Field 4: "DIAGN: Major Depressive Disorder, Single Episode"<br> 
				Line 2:<br> 
				Field 1: "SUBJ2"<br> 
				Field 2: "Age 22-30"<br> 
				Field 3: "VISIT1"<br> 
				Field 4: "DIAGN: Bipolar, Schizophrenia"<br> 
				Line 3:<br> 
				Field 1: "SUBJ3"<br> 
				Field 2: "Age 22-30"<br> 
				Field 3: "VISIT1"<br> 
				Field 4: "DIAGN: Major Depressive Disorder"<br> 
				Line 4:<br> 
				Field 1: "SUBJ4"<br> 
				Field 2: "Age 22-30"<br> 
				Field 3: "VISIT1"<br> 
				Field 4: "DIAGN: Autism, Dyslexia, ADHD" 
				</font>
		    		</font></p>

		    	<h3>9.5. The awk command</h3>
		    		<p><font class="bashcommand">awk</font> is a bash program that scans files and process their content using patterns. It reads each line of a file or a group of files searching for the specified pattern and each time that it finds the pattern, it performs an associated action. This tool can extract specific lines or columns from files, merge files, search the content of one file in the other, etc.</p>
		    		
				<p>When reading each line of the specified files, <font class="bashcommand">awk</font> will separate it into fields (columns) using the blank space as a separator. If your file uses a different separator (i.e. a comma). Then you must specify your separator using the <font class="bashcommand">-F</font> flag (see syntax below). The different fields will be denoted <font class="bashcommand">$1</font>, <font class="bashcommand">$2</font>, <font class="bashcommand">$3</font>... etc. <font class="bashcommand">$0</font> will refer to the entire line. If the field separator (<font class="bashcommand">FS</font>) is null, each line will be split into one field per character.</p>

				<p>Syntax: <font class="bashcommand">awk [ -F fs ] [ -v var=value ] [ 'pattern {action}' ] [ files ] | [ other functions ]</font></p>

				<table>
					<tr>
						<th>Flag</th>
						<th>Meaning</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-F fs (optional)</font></td>
						<td>Defines the input field separator to be the regular expression <font class="bashcommand">fs</font>. Use this flag when the columns of your file use a separator other than a space. See examples below.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-v var=variableName (optional)</font></td>
						<td>When the value that is being search is stored in a variable, you should use this flag. See below for examples on how to use this flag.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">files</font></td>
						<td>List of files to be searched.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">other functions</font> (optional)</td>
						<td>You can apply to the output of <font class="bashcommand">awk</font> other functions such as <font class="bashcommand">head</font>, <font class="bashcommand">tail</font>, <font class="bashcommand">paste</font>, <font class="bashcommand">grep</font>, etc (some of them explained below and in the examples section)</td>
					</tr>
				</table>

		    	<h3>9.6. The grep command</h3>
		    		<p>Searches a given pattern or text in a file or list of files. <font class="bashcommand">grep</font> is is able to find simple patterns and basic regular expressions, <font class="bashcommand">egrep</font> can perform search of extended regular expressions. <font class="bashcommand">fgrep</font> is quicker than both tools but can only handle fixed patterns. <font class="bashcommand">zgrep</font>, <font class="bashcommand">zegrep</font>, and <font class="bashcommand">zfgrep</font> act like <font class="bashcommand">grep</font>, <font class="bashcommand">egrep</font>, and <font class="bashcommand">fgrep</font>, respectively, but accept compressed files as input.</p>
		    
				<p>Syntax: <font class="bashcommand">grep [flag] [pattern] [file(s)]</font></p>

				<p>
				<table>
					<tr>
						<th>grep format</th>
						<th>meaning</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep string files</font></td>
						<td>Searches the list of <font class="bashcommand">files</font> for lines that <u>contain</u> <font class="bashcommand">string</font>. See examples here.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep '^expression' files</font></td>
						<td> 
							<p>Search for any lines that <u>start with</u> <font class="bashcommand">expression</font> in the list of <font class="bashcommand">files</font>. If <font class="bashcommand">expression</font> contains a back slash (<font class="bashcommand">\</font>), the special meaning of the next special character is turned off. If <font class="bashcommand">expression</font> contains a dot (<font class="bashcommand">.</font>) that is not preceded by a black slash, it will match a single character of any value in the position of the dot.</p>
							
							<p>e.i. <font class="bashcommand">grep '^string' file.txt</font> will search for any lines in <font class="bashcommand">file.txt</font> that start with <font class="bashcommand">string</font>. See more examples here.</p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep 'expression$' files</font></td>
						<td> 
							<p>Search for any lines that <u>end with</u> <font class="bashcommand">expression</font> in the list of <font class="bashcommand">files</font>. If <font class="bashcommand">expression</font> contains a back slash (<font class="bashcommand">\</font>), the special meaning of the next special character is turned off. If <font class="bashcommand">expression</font> contains a dot (<font class="bashcommand">.</font>) that is not preceded by a black slash, it will match a single character of any value in the position of the dot.</p>
							
							<p>
							Examples:<br>
							<font class="bashcommand">grep 'string$' file</font> matches any lines in <font class="bashcommand">file</font> that end with <font class="bashcommand">string</font>. See more examples here. 
							</p>
							
							<p><font class="bashcommand">grep '^string$' files</font> matches any lines in <font class="bashcommand">file</font> that start and end with <font class="bashcommand">string</font> (lines containing only string).</p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep '[characters]' files</font></td>
						<td> 
							<p>Search for any lines that contain any of the characters enclosed between the brackets. Use a hyphen for a range of values.</p>
							
							<p>
							Examples:<br> 
							<font class="bashcommand">grep '[abcde]' files</font> matches any lines in <font class="bashcommand">file</font> that contain <font class="bashcommand">a</font>, <font class="bashcommand">b</font>, <font class="bashcommand">c</font>, <font class="bashcommand">d</font> or <font class="bashcommand">e</font>. 
							</p>
							
							<p><font class="bashcommand">grep '[Ss]tring' file</font> matches any lines in <font class="bashcommand">file</font> that contain the words <font class="bashcommand"><u>s</u>tring</font> or <font class="bashcommand"><u>S</u>tring</font>.</p>
							
							<p><font class="bashcommand">grep 'B[ai][dt]' file</font> matches any <font class="bashcommand">lines</font> in <font class="bashcommand">file</font> that contain the words <font class="bashcommand">Bad</font>, <font class="bashcommand">Bat</font>, <font class="bashcommand">Bid</font> or <font class="bashcommand">Bit</font> (the second character can be <font class="bashcommand">a</font> or <font class="bashcommand">i</font> and the third character <font class="bashcommand">d</font> or <font class="bashcommand">t</font>).</p>
							
							<p><font class="bashcommand">grep '[0-9][0-9]' file</font> matches any lines in <font class="bashcommand">file</font> that contain a pair of numeric digits.</p>
							
							<p><font class="bashcommand">grep '[a-zA-Z]' file</font> matches any lines in <font class="bashcommand">file</font> with at least one letter.</p>
							
							<p><font class="bashcommand">grep '^$' file</font> matches any empty lines.</p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep '[^characters]' files</font></td>
						<td> 
							<p>Search for any lines that <u>don't contain</u> any of the characters enclosed between he brackets. Use a hyphen for a range of values.</p>		
							<p>e.i. <font class="bashcommand">grep '[^a-zA-Z0-9]' file</font> matches any lines in file that don't contain any letter or number (any lines that contain only special characters).</p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep 'character*' files</font></td>
						<td> 
							<p>The character preceding the asterisk is optional when matching lines.</p>
							<p>e.i. <font class="bashcommand">grep '"*smug"*' file</font> matches any lines in file that contain <font class="bashcommand">smug</font> or <font class="bashcommand">"smug"</font> (with or without the quotes that precede the asterisks).</p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep 'expression\{n\}' files</font></td>
						<td> 
							<p>Match exactly <font class="bashcommand">n</font> occurrences of <font class="bashcommand">expression</font>.</p>
							<p>e.i. <font class="bashcommand">grep '[0-9]\{3\}-[0-9]\{4\}' file</font> matches any lines in <font class="bashcommand">file</font> that contain three digits, followed by a line and four digits.</p>
						</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">grep 'expression \{n,\}' files</font></td>
						<td> 
							<p>Matches n or more occurrences of <font class="bashcommand">expression</font>.</p>
							<p>e.i. <font class="bashcommand">grep '[0-9]\{3,\}' file</font> matches any lines in <font class="bashcommand">file</font> that contain three or more digits.</p>
						</td>
					</tr>
				</table>
				</p>

				<p>
				<table>
					<tr>
						<th>Flag</th>
						<th>Meaning</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-A num</font></td>
						<td>Print <font class="bashcommand">num</font> lines of trailing context after each match. See here for an example.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-B num</font></td>
						<td>Print <font class="bashcommand">num</font> lines of leading context before each match. See here for an example.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-C num</font></td>
						<td>Print <font class="bashcommand">num</font> lines of leading and trailing context surrounding each match. If <font class="bashcommand">num</font> is not specified, <font class="bashcommand">num=2</font>. See here for an example.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-c</font></td>
						<td>Print the number of matched lines per file instead of the actual lines.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--colour=when</font></td>
						<td>Mark up the matching text with the expression stored in <font class="bashcommand">GREP_COLOR</font> environment variable. The possible values of when can be: <font class="bashcommand">never</font>, <font class="bashcommand">always</font> or <font class="bashcommand">auto</font>.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-d action</font></td>
						<td>Specify the demanded action for directories. The possible values of action are: <font class="bashcommand">read</font> (default), which means that the directories are read in the same manner as normal files; <font class="bashcommand">skip</font> to silently ignore the directories, and <font class="bashcommand">recourse</font> to read them recursively, which has the same effect as the <font class="bashcommand">-R</font> and <font class="bashcommand">-r</font> option.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-e pattern</font></td>
						<td>To search for more than one pattern/expression, add the flag <font class="bashcommand">-e</font> in front of each expression.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--exclude</font></td>
						<td>If specified, it excludes files matching the given filename pattern from the search. Note that <font class="bashcommand">--exclude</font> patterns take priority over <font class="bashcommand">--include</font> patterns. Patterns are matched to the full path specified, not only to the filename component.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--exclude-dir filename_pattern</font></td>
						<td>If <font class="bashcommand">-R</font> is specified, it excludes directories matching the given <font class="bashcommand">filename_pattern</font> from the search.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-f file</font></td>
						<td>Read one or more newline separated patterns from <font class="bashcommand">file</font>. Empty pattern lines match every input line. Newlines are not considered part of a pattern. If <font class="bashcommand">file</font> is empty, nothing is matched.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-h</font></td>
						<td>Omit the filename headers with output lines.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--help</font></td>
						<td>Print a brief help message.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--include</font></td>
						<td>If specified, only files matching the given filename pattern are searched. Note that <font class="bashcommand">--exclude</font> patterns take priority over <font class="bashcommand">--include</font> patterns. Patterns are matched to the full path specified, not only to the filename component.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--include-dir filename_pattern</font></td>
						<td>If <font class="bashcommand">-R</font> is specified, only directories matching the given <font class="bashcommand">filename_pattern</font> are searched. Note that <font class="bashcommand">--exclude-dir</font> patterns take priority over <font class="bashcommand">--include-dir</font> patterns.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-L</font></td>
						<td>Only the names of files not containing selected lines are listed.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-l</font></td>
						<td>Only the names of files containing selected lines are listed.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-m num</font></td>
						<td>Stop reading the file after <font class="bashcommand">num</font> matches.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-n</font></td>
						<td>Each output line is preceded by its relative line number in the file, <u>starting at line 1</u>. The line number counter is reset for each file processed. This option is ignored if <font class="bashcommand">-c</font>, <font class="bashcommand">-L</font>, <font class="bashcommand">-l</font>, or <font class="bashcommand">-q</font> is specified.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--null</font></td>
						<td>Prints a zero-byte after the file name.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-O</font></td>
						<td>If <font class="bashcommand">-R</font> is specified, follow symbolic links only if they were explicitly listed on the command line. The default is not to follow symbolic links.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-o</font></td>
						<td>Prints only the matching part of the lines.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-q</font></td>
						<td>Suppress normal output.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-R</font> or <font class="bashcommand">-r</font></td>
						<td>Recursively search subdirectories listed.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-S</font></td>
						<td>If <font class="bashcommand">-R</font> is specified, all symbolic links are followed. The default is not to follow symbolic links.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-s</font></td>
						<td>Suppress error messages from nonexistent or unreadable files.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-V</font></td>
						<td>Display version information and exit.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-v</font></td>
						<td>Selected lines are those <u>not</u> matching any of the specified patterns.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-w</font></td>
						<td>The expression is searched for as a whole word.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-x</font></td>
						<td>Show only the cases where the whole line equals the expression.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">-Z</font> or <font class="bashcommand">-z</font></td>
						<td>Accepts compressed input files.</td>
					</tr>
					
					<tr>
						<td><font class="bashcommand">--line-buffered</font></td>
						<td>Force output to be line buffered. By default, output is line buffered when standard output is a terminal and block buffered otherwise.</td>
					</tr>
				</table>
				</p>

				<p>The following examples will show how to read and manipulate files using different command line tools. Each example will read one or more of the following files. file1.csv and file3.csv use comma as the separator between columns. On the other hand, file2.txt and file file4.txt use a space as the separator between columns.</p>

				<p>
				Content of file1.csv:<br>
				"Anonymized ID","Subject Group","HASCONDITION","CONDITION"<br>
				"B33199522","Group1","0",""<br>
				"B33199603","Group3","0",""<br>
				"B11137879","Group1","0",""<br>
				"B11144410","Group2 b","0",""<br>
				"B11110455","Group2 b","0",""<br>
				"B11135291","Group3","0",""<br>
				"B11153927","Group1","0",""<br>
				"B11177579","Group2 b","0",""<br>
				"B11177806","Group1","MD",""<br>
				"B11157958","Group3","0",""<br>
				"B11110690","Group3","0",""<br>
				"B11152799","Group1","0",""<br>
				"B11154358","Group1","0",""<br>
				"B11110925","Group1","0",""<br>
				"B11135291","Group3","9","mTBI"<br> 
				"B11135072","MISSING","0",""<br>
				"B33199603","Group3","0",""<br>
				"B11137879","Group1","0",""<br>
				"B11110603","Group1","0",""<br>
				"B11110927","Group1","0",""<br>
				"B11147712","Group1","0",""<br>
				"B33191224","Group2 b","0",""<br>
				"B11131290","Group2 b","0",""<br>
				"B11157974","Group1","0",""<br>
				"B33191224","Group2 b","0",""<br>
				"B11141503","Group3","0",""<br>
				"C11137159","Group3","9","mTBI"<br> 
				"B33199522","Group1","0","" 
				</p>

				<p>
				Content of file2.txt:<br> 
				"AnonymizedID" "SubjectGroup" "TEST1" "TEST2"<br> 
				"B11130912" "Group2b" "900" "MissingData"<br> 
				"B11137244" "Group1" "450" "555"<br> 
				"B11154534" "Group1" "456" "456"<br> 
				"B11144100" "Group1" "450" "886"<br> 
				"B11137244" "Group1" "450" "456"<br> 
				"B12226566" "Group2b" "450" "MissingData"<br> 
				"B11134987" "Group1" "900" "MissingData"<br> 
				"B11144345" "Group1" "900" "776"<br> 
				"C11137159" "Group3" "MissingData" "MissingData"<br> 
				"B11156453" "Group4" "456" "2"<br> 
				"B11110676" "Group1" "900" "10"<br> 
				"C11138929" "Group2b" "2" "MissingData"<br> 
				"B11154532" "Group1" "456" "886"<br> 
				"B11155267" "Group3" "900" "10"<br> 
				"B11137120" "Group2b" "450" "456"<br> 
				"B33191224" "Group2b" "450" "776"<br> 
				"B11155267" "Group3" "900" "10"<br> 
				"C11138999" "Group2b" "900" "MissingData"<br> 
				"B11131605" "Group1" "456" "MissingData"<br> 
				"B11137784" "Group1" "900" "436"<br> 
				"B11156098" "Group1" "500" "886"<br> 
				"B11133232" "Group1" "500" "MissingData"<br> 
				"B11135292" "Group3" "MissingData" "MissingData"<br> 
				"C11138912" "Group2b" "900" "MissingData"<br> 
				"B11150911" "Group2b" "900" "117"<br> 
				"B11152577" "Group1" "900" "756"<br> 
				"B11156098" "Group1" "456" "886"<br> 
				"B11133232" "Group1" "456" "MissingData" 
				</p>

				<p>
				Content of file3.csv:<br> 
				Anonymized ID,Subject Group,AGE<br> 
				C11138122,MISSING,21<br> 
				C11138192,Group1,54<br> 
				B12226507,Group1,68<br> 
				B12226546,Group1,67<br> 
				C11138122,Group1,24<br> 
				C11138184,Group1,59<br> 
				C11138797,Group1,22<br> 
				C11138152,Group1,53<br> 
				C11138150,Group1,41<br> 
				C11137167,Group3,14<br> 
				C11137159,Group3,13<br> 
				C11137167,Group3,16<br> 
				C11137159,Group3,13<br> 
				C11131039,Group2 b,67<br> 
				C11135566,Group2 b,73<br> 
				B11119903,Group2 b,83<br> 
				C11137544,Group1,21<br> 
				C11137443,Group3,11<br> 
				C11137123,Group2 b,69<br> 
				C11137439,Group3,79<br> 
				C11137439,Group3,15<br> 
				C11133100,Group1,23<br> 
				D11144030,Group3,13<br> 
				B11108399,Group1,23<br> 
				B11108326,Group1,59<br> 
				B11119909,Group2 b,61<br> 
				B11110893,Group1,28
				</p>

				<p>
				Content of file4.txt:<br>
				AnonymizedID SubjectGroup AGE<br> 
				B11108326 Group1 59<br> 
				B11108399 Group1 23<br> 
				B11110893 Group1 28<br> 
				B11119909 Group2 61<br> 
				D11144030 Group3 11<br> 
				D11144030 Group3 13<br> 
				B11119903 Group2 84<br> 
				C11131039 Group2 67<br> 
				C11133100 Group1 23<br> 
				C11135566 Group2 72<br> 
				C11137159 Group3 11<br> 
				C11137159 Group3 12<br> 
				C11137167 Group3 14<br> 
				C11137167 Group3 16<br> 
				C11137439 Group3 15<br> 
				C11137439 Group3 79<br> 
				C11137443 Group3 15<br> 
				C11137544 Group1 22<br> 
				C11137123 Group2 68<br> 
				C11138150 Group1 44<br> 
				C11138152 Group1 10<br> 
				C11138797 Group1 24<br> 
				C11138184 Group1 57<br> 
				C11138122 Group1 23<br> 
				C11138122 MISSING 25<br> 
				C11138192 Group1 45<br> 
				B12226507 Group1 26<br> 
				B12226546 Group1 55 
				</p>

			<h3>9.7. Examples: Reading specific columns from a file or a list of files</h3>
				<p>
					<font class="example">Print the first column of each file</font>
					In order to print the first column of these files, we will use <font class="bashcommand">awk</font> utility. As it was shown before, the command for this utility consists on some optional flags followed by an action statement and then the list of files. In this case the action statement is <font class="bashcommand">'{print $1}'</font>, because we want to print only the first column (<font class="bashcommand">$1</font>). Files file2.txt and file4.txt use a space as a column separator (which is the separator for default). So, to access the first column of these files we don't need the <font class="bashcommand">-F</font> flag. However, files file1.csv and file3.csv use a comma as a separator. So, in order for <font class="bashcommand">awk</font> to distinguish the different columns we have to use the <font class="bashcommand">-F</font> flag. In this case, the parameter of the <font class="bashcommand">-F</font> flag is a comma (<font class="bashcommand">-F','</font>). If you are trying to read a file which has the columns separated by a different character, then use that character instead of <font class="bashcommand">','</font>. 
				</p>

				<p>
				<table class="ghostTable">
					<tr>
						<th>Space-separated files</th>
						<th>Comma-separated files</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">$ awk '{print $1}' file2.txt</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print $1}' file1.csv</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"AnonymizedID"</font></td>
						<td><font class="bashcommand-result">"Anonymized ID"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11130912"</font></td>
						<td><font class="bashcommand-result">"B33199522"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137244"</font></td>
						<td><font class="bashcommand-result">"B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11154534"</font></td>
						<td><font class="bashcommand-result">"B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11144100"</font></td>
						<td><font class="bashcommand-result">"B11144410"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137244"</font></td>
						<td><font class="bashcommand-result">"B11110455"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B12226566"</font></td>
						<td><font class="bashcommand-result">"B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11134987"</font></td>
						<td><font class="bashcommand-result">"B11153927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11144345"</font></td>
						<td><font class="bashcommand-result">"B11177579"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11137159"</font></td>
						<td><font class="bashcommand-result">"B11177806"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11156453"</font></td>
						<td><font class="bashcommand-result">"B11157958"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11110676"</font></td>
						<td><font class="bashcommand-result">"B11110690"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11138929"</font></td>
						<td><font class="bashcommand-result">"B11152799"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11154532"</font></td>
						<td><font class="bashcommand-result">"B11154358"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11155267"</font></td>
						<td><font class="bashcommand-result">"B11110925"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137120"</font></td>
						<td><font class="bashcommand-result">"B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33191224"</font></td>
						<td><font class="bashcommand-result">"B11135072"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11155267"</font></td>
						<td><font class="bashcommand-result">"B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11138999"</font></td>
						<td><font class="bashcommand-result">"B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11131605"</font></td>
						<td><font class="bashcommand-result">"B11131605"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137784"</font></td>
						<td><font class="bashcommand-result">"B11110927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11156098"</font></td>
						<td><font class="bashcommand-result">"B11147712"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11133232"</font></td>
						<td><font class="bashcommand-result">"B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11135292"</font></td>
						<td><font class="bashcommand-result">"B11131290"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11138912"</font></td>
						<td><font class="bashcommand-result">"B11157974"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11150911"</font></td>
						<td><font class="bashcommand-result">"B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11152577"</font></td>
						<td><font class="bashcommand-result">"B11141503"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11156098"</font></td>
						<td><font class="bashcommand-result">"C11137159"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11133232"</font></td>
						<td><font class="bashcommand-result">"B33199522"</font></td>
					</tr>
				</table>
				</p>

				<p>
				<table class="ghostTable">
					<tr>
						<td><font class="bashcommand">$ awk '{print $1}' file4.txt</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print $1}' file3.csv</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">AnonymizedID</font></td>
						<td><font class="bashcommand-result">Anonymized ID</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">B11108326</font></td>
						<td><font class="bashcommand-result">C11138122</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">B11110893</font></td>
						<td><font class="bashcommand-result">C11138192</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">B11119909</font></td>
						<td><font class="bashcommand-result">B12226507</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">D11144030</font></td>
						<td><font class="bashcommand-result">B12226546</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">D11144030</font></td>
						<td><font class="bashcommand-result">C11138122</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">B11119903</font></td>
						<td><font class="bashcommand-result">C11138184</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11131039</font></td>
						<td><font class="bashcommand-result">C11138797</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11133100</font></td>
						<td><font class="bashcommand-result">C11138152</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11135566</font></td>
						<td><font class="bashcommand-result">C11138150</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137159</font></td>
						<td><font class="bashcommand-result">C11137167</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137159</font></td>
						<td><font class="bashcommand-result">C11137159</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137167</font></td>
						<td><font class="bashcommand-result">C11137167</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137167</font></td>
						<td><font class="bashcommand-result">C11137159</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137439</font></td>
						<td><font class="bashcommand-result">C11131039</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137439</font></td>
						<td><font class="bashcommand-result">C11135566</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137443</font></td>
						<td><font class="bashcommand-result">B11119903</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137544</font></td>
						<td><font class="bashcommand-result">C11137544</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11137123</font></td>
						<td><font class="bashcommand-result">C11137443</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11138150</font></td>
						<td><font class="bashcommand-result">C11137123</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11138152</font></td>
						<td><font class="bashcommand-result">C11137439</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11138797</font></td>
						<td><font class="bashcommand-result">C11137439</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11138184</font></td>
						<td><font class="bashcommand-result">C11133100</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11138122</font></td>
						<td><font class="bashcommand-result">D11144030</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11138122</font></td>
						<td><font class="bashcommand-result">B11108399</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">C11138192</font></td>
						<td><font class="bashcommand-result">B11108326</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">B12226507</font></td>
						<td><font class="bashcommand-result">B11119909</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">B12226546</font></td>
						<td><font class="bashcommand-result">B11110893</font></td>
					</tr>
				</table>
				</p>

				<p>To precede each line by the line number, add <font class="bashcommand">NR</font>, after the string <font class="bashcommand">print</font> in the <font class="bashcommand">awk</font> command to indicate that you want to print the Number Row before the column 1 (<font class="bashcommand">$1</font>):</p>

				<p>
				<table class="ghostTable">
					<tr>
						<th>Space-separated files</th>
						<th>Comma-separated files</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">$ awk '{print NR,$1}' file2.txt</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print NR, $1}' file1.csv</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">1 "AnonymizedID"</font></td>
						<td><font class="bashcommand-result">1 "Anonymized ID"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">2 "B11130912"</font></td>
						<td><font class="bashcommand-result">2 "B33199522"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">3 "B11137244"</font></td>
						<td><font class="bashcommand-result">3 "B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">4 "B11154534"</font></td>
						<td><font class="bashcommand-result">4 "B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">5 "B11144100"</font></td>
						<td><font class="bashcommand-result">5 "B11144410"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">6 "B11137244"</font></td>
						<td><font class="bashcommand-result">6 "B11110455"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">7 "B12226566"</font></td>
						<td><font class="bashcommand-result">7 "B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">8 "B11134987"</font></td>
						<td><font class="bashcommand-result">8 "B11153927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">9 "B11144345"</font></td>
						<td><font class="bashcommand-result">9 "B11177579"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">10 "C11137159"</font></td>
						<td><font class="bashcommand-result">10 "B11177806"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">11 "B11156453"</font></td>
						<td><font class="bashcommand-result">11 "B11157958"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">12 "B11110676"</font></td>
						<td><font class="bashcommand-result">12 "B11110690"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">13 "C11138929"</font></td>
						<td><font class="bashcommand-result">13 "B11152799"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">14 "B11154532"</font></td>
						<td><font class="bashcommand-result">14 "B11154358"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">15 "B11155267"</font></td>
						<td><font class="bashcommand-result">15 "B11110925"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">16 "B11137120"</font></td>
						<td><font class="bashcommand-result">16 "B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">17 "B33191224"</font></td>
						<td><font class="bashcommand-result">17 "B11135072"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">18 "B11155267"</font></td>
						<td><font class="bashcommand-result">18 "B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">19 "C11138999"</font></td>
						<td><font class="bashcommand-result">19 "B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">20 "B11131605"</font></td>
						<td><font class="bashcommand-result">20 "B11131605"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">21 "B11137784"</font></td>
						<td><font class="bashcommand-result">21 "B11110927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">22 "B11156098"</font></td>
						<td><font class="bashcommand-result">22 "B11147712"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">23 "B11133232"</font></td>
						<td><font class="bashcommand-result">23 "B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">24 "B11135292"</font></td>
						<td><font class="bashcommand-result">24 "B11131290"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">25 "C11138912"</font></td>
						<td><font class="bashcommand-result">25 "B11157974"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">26 "B11150911"</font></td>
						<td><font class="bashcommand-result">26 "B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">27 "B11152577"</font></td>
						<td><font class="bashcommand-result">27 "B11141503"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">28 "B11156098"</font></td>
						<td><font class="bashcommand-result">28 "C11137159"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">29 "B11133232"</font></td>
						<td><font class="bashcommand-result">29 "B33199522"</font></td>
					</tr>
				</table>
				</p>

				<p>
				<table class="ghostTable">
					<tr>
						<td><font class="bashcommand">$ awk '{print NR, $1}' file4.txt</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print NR, $1}' file3.csv</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">1 AnonymizedID</font></td>
						<td><font class="bashcommand-result">1 Anonymized ID</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">2 B11108326</font></td>
						<td><font class="bashcommand-result">2 C11138122</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">3 B11110893</font></td>
						<td><font class="bashcommand-result">3 C11138192</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">4 B11119909</font></td>
						<td><font class="bashcommand-result">4 B12226507</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">5 D11144030</font></td>
						<td><font class="bashcommand-result">5 B12226546</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">6 D11144030</font></td>
						<td><font class="bashcommand-result">6 C11138122</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">7 B11119903</font></td>
						<td><font class="bashcommand-result">7 C11138184</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">8 C11131039</font></td>
						<td><font class="bashcommand-result">8 C11138797</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">9 C11133100</font></td>
						<td><font class="bashcommand-result">9 C11138152</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">10 C11135566</font></td>
						<td><font class="bashcommand-result">10 C11138150</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">11 C11137159</font></td>
						<td><font class="bashcommand-result">11 C11137167</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">12 C11137159</font></td>
						<td><font class="bashcommand-result">12 C11137159</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">13 C11137167</font></td>
						<td><font class="bashcommand-result">13 C11137167</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">14 C11137167</font></td>
						<td><font class="bashcommand-result">14 C11137159</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">15 C11137439</font></td>
						<td><font class="bashcommand-result">15 C11131039</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">16 C11137439</font></td>
						<td><font class="bashcommand-result">16 C11135566</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">17 C11137443</font></td>
						<td><font class="bashcommand-result">17 B11119903</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">18 C11137544</font></td>
						<td><font class="bashcommand-result">18 C11137544</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">19 C11137123</font></td>
						<td><font class="bashcommand-result">19 C11137443</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">20 C11138150</font></td>
						<td><font class="bashcommand-result">20 C11137123</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">21 C11138152</font></td>
						<td><font class="bashcommand-result">21 C11137439</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">22 C11138797</font></td>
						<td><font class="bashcommand-result">22 C11137439</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">23 C11138184</font></td>
						<td><font class="bashcommand-result">23 C11133100</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">24 C11138122</font></td>
						<td><font class="bashcommand-result">24 D11144030</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">25 C11138122</font></td>
						<td><font class="bashcommand-result">25 B11108399</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">26 C11138192</font></td>
						<td><font class="bashcommand-result">26 B11108326</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">27 B12226507</font></td>
						<td><font class="bashcommand-result">27 B11119909</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">28 B12226546</font></td>
						<td><font class="bashcommand-result">28 B11110893</font></td>
					</tr>
				</table>
				</p>

				<p>
					<font class="example">Print the first column of file1.csv and file2.txt in reverse order</font>
					In order to print from the last line to the first line, you can use the command <font class="bashcommand">tail</font> with the flag <font class="bashcommand">-r</font> (for reverse) after the command <font class="bashcommand">awk</font>. The command line will first execute the <font class="bashcommand">awk</font> command which is written before the <font class="bashcommand">|</font> symbol, and then it will run the <font class="bashcommand">tail</font> command which inverts the order of the previous output. Remember that for file1.csv you need to use <font class="bashcommand">-F','</font> to indicate that the columns are separated by commas and not spaces.
				</p>

				<p>
				<table class="ghostTable">
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">$ awk '{print $1}' file2.txt | tail -r</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print $1}' file1.csv | tail -r</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11133232"</font></td>
						<td><font class="bashcommand-result">"B33199522"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11156098"</font></td>
						<td><font class="bashcommand-result">"C11137159"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11152577"</font></td>
						<td><font class="bashcommand-result">"B11141503"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11150911"</font></td>
						<td><font class="bashcommand-result">"B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11138912"</font></td>
						<td><font class="bashcommand-result">"B11157974"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11135292"</font></td>
						<td><font class="bashcommand-result">"B11131290"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11133232"</font></td>
						<td><font class="bashcommand-result">"B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11156098"</font></td>
						<td><font class="bashcommand-result">"B11147712"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137784"</font></td>
						<td><font class="bashcommand-result">"B11110927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11131605"</font></td>
						<td><font class="bashcommand-result">"B11110603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11138999"</font></td>
						<td><font class="bashcommand-result">"B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11155267"</font></td>
						<td><font class="bashcommand-result">"B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33191224"</font></td>
						<td><font class="bashcommand-result">"B11135072"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137120"</font></td>
						<td><font class="bashcommand-result">"B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11155267"</font></td>
						<td><font class="bashcommand-result">"B11110925"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11154532"</font></td>
						<td><font class="bashcommand-result">"B11154358"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11138929"</font></td>
						<td><font class="bashcommand-result">"B11152799"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11110676"</font></td>
						<td><font class="bashcommand-result">"B11110690"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11156453"</font></td>
						<td><font class="bashcommand-result">"B11157958"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11137159"</font></td>
						<td><font class="bashcommand-result">"B11177806"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11144345"</font></td>
						<td><font class="bashcommand-result">"B11177579"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11134987"</font></td>
						<td><font class="bashcommand-result">"B11153927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B12226566"</font></td>
						<td><font class="bashcommand-result">"B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137244"</font></td>
						<td><font class="bashcommand-result">"B11110455"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11144100"</font></td>
						<td><font class="bashcommand-result">"B11144410"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11154534"</font></td>
						<td><font class="bashcommand-result">"B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137244"</font></td>
						<td><font class="bashcommand-result">"B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11130912"</font></td>
						<td><font class="bashcommand-result">"B33199522"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"AnonymizedID"</font></td>
						<td><font class="bashcommand-result">"Anonymized ID"</font></td>
					</tr>
				</table>
				</p>

				<p>The same as in example 1, to precede each line by the line number, add <font class="bashcommand">NR</font>, after the string <font class="bashcommand">print</font> in the <font class="bashcommand">awk</font> command to indicate that you want to print the Number Row before the column 1 (<font class="bashcommand">$1</font>):</p>

				<p>
				<table class="ghostTable">
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">$ awk '{print NR, $1}' file2.txt | tail -r</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print NR, $1}' file1.csv | tail -r</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">29 "B11133232"</font></td>
						<td><font class="bashcommand-result">29 "B33199522"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">28 "B11156098"</font></td>
						<td><font class="bashcommand-result">28 "C11137159"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">27 "B11152577"</font></td>
						<td><font class="bashcommand-result">27 "B11141503"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">26 "B11150911"</font></td>
						<td><font class="bashcommand-result">26 "B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">25 "C11138912"</font></td>
						<td><font class="bashcommand-result">25 "B11157974"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">24 "B11135292"</font></td>
						<td><font class="bashcommand-result">24 "B11131290"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">23 "B11133232"</font></td>
						<td><font class="bashcommand-result">23 "B33191224"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">22 "B11156098"</font></td>
						<td><font class="bashcommand-result">22 "B11147712"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">21 "B11137784"</font></td>
						<td><font class="bashcommand-result">21 "B11110927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">20 "B11131605"</font></td>
						<td><font class="bashcommand-result">20 "B11110603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">19 "C11138999"</font></td>
						<td><font class="bashcommand-result">19 "B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">18 "B11155267"</font></td>
						<td><font class="bashcommand-result">18 "B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">17 "B33191224"</font></td>
						<td><font class="bashcommand-result">17 "B11135072"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">16 "B11137120"</font></td>
						<td><font class="bashcommand-result">16 "B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">15 "B11155267"</font></td>
						<td><font class="bashcommand-result">15 "B11110925"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">14 "B11154532"</font></td>
						<td><font class="bashcommand-result">14 "B11154358"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">13 "C11138929"</font></td>
						<td><font class="bashcommand-result">13 "B11152799"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">12 "B11110676"</font></td>
						<td><font class="bashcommand-result">12 "B11110690"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">11 "B11156453"</font></td>
						<td><font class="bashcommand-result">11 "B11157958"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">10 "C11137159"</font></td>
						<td><font class="bashcommand-result">10 "B11177806"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">9 "B11144345"</font></td>
						<td><font class="bashcommand-result">9 "B11177579"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">8 "B11134987"</font></td>
						<td><font class="bashcommand-result">8 "B11153927"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">7 "B12226566"</font></td>
						<td><font class="bashcommand-result">7 "B11135291"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">6 "B11137244"</font></td>
						<td><font class="bashcommand-result">6 "B11110455"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">5 "B11144100"</font></td>
						<td><font class="bashcommand-result">5 "B11144410"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">4 "B11154534"</font></td>
						<td><font class="bashcommand-result">4 "B11137879"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">3 "B11137244"</font></td>
						<td><font class="bashcommand-result">3 "B33199603"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">2 "B11130912"</font></td>
						<td><font class="bashcommand-result">2 "B33199522"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">1 "AnonymizedID"</font></td>
						<td><font class="bashcommand-result">1 "Anonymized ID"</font></td>
					</tr>
				</table>
				</p>

				<p>
				<font class="example">Print the second and third columns of file1.csv and file2.txt. Show the lines of file2.txt in <b>reverse order</b>.</font>
				In the previous examples we used the action statement <font class="bashcommand">'{print $1}'</font> to print the first column. Since we now want to print the second and third columns instead of the first one, we replace  <font class="bashcommand">$1</font> by  <font class="bashcommand">$2</font>, <font class="bashcommand">$3</font>. If you wanted to print column 4 and 5 instead, then you would simply use <font class="bashcommand">$4</font>,<font class="bashcommand">$5</font>, etc. In order to print the output in reverse order for file2.txt, use the <font class="bashcommand">tail -r</font> command after the <font class="bashcommand">awk</font>. 
				</p>

				<p>
				<table class="ghostTable">
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">$ awk '{print $2,$3}' file2.txt</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print $2,$3}' file1.csv | tail -r</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"SubjectGroup" "TEST1"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "900"</font></td>
						<td><font class="bashcommand-result">"Group3" "9"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "450"</font></td>
						<td><font class="bashcommand-result">"Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "456"</font></td>
						<td><font class="bashcommand-result">"Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "450"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "450"</font></td>
						<td><font class="bashcommand-result">"Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "450"</font></td>
						<td><font class="bashcommand-result">"Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "900"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "900"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group3" "MissingData"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group4" "456"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "900"</font></td>
						<td><font class="bashcommand-result">"Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "2"</font></td>
						<td><font class="bashcommand-result">"MISSING" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "456"</font></td>
						<td><font class="bashcommand-result">"Group3" "9"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group3" "900"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "450"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "450"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group3" "900"</font></td>
						<td><font class="bashcommand-result">"Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "900"</font></td>
						<td><font class="bashcommand-result">"Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "456"</font></td>
						<td><font class="bashcommand-result">"Group1" "MD"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "900"</font></td>
						<td><font class="bashcommand-result">"Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "500"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "500"</font></td>
						<td><font class="bashcommand-result">"Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group3" "MissingData"</td>
						<td><font class="bashcommand-result">"Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "900"</font></td>
						<td><font class="bashcommand-result">"Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group2b" "900"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "900"</font></td>
						<td><font class="bashcommand-result">"Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "456"</font></td>
						<td><font class="bashcommand-result">"Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Group1" "456"</font></td>
						<td><font class="bashcommand-result">"Subject Group" "HASCONDITION"</font></td>
					</tr>
				</table>
				</p>

				<p>To precede each line by the line number, add <font class="bashcommand">NR</font>, after the string <font class="bashcommand">print</font> in the <font class="bashcommand">awk</font> command to indicate that you want to print the Number Row before the column 1 (<font class="bashcommand">$1</font>):</p>

				<p>
				<table class="ghostTable">
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">$ awk '{print NR,$2,$3}' file2.txt</font></td>
						<td><font class="bashcommand">$ awk -F',' '{print NR,$2,$3}' file1.csv | tail -r</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">1 "SubjectGroup" "TEST1"</font></td>
						<td><font class="bashcommand-result">29 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">2 "Group2b" "900"</font></td>
						<td><font class="bashcommand-result">28 "Group3" "9"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">3 "Group1" "450"</font></td>
						<td><font class="bashcommand-result">27 "Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">4 "Group1" "456"</font></td>
						<td><font class="bashcommand-result">26 "Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">5 "Group1" "450"</font></td>
						<td><font class="bashcommand-result">25 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">6 "Group1" "450"</font></td>
						<td><font class="bashcommand-result">24 "Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">7 "Group2b" "450"</font></td>
						<td><font class="bashcommand-result">23 "Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">8 "Group1" "900"</font></td>
						<td><font class="bashcommand-result">22 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">9 "Group1" "900"</font></td>
						<td><font class="bashcommand-result">21 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">10 "Group3" "MissingData"</font></td>
						<td><font class="bashcommand-result">20 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">11 "Group4" "456"</font></td>
						<td><font class="bashcommand-result">19 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">12 "Group1" "900"</font></td>
						<td><font class="bashcommand-result">18 "Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">13 "Group2b" "2"</font></td>
						<td><font class="bashcommand-result">17 "MISSING" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">14 "Group1" "456"</font></td>
						<td><font class="bashcommand-result">16 "Group3" "9"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">15 "Group3" "900"</font></td>
						<td><font class="bashcommand-result">15 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">16 "Group2b" "450"</font></td>
						<td><font class="bashcommand-result">14 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">17 "Group2b" "450"</font></td>
						<td><font class="bashcommand-result">13 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">18 "Group3" "900"</font></td>
						<td><font class="bashcommand-result">12 "Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">19 "Group2b" "900"</font></td>
						<td><font class="bashcommand-result">11 "Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">20 "Group1" "456"</font></td>
						<td><font class="bashcommand-result">10 "Group1" "MD"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">21 "Group1" "900"</font></td>
						<td><font class="bashcommand-result">9 "Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">22 "Group1" "500"</font></td>
						<td><font class="bashcommand-result">8 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">23 "Group1" "500"</font></td>
						<td><font class="bashcommand-result">7 "Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">24 "Group3" "MissingData"</font></td>
						<td><font class="bashcommand-result">6 "Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">25 "Group2b" "900"</font></td>
						<td><font class="bashcommand-result">5 "Group2 b" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">26 "Group2b" "900"</font></td>
						<td><font class="bashcommand-result">4 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">27 "Group1" "900"</font></td>
						<td><font class="bashcommand-result">3 "Group3" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">28 "Group1" "456"</font></td>
						<td><font class="bashcommand-result">2 "Group1" "0"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">29 "Group1" "456"</font></td>
						<td><font class="bashcommand-result">1 "Subject Group" "HASCONDITION"</font></td>
					</tr>
				</table>
				</p>

				<p>
					<font class="example">Print all the columns of file1.csv showing the lines in <b>reverse order</b>.</font>
					To print all the columns of a file using <font class="bashcommand">awk</font> simply use <font class="bashcommand">$0</font> (instead of a column number). Or use the command <font class="bashcommand">cat</font>.
				</p>

				<p>
				<table class="ghostTable">
					<tr>
						<th>Using <font class="bashcommand">awk</font></th>
						<th>Using <font class="bashcommand">cat</font></th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">$ awk -F',' '{print $0}' file1.csv | tail -r</font></td>
						<td><font class="bashcommand">$ cat file1.csv | tail -r</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33199522","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B33199522","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"C11137159","Group3","9","mTBI"</font></td>
						<td><font class="bashcommand-result">"C11137159","Group3","9","mTBI"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11141503","Group3","0",""</font></td>
						<td><font class="bashcommand-result">"B11141503","Group3","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33191224","Group2 b","0",""</font></td>
						<td><font class="bashcommand-result">"B33191224","Group2 b","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11157974","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11157974","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11131290","Group2 b","0",""</font></td>
						<td><font class="bashcommand-result">"B11131290","Group2 b","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33191224","Group2 b","0",""</font></td>
						<td><font class="bashcommand-result">"B33191224","Group2 b","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11147712","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11147712","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11110927","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11110927","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11110603","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11110603","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137879","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11137879","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33199603","Group3","0",""</font></td>
						<td><font class="bashcommand-result">"B33199603","Group3","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11135072","MISSING","0",""</font></td>
						<td><font class="bashcommand-result">"B11135072","MISSING","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11135291","Group3","9","mTBI"</font></td>
						<td><font class="bashcommand-result">"B11135291","Group3","9","mTBI"</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11110925","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11110925","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11154358","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11154358","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11152799","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11152799","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11110690","Group3","0",""</font></td>
						<td><font class="bashcommand-result">"B11110690","Group3","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11157958","Group3","0",""</font></td>
						<td><font class="bashcommand-result">"B11157958","Group3","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11177806","Group1","MD",""</font></td>
						<td><font class="bashcommand-result">"B11177806","Group1","MD",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11177579","Group2 b","0",""</font></td>
						<td><font class="bashcommand-result">"B11177579","Group2 b","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11153927","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11153927","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11135291","Group3","0",""</font></td>
						<td><font class="bashcommand-result">"B11135291","Group3","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11110455","Group2 b","0",""</font></td>
						<td><font class="bashcommand-result">"B11110455","Group2 b","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11144410","Group2 b","0",""</font></td>
						<td><font class="bashcommand-result">"B11144410","Group2 b","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B11137879","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B11137879","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33199603","Group3","0",""</font></td>
						<td><font class="bashcommand-result">"B33199603","Group3","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"B33199522","Group1","0",""</font></td>
						<td><font class="bashcommand-result">"B33199522","Group1","0",""</font></td>
					</tr>
					
					<tr>
						<td><font class="bashcommand-result">"Anonymized ID","Subject Group","HASCONDITION","CONDITION"</font></td>
						<td><font class="bashcommand-result">"Anonymized ID","Subject Group","HASCONDITION","CONDITION"</font></td>
					</tr>
				</table>
				</p>
	
				<p>
					<font class="example">Print all the columns of file1.csv in <b>reversed order</b> (first the third column, then the second and finally the first one), and save the re-ordered columns in a new file called file1_reordered.csv.</font>
					If you were going to print the columns one to three in normal order, you would use <font class="bashcommand">'{print $1,$2,$3}'</font>. To print them in reverse order, you just reverse the order of the columns in <font class="bashcommand">print</font>: <font class="bashcommand">'{print $3,$2,$1}'</font>.<br>
					To save the output to a file instead of showing it in the terminal, use <font class="bashcommand">&gt;&gt; file</font> as explained in previous sections.<br>
					Remember to use the <font class="bashcommand">-F','</font> flag to indicate that the columns are separated by commas and not the default space.
				</p>

				<p><font class="bashcommand">
				$ awk -F',' '{print $3,$2,$1}' file1.csv &gt;&gt; file1_reordered.csv<br>
				$ cat file1_reordered.csv<br>
				<font class="bashcommand-result"><br>
				"HASCONDITION" "Subject Group" "Anonymized ID"<br>
				"0" "Group1" "B33199522"<br>
				"0" "Group3" "B33199603"<br>
				"0" "Group1" "B11137879"<br>
				"0" "Group2 b" "B11144410"<br>
				"0" "Group2 b" "B11110455"<br>
				"0" "Group3" "B11135291"<br>
				"0" "Group1" "B11153927"<br>
				"0" "Group2 b" "B11177579"<br>
				"MD" "Group1" "B11177806"<br>
				"0" "Group3" "B11157958"<br>
				"0" "Group3" "B11110690"<br>
				"0" "Group1" "B11152799"<br>
				"0" "Group1" "B11154358"<br>
				"0" "Group1" "B11110925"<br>
				"9" "Group3" "B11135291"<br>
				"0" "MISSING" "B11135072"<br>
				"0" "Group3" "B33199603"<br>
				"0" "Group1" "B11137879"<br>
				"0" "Group1" "B11110603"<br>
				"0" "Group1" "B11110927"<br>
				"0" "Group1" "B11147712"<br>
				"0" "Group2 b" "B33191224"<br>
				"0" "Group2 b" "B11131290"<br>
				"0" "Group1" "B11157974"<br>
				"0" "Group2 b" "B33191224"<br>
				"0" "Group3" "B11141503"<br>
				"9" "Group3" "C11137159"<br>
				"0" "Group1" "B33199522"
				</font>
				</font></p>

				<p>
				<font class="example">Print all the columns of file1.csv in <b>reversed order</b> (first the third column, then the second and finally the first one). Print the lines also in reverse order (from the last line to the first one).</font><br>
				Use the same command as before, adding <font class="bashcommand">| tail -r</font> at the end to invert also the lines. 
				</p>

				<p><font class="bashcommand">
				$ awk -F',' '{print $3,$2,$1}' file1.csv | tail -r<br>
				<font class="bashcommand-result">
				"0" "Group1" "B33199522"<br>
				"9" "Group3" "C11137159"<br>
				"0" "Group3" "B11141503"<br>
				"0" "Group2 b" "B33191224"<br>
				"0" "Group1" "B11157974"<br>
				"0" "Group2 b" "B11131290"<br>
				"0" "Group2 b" "B33191224"<br>
				"0" "Group1" "B11147712"<br>
				"0" "Group1" "B11110927"<br>
				"0" "Group1" "B11110603"<br>
				"0" "Group1" "B11137879"<br>
				"0" "Group3" "B33199603"<br>
				"0" "MISSING" "B11135072"<br>
				"9" "Group3" "B11135291"<br>
				"0" "Group1" "B11110925"<br>
				"0" "Group1" "B11154358"<br>
				"0" "Group1" "B11152799"<br>
				"0" "Group3" "B11110690"<br>
				"0" "Group3" "B11157958"<br>
				"MD" "Group1" "B11177806"<br>
				"0" "Group2 b" "B11177579"<br>
				"0" "Group1" "B11153927"<br>
				"0" "Group3" "B11135291"<br>
				"0" "Group2 b" "B11110455"<br>
				"0" "Group2 b" "B11144410"<br>
				"0" "Group1" "B11137879"<br>
				"0" "Group3" "B33199603"<br>
				"0" "Group1" "B33199522"<br>
				"HASCONDITION" "Subject Group" "Anonymized ID" 
				</font>
				</font></p>

				<p>
				<font class="example">Read the second column of file1.csv and file2.txt and save it into an array.</font> 
				When saving a column of a file into an array, you must specify that the elements of the array are separated by new lines (<font class="bashcommand">'\n'</font>). You do this using the command <font class="bashcommand">IFS=$'\n'</font>.<br> 
				The elements of the array will be saved in the variable <font class="bashcommand">ARRAY</font>. As it was learned in previous chapters, to access the individual elements of <font class="bashcommand">ARRAY</font> you use the syntax <font class="bashcommand">${ARRAY[index]}</font>. With <font class="bashcommand">index</font> starting at <font class="bashcommand">0</font>. So, to access the first element the command is <font class="bashcommand">echo ${ARRAY[0]}</font>, to access the second element <font class="bashcommand">echo ${ARRAY[1]}</font>, etc. Type <font class="bashcommand">echo ${ARRAY[@]}</font> to view all elements and to obtain the number of elements (size of <font class="bashcommand">ARRAY</font>).<br>
				Remember, the system variable <font class="bashcommand">IFS</font> contains the separator that is being used to separate each feld within the lines of a file. You can change the value of this variable at any time: <font class="bashcommand">IFS='character'</font>
				</p>

				<table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ IFS=$'\n'<br>
						$ ARRAY=($(awk '{print $2}' file2.txt))<br>
						$ echo ${ARRAY[0]}<br> 
						<font class="bashcommand-result">"SubjectGroup"</font><br>
						$ echo ${ARRAY[1]}<br>
						<font class="bashcommand-result">"Group2b"</font><br>
						$ echo ${ARRAY[@]}<br>
						<font class="bashcommand-result">"SubjectGroup" "Group2b" "Group1" "Group1" "Group1" "Group1" "Group2b" "Group1" "Group1" "Group3" "Group4" "Group1" "Group2b" "Group1" "Group3" "Group2b" "Group2b" "Group3" "Group2b" "Group1" "Group1" "Group1" "Group1" "Group3" "Group2b" "Group2b" "Group1" "Group1" "Group1"</font><br>
						$ echo ${#ARRAY[@]}<br>
						<font class="bashcommand-result">29</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ IFS=$'\n'<br>
						$ ARRAY=($(awk -F',' '{print $2}' file1.csv))<br>
						$ echo ${ARRAY[0]}<br>
						<font class="bashcommand-result">"Subject Group"</font><br>
						$ echo ${ARRAY[1]}<br>
						<font class="bashcommand-result">"Group1"</font><br>
						$ echo ${ARRAY[@]}<br>
						<font class="bashcommand-result">"Subject Group" "Group1" "Group3" "Group1" "Group2 b" "Group2 b" "Group3" "Group1" "Group2 b" "Group1" "Group3" "Group3" "Group1" "Group1" "Group1" "Group3" "MISSING" "Group3" "Group1" "Group1" "Group1" "Group1" "Group2 b" "Group2 b" "Group1" "Group2 b" "Group3" "Group3" "Group1"</font><br>
						$ echo ${#ARRAY[@]}<br>
						<font class="bashcommand-result">29</font>
						</font></td>
					</tr>
				</table>

				<p>
				<font class="example">Print the first column of file2.txt followed by the first column of file4.txt.</font>
				To print a specific column for more than one file, you use the same command, adding the list of files you want to print after the first one. However, all the files in the list must use the same column separator (in this case is a space). Since the column separator for this list of files is a space (the default), you don't need to use the <font class="bashcommand">-F</font> flag.
				</p>

				<p>
				<font class="bashcommand">
				$ awk '{print $1}' file2.txt file4.txt<br>
				<font class="bashcommand-result">
				"AnonymizedID"<br>
				"B11130912"<br>
				"B11137244"<br>
				"B11154534"<br>
				"B11144100"<br>
				"B11137244"<br>
				"B12226566"<br>
				"B11134987"<br>
				"B11144345"<br>
				"C11137159"<br>
				"B11156453"<br>
				"B11110676"<br>
				"C11138929"<br>
				"B11154532"<br>
				"B11155267"<br>
				"B11137120"<br>
				"B33191224"<br>
				"B11155267"<br>
				"C11138999"<br>
				"B11131605"<br>
				"B11137784"<br>
				"B11156098"<br>
				"B11133232"<br>
				"B11135292"<br>
				"C11138912"<br>
				"B11150911"<br>
				"B11152577"<br>
				"B11156098"<br>
				"B11133232"<br>
				AnonymizedID<br>
				B11108326<br>
				B11110893<br>
				B11119909<br>
				D11144030<br>
				D11144030<br>
				B11119903<br>
				C11131039<br>
				C11133100<br>
				C11135566<br>
				C11137159<br>
				C11137159<br>
				C11137167<br>
				C11137167<br>
				C11137439<br>
				C11137439<br>
				C11137443<br>
				C11137544<br>
				C11137123<br>
				C11138150<br>
				C11138152<br>
				C11138797<br>
				C11138184<br>
				C11138122<br>
				C11138122<br>
				C11138192<br>
				B12226507<br>
				B12226546
				</font>
				</font>
				</p>

				<p>
				<font class="example">Print the first column of file3.csv followed by the first column of file1.csv.</font> 
				Since the column separator for this list of files is a comma, you need to use the <font class="bashcommand">-F','</font> flag.
				</p>

				<p>
				<font class="bashcommand">
				$ awk -F',' '{print $1}' file3.csv file1.csv<br>
				<font class="bashcommand-result">
				Anonymized ID<br>
				C11138122<br>
				C11138192<br>
				B12226507<br>
				B12226546<br>
				C11138122<br>
				C11138184<br>
				C11138797<br>
				C11138152<br>
				C11138150<br>
				C11137167<br>
				C11137159<br>
				C11137167<br>
				C11137159<br>
				C11131039<br>
				C11135566<br>
				B11119903<br>
				C11137544<br>
				C11137443<br>
				C11137123<br>
				C11137439<br>
				C11137439<br>
				C11133100<br>
				D11144030<br>
				B11108399<br>
				B11108326<br>
				B11119909<br>
				B11110893<br>
				"Anonymized ID"<br>
				"B33199522"<br>
				"B33199603"<br>
				"B11137879"<br>
				"B11144410"<br>
				"B11110455"<br>
				"B11135291"<br>
				"B11153927"<br>
				"B11177579"<br>
				"B11177806"<br>
				"B11157958"<br>
				"B11110690"<br>
				"B11152799"<br>
				"B11154358"<br>
				"B11110925"<br>
				"B11135291"<br>
				"B11135072"<br>
				"B33199603"<br>
				"B11137879"<br>
				"B11110603"<br>
				"B11110927"<br>
				"B11147712"<br>
				"B33191224"<br>
				"B11131290"<br>
				"B11157974"<br>
				"B33191224"<br>
				"B11141503"<br>
				"C11137159"<br>
				"B33199522" 
				</font>
				</font>
				</p>

			<h3>9.8. Examples: Reading specific columns from a file or a list of files and sorting the result in alphabetical order and/or removing duplicate values</h3>
				<p>
				<font class="example">Print the first column of file1.csv and file2.txt <b>in alphabetical order</b>.</font>
				In order to do this, you sort the result after printing the first column. First, use <font class="bashcommand">awk</font> to print the desired column, followed by <font class="bashcommand">| sort</font> to sort it in alphabetical order. 
				</p>

				<p><table class="ghostTable">
				<tr>
					<th>Space-separated file</th>
					<th>Comma-separated file</th>
				</tr>
					
				<tr>
					<td><font class="bashcommand">
					$ awk '{print $1}' file2.txt | sort<br>
					<font class="bashcommand-result">
					"AnonymizedID"<br>
					"B11110676"<br>
					"B11130912"<br>
					"B11131605"<br>
					"B11133232"<br>
					"B11133232"<br>
					"B11134987"<br>
					"B11135292"<br>
					"B11137120"<br>
					"B11137244"<br>
					"B11137244"<br>
					"B11137784"<br>
					"B11144100"<br>
					"B11144345"<br>
					"B11150911"<br>
					"B11152577"<br>
					"B11154532"<br>
					"B11154534"<br>
					"B11155267"<br>
					"B11155267"<br>
					"B11156098"<br>
					"B11156098"<br>
					"B11156453"<br>
					"B12226566"<br>
					"B33191224"<br>
					"C11137159"<br>
					"C11138912"<br>
					"C11138929"<br>
					"C11138999"
					</font>
					</font></td>
					
					<td><font class="bashcommand">
					$ awk -F ',' '{print $1}' file1.csv | sort<br>
					<font class="bashcommand-result">
					"Anonymized ID"<br>
					"B11110455"<br>
					"B11110603"<br>
					"B11110690"<br>
					"B11110925"<br>
					"B11110927"<br>
					"B11131290"<br>
					"B11135072"<br>
					"B11135291"<br>
					"B11135291"<br>
					"B11137879"<br>
					"B11137879"<br>
					"B11141503"<br>
					"B11144410"<br>
					"B11147712"<br>
					"B11152799"<br>
					"B11153927"<br>
					"B11154358"<br>
					"B11157958"<br>
					"B11157974"<br>
					"B11177579"<br>
					"B11177806"<br>
					"B33191224"<br>
					"B33191224"<br>
					"B33199522"<br>
					"B33199522"<br>
					"B33199603"<br>
					"B33199603"<br>
					"C11137159"
					</font>
					</font></td>
				</tr>
				</table></p>

				<p>
				<font class="example">Print the first column of file1.csv and file2.txt <b>in alphabetical removing any duplicate values</b>.</font>
				In order to do this, you remove the duplicates after printing and sorting the first column. First, use <font class="bashcommand">awk</font> to print the desired column, followed by <font class="bashcommand">sort | uniq</font> to sort and remove the duplicates on the result.
				</p>

				<p><table class="ghostTable">
				<tr>
					<th>Space-separated file</th>
					<th>Comma-separated file</th>
				</tr>
					
				<tr>
					<td><font class="bashcommand">
					$ awk '{print $1}' file2.txt | sort | uniq<br>
					<font class="bashcommand-result">
					"AnonymizedID"<br>
					"B11130912"<br>
					"B11137244"<br>
					"B11154534"<br>
					"B11144100"<br>
					"B11137244"<br>
					"B12226566"<br>
					"B11134987"<br>
					"B11144345"<br>
					"C11137159"<br>
					"B11156453"<br>
					"B11110676"<br>
					"C11138929"<br>
					"B11154532"<br>
					"B11155267"<br>
					"B11137120"<br>
					"B33191224"<br>
					"B11155267"<br>
					"C11138999"<br>
					"B11131605"<br>
					"B11137784"<br>
					"B11156098"<br>
					"B11133232"<br>
					"B11135292"<br>
					"C11138912"<br>
					"B11150911"<br>
					"B11152577"<br>
					"B11156098"<br>
					"B11133232"
					</font>
					</font></td>	
					
					<td><font class="bashcommand">
					$ awk -F ',' '{print $1}' file1.csv | sort | uniq<br>
					<font class="bashcommand-result">
					"Anonymized ID"<br>
					"B33199522"<br>
					"B33199603"<br>
					"B11137879"<br>
					"B11144410"<br>
					"B11110455"<br>
					"B11135291"<br>
					"B11153927"<br>
					"B11177579"<br>
					"B11177806"<br>
					"B11157958"<br>
					"B11110690"<br>
					"B11152799"<br>
					"B11154358"<br>
					"B11110925"<br>
					"B11135291"<br>
					"B11135072"<br>
					"B33199603"<br>
					"B11137879"<br>
					"B11110603"<br>
					"B11110927"<br>
					"B11147712"<br>
					"B33191224"<br>
					"B11131290"<br>
					"B11157974"<br>
					"B33191224"<br>
					"B11141503"<br>
					"C11137159"<br>
					"B33199522"
					</font>
					</font></td>
				</tr>
				</table></p>

				<p>
				Print the first column of file1.csv and file3.csv combined, in alphabetical order and with no duplicates.<br>
				As explained in a previous example, to print the first column of file1.csv and file3.csv combined just use the command <font class="bashcommand">awk</font> with the list of files to be read (file1.csv file3.csv) at the end of the command. Then, use <font class="bashcommand">| sort</font> to organize the output in alphabetical order, and finally use <font class="bashcommand">| uniq</font> to remove the duplicates. 
				</p>

				<p>In this case, because the strings in file1.csv all start by colons (<font class="bashcommand">"</font>), while the values in file3.csv don't, then all the values of file1.csv will be printed before those of file3.csv (because alphabetically, special characters such as <font class="bashcommand">"</font> go before any letter (including <font class="bashcommand">A</font>). So, for bash <font class="bashcommand">"B11110455"</font> goes before <font class="bashcommand">Anonymized ID</font>.</p>

				<p><font class="bashcommand">
				$ awk -F ',' '{print $1}' file1.csv file3.csv | sort | uniq<br>
				<font class="bashcommand-result">
				"Anonymized ID"<br>
				"B11110455"<br>
				"B11110603"<br>
				"B11110690"<br>
				"B11110925"<br>
				"B11110927"<br>
				"B11131290"<br>
				"B11135072"<br>
				"B11135291"<br>
				"B11137879"<br>
				"B11141503"<br>
				"B11144410"<br>
				"B11147712"<br>
				"B11152799"<br>
				"B11153927"<br>
				"B11154358"<br>
				"B11157958"<br>
				"B11157974"<br>
				"B11177579"<br>
				"B11177806"<br>
				"B33191224"<br>
				"B33199522"<br>
				"B33199603"<br>
				"C11137159"<br>
				Anonymized ID<br>
				B11108326<br>
				B11108399<br>
				B11110893<br>
				B11119903<br>
				B11119909<br>
				B12226507<br>
				B12226546<br>
				C11131039<br>
				C11133100<br>
				C11135566<br>
				C11137123<br>
				C11137159<br>
				C11137167<br>
				C11137439<br>
				C11137443<br>
				C11137544<br>
				C11138122<br>
				C11138150<br>
				C11138152<br>
				C11138184<br>
				C11138192<br>
				C11138797<br>
				D11144030
				</font>
				</font></p>

			<h3>9.9. Examples: Reading all the columns from multiple files and concatenating them horizontally</h3>
				<p>
				<font class="example">Concatenate all the columns of file2.txt and file4.txt horizontally</font>
				Print the columns of one file next to the columns of the previous one, using a space as separator between the columns of one file and the other.
				</p>

				<p><font class="bashcommand">
				$ paste -d ' ' file2.txt file4.txt<br>
				<font class="bashcommand-result">
				"AnonymizedID" "SubjectGroup" "TEST1" "TEST2" AnonymizedID SubjectGroup AGE<br>
				B11108399 Group1 23b" "900" "MissingData" B11108326 Group1 59<br>
				"B11137244" "Group1" "450" "555" B11110893 Group1 28<br>
				"B11154534" "Group1" "456" "456" B11119909 Group2 61<br>
				"B11144100" "Group1" "450" "886" D11144030 Group3 11<br>
				"B11137244" "Group1" "450" "456" D11144030 Group3 13<br>
				"B12226566" "Group2b" "450" "MissingData" B11119903 Group2 84<br>
				"B11134987" "Group1" "900" "MissingData" C11131039 Group2 67<br>
				"B11144345" "Group1" "900" "776" C11133100 Group1 23<br>
				"C11137159" "Group3" "MissingData" "MissingData" C11135566 Group2 72<br>
				"B11156453" "Group4" "456" "2" C11137159 Group3 11<br>
				"B11110676" "Group1" "900" "10" C11137159 Group3 12<br>
				"C11138929" "Group2b" "2" "MissingData" C11137167 Group3 14<br>
				"B11154532" "Group1" "456" "886" C11137167 Group3 16<br>
				"B11155267" "Group3" "900" "10" C11137439 Group3 15<br>
				"B11137120" "Group2b" "450" "456" C11137439 Group3 79<br>
				"B33191224" "Group2b" "450" "776" C11137443 Group3 15<br>
				"B11155267" "Group3" "900" "10" C11137544 Group1 22<br>
				"C11138999" "Group2b" "900" "MissingData" C11137123 Group2 68<br>
				"B11131605" "Group1" "456" "MissingData" C11138150 Group1 44<br>
				"B11137784" "Group1" "900" "436" C11138152 Group1 10<br>
				"B11156098" "Group1" "500" "886" C11138797 Group1 24<br>
				"B11133232" "Group1" "500" "MissingData" C11138184 Group1 57<br>
				"B11135292" "Group3" "MissingData" "MissingData" C11138122 Group1 23<br>
				"C11138912" "Group2b" "900" "MissingData" C11138122 MISSING 25<br>
				"B11150911" "Group2b" "900" "117" C11138192 Group1 45<br>
				"B11152577" "Group1" "900" "756" B12226507 Group1 26<br>
				"B11156098" "Group1" "456" "886" B12226546 Group1 55<br>
				"B11133232" "Group1" "456" "MissingData" 
				</font>
				</font></p>

				<p>
				<font class="example">Concatenate all the columns of file2.txt and file4.txt horizontally.</font>
				Use a semicolon (<font class="bashcommand">;</font>) as separator between the columns of one file and the other.
				</p>

				<p><font class="bashcommand">
				$ paste -d ';' file2.txt file4.txt<br>
				<font class="bashcommand-result">
				"AnonymizedID" "SubjectGroup" "TEST1" "TEST2";AnonymizedID SubjectGroup AGE<br>
				B11108399 Group1 23b" "900" "MissingData";B11108326 Group1 59<br>
				"B11137244" "Group1" "450" "555";B11110893 Group1 28<br>
				"B11154534" "Group1" "456" "456";B11119909 Group2 61<br>
				"B11144100" "Group1" "450" "886";D11144030 Group3 11<br>
				"B11137244" "Group1" "450" "456";D11144030 Group3 13<br>
				"B12226566" "Group2b" "450" "MissingData";B11119903 Group2 84<br>
				"B11134987" "Group1" "900" "MissingData";C11131039 Group2 67<br>
				"B11144345" "Group1" "900" "776";C11133100 Group1 23<br>
				"C11137159" "Group3" "MissingData" "MissingData";C11135566 Group2 72<br>
				"B11156453" "Group4" "456" "2";C11137159 Group3 11<br>
				"B11110676" "Group1" "900" "10";C11137159 Group3 12<br>
				"C11138929" "Group2b" "2" "MissingData";C11137167 Group3 14<br>
				"B11154532" "Group1" "456" "886";C11137167 Group3 16<br>
				"B11155267" "Group3" "900" "10";C11137439 Group3 15<br>
				"B11137120" "Group2b" "450" "456";C11137439 Group3 79<br>
				"B33191224" "Group2b" "450" "776";C11137443 Group3 15<br>
				"B11155267" "Group3" "900" "10";C11137544 Group1 22<br>
				"C11138999" "Group2b" "900" "MissingData";C11137123 Group2 68<br>
				"B11131605" "Group1" "456" "MissingData";C11138150 Group1 44<br>
				"B11137784" "Group1" "900" "436";C11138152 Group1 10<br>
				"B11156098" "Group1" "500" "886";C11138797 Group1 24<br>
				"B11133232" "Group1" "500" "MissingData";C11138184 Group1 57<br>
				"B11135292" "Group3" "MissingData" "MissingData";C11138122 Group1 23<br>
				"C11138912" "Group2b" "900" "MissingData";C11138122 MISSING 25<br>
				"B11150911" "Group2b" "900" "117";C11138192 Group1 45<br>
				"B11152577" "Group1" "900" "756";B12226507 Group1 26<br>
				"B11156098" "Group1" "456" "886";B12226546 Group1 55<br>
				"B11133232" "Group1" "456" "MissingData"; 
				</font>
				</font></p>

				<p>
				<font class="example">Concatenate all the columns of file2.txt and file4.txt horizontally.</font>
				Use a tab (<font class="bashcommand">\t</font>) as separator between the columns of one file and the other.
				</p>

				<p><font class="bashcommand">
				$ paste -d '\t' file2.txt file4.txt<br>
				<font class="bashcommand-result">
				"AnonymizedID" "SubjectGroup" "TEST1" "TEST2"&emsp;AnonymizedID SubjectGroup AGE<br>
				"B11108399" "Group1" "23b" "900" "MissingData"&emsp;B11108326 Group1 59<br>
				"B11137244" "Group1" "450" "555"&emsp;B11110893 Group1 28<br>
				"B11154534" "Group1" "456" "456"&emsp;B11119909 Group2 61<br>
				"B11144100" "Group1" "450" "886"&emsp;D11144030 Group3 11<br>
				"B11137244" "Group1" "450" "456"&emsp;D11144030 Group3 13<br>
				"B12226566" "Group2b" "450" "MissingData"&emsp;B11119903 Group2 84<br>
				"B11134987" "Group1" "900" "MissingData"&emsp;C11131039 Group2 67<br>
				"B11144345" "Group1" "900" "776"&emsp;C11133100 Group1 23<br>
				"C11137159" "Group3" "MissingData" "MissingData"&emsp;C11135566 Group2 72<br>
				"B11156453" "Group4" "456" "2"&emsp;C11137159 Group3 11<br>
				"B11110676" "Group1" "900" "10"&emsp;C11137159 Group3 12<br>
				"C11138929" "Group2b" "2" "MissingData"&emsp;C11137167 Group3 14<br>
				"B11154532" "Group1" "456" "886"&emsp;C11137167 Group3 16<br>
				"B11155267" "Group3" "900" "10"&emsp;C11137439 Group3 15<br>
				"B11137120" "Group2b" "450" "456"&emsp;C11137439 Group3 79<br>
				"B33191224" "Group2b" "450" "776"&emsp;C11137443 Group3 15<br>
				"B11155267" "Group3" "900" "10"&emsp;C11137544 Group1 22<br>
				"C11138999" "Group2b" "900" "MissingData"&emsp;C11137123 Group2 68<br>
				"B11131605" "Group1" "456" "MissingData"&emsp;C11138150 Group1 44<br>
				"B11137784" "Group1" "900" "436"&emsp;C11138152 Group1 10<br>
				"B11156098" "Group1" "500" "886"&emsp;C11138797 Group1 24<br>
				"B11133232" "Group1" "500" "MissingData"&emsp;C11138184 Group1 57<br>
				"B11135292" "Group3" "MissingData" "MissingData"&emsp;C11138122 Group1 23<br>
				"C11138912" "Group2b" "900" "MissingData"&emsp;C11138122 MISSING 25<br>
				"B11150911" "Group2b" "900" "117"&emsp;C11138192 Group1 45<br>
				"B11152577" "Group1" "900" "756"&emsp;B12226507 Group1 26<br>
				"B11156098" "Group1" "456" "886"&emsp;B12226546 Group1 55<br>
				"B11133232" "Group1" "456" "MissingData" 
				</font>
				</font></p>

				<p>
				<font class="example">Concatenate all the columns of file2.txt and file4.txt horizontally</font>
				Use an empty string as separator between the columns of one file and the other.
				</p>

				<p><font class="bashcommand">
				$ paste -d '\0' file2.txt file4.txt<br>
				<font class="bashcommand-result">
				"AnonymizedID" "SubjectGroup" "TEST1" "TEST2"AnonymizedID SubjectGroup AGE<br>
				B11108399 Group1 23b" "900" "MissingData"B11108326 Group1 59<br>
				"B11137244" "Group1" "450" "555"B11110893 Group1 28<br>
				"B11154534" "Group1" "456" "456"B11119909 Group2 61<br>
				"B11144100" "Group1" "450" "886"D11144030 Group3 11<br>
				"B11137244" "Group1" "450" "456"D11144030 Group3 13<br>
				"B12226566" "Group2b" "450" "MissingData"B11119903 Group2 84<br>
				"B11134987" "Group1" "900" "MissingData"C11131039 Group2 67<br>
				"B11144345" "Group1" "900" "776"C11133100 Group1 23<br>
				"C11137159" "Group3" "MissingData" "MissingData"C11135566 Group2 72<br>
				"B11156453" "Group4" "456" "2"C11137159 Group3 11<br>
				"B11110676" "Group1" "900" "10"C11137159 Group3 12<br>
				"C11138929" "Group2b" "2" "MissingData"C11137167 Group3 14<br>
				"B11154532" "Group1" "456" "886"C11137167 Group3 16<br>
				"B11155267" "Group3" "900" "10"C11137439 Group3 15<br>
				"B11137120" "Group2b" "450" "456"C11137439 Group3 79<br>
				"B33191224" "Group2b" "450" "776"C11137443 Group3 15<br>
				"B11155267" "Group3" "900" "10"C11137544 Group1 22<br>
				"C11138999" "Group2b" "900" "MissingData"C11137123 Group2 68<br>
				"B11131605" "Group1" "456" "MissingData"C11138150 Group1 44<br>
				"B11137784" "Group1" "900" "436"C11138152 Group1 10<br>
				"B11156098" "Group1" "500" "886"C11138797 Group1 24<br>
				"B11133232" "Group1" "500" "MissingData"C11138184 Group1 57<br>
				"B11135292" "Group3" "MissingData" "MissingData"C11138122 Group1 23<br>
				"C11138912" "Group2b" "900" "MissingData"C11138122 MISSING 25<br>
				"B11150911" "Group2b" "900" "117"C11138192 Group1 45<br>
				"B11152577" "Group1" "900" "756"B12226507 Group1 26<br>
				"B11156098" "Group1" "456" "886"B12226546 Group1 55<br>
				"B11133232" "Group1" "456" "MissingData"
				</font>
				</font></p>

				<p>
				<font class="example">Concatenate all the columns of file2.txt and file4.txt horizontally</font>
				Use a backslash character (<font class="bashcommand">\</font>) as separator between the columns of one file and the other.
				</p>

				<p><font class="bashcommand">
				$ paste -d '\\' file2.txt file4.txt<br>
				<font class="bashcommand-result">
				"AnonymizedID" "SubjectGroup" "TEST1" "TEST2"\AnonymizedID SubjectGroup AGE<br>
				B11108399 Group1 23b" "900" "MissingData"\B11108326 Group1 59<br>
				"B11137244" "Group1" "450" "555"\B11110893 Group1 28<br>
				"B11154534" "Group1" "456" "456"\B11119909 Group2 61<br>
				"B11144100" "Group1" "450" "886"\D11144030 Group3 11<br>
				"B11137244" "Group1" "450" "456"\D11144030 Group3 13<br>
				"B12226566" "Group2b" "450" "MissingData"\B11119903 Group2 84<br>
				"B11134987" "Group1" "900" "MissingData"\C11131039 Group2 67<br>
				"B11144345" "Group1" "900" "776"\C11133100 Group1 23<br>
				"C11137159" "Group3" "MissingData" "MissingData"\C11135566 Group2 72<br>
				"B11156453" "Group4" "456" "2"\C11137159 Group3 11<br>
				"B11110676" "Group1" "900" "10"\C11137159 Group3 12<br>
				"C11138929" "Group2b" "2" "MissingData"\C11137167 Group3 14<br>
				"B11154532" "Group1" "456" "886"\C11137167 Group3 16<br>
				"B11155267" "Group3" "900" "10"\C11137439 Group3 15<br>
				"B11137120" "Group2b" "450" "456"\C11137439 Group3 79<br>
				"B33191224" "Group2b" "450" "776"\C11137443 Group3 15<br>
				"B11155267" "Group3" "900" "10"\C11137544 Group1 22<br>
				"C11138999" "Group2b" "900" "MissingData"\C11137123 Group2 68<br>
				"B11131605" "Group1" "456" "MissingData"\C11138150 Group1 44<br>
				"B11137784" "Group1" "900" "436"\C11138152 Group1 10<br>
				"B11156098" "Group1" "500" "886"\C11138797 Group1 24<br>
				"B11133232" "Group1" "500" "MissingData"\C11138184 Group1 57<br>
				"B11135292" "Group3" "MissingData" "MissingData"\C11138122 Group1 23<br>
				"C11138912" "Group2b" "900" "MissingData"\C11138122 MISSING 25<br>
				"B11150911" "Group2b" "900" "117"\C11138192 Group1 45<br>
				"B11152577" "Group1" "900" "756"\B12226507 Group1 26<br>
				"B11156098" "Group1" "456" "886"\B12226546 Group1 55<br>
				"B11133232" "Group1" "456" "MissingData"\ 
				</font>
				</font></p>

				<p>
				<font class="example">Concatenate all the columns of file2.txt and file4.txt</font>
				Use a newline character (<font class="bashcommand">\n</font>) as separator between the columns of one file and the other. As a result, the two files will be interlined. In the output you will have the first line of file2.txt followed by the first line of file4.txt, followed by the second line of file2.txt, then the second line of file4.txt. etc.
				</p>

				<p><font class="bashcommand">
				$ paste -d '\n' file2.txt file4.txt<br>
				<font class="bashcommand-result">
				"AnonymizedID" "SubjectGroup" "TEST1" "TEST2"<br>
				AnonymizedID SubjectGroup AGE<br>
				"B11130912" "Group2b" "900" "MissingData"<br>
				B11108399 Group1 23<br>
				"B11137244" "Group1" "450" "555"<br>
				B11110893 Group1 28<br>
				"B11154534" "Group1" "456" "456"<br>
				B11119909 Group2 61<br>
				"B11144100" "Group1" "450" "886"<br>
				D11144030 Group3 11<br>
				"B11137244" "Group1" "450" "456"<br>
				D11144030 Group3 13<br>
				"B12226566" "Group2b" "450" "MissingData"<br>
				B11119903 Group2 84<br>
				"B11134987" "Group1" "900" "MissingData"<br>
				C11131039 Group2 67<br>
				"B11144345" "Group1" "900" "776"<br>
				C11133100 Group1 23<br>
				"C11137159" "Group3" "MissingData" "MissingData"<br>
				C11135566 Group2 72<br>
				"B11156453" "Group4" "456" "2"<br>
				C11137159 Group3 11<br>
				"B11110676" "Group1" "900" "10"<br>
				C11137159 Group3 12<br>
				"C11138929" "Group2b" "2" "MissingData"<br>
				C11137167 Group3 14<br>
				"B11154532" "Group1" "456" "886"<br>
				C11137167 Group3 16<br>
				"B11155267" "Group3" "900" "10"<br>
				C11137439 Group3 15<br>
				"B11137120" "Group2b" "450" "456"<br>
				C11137439 Group3 79<br>
				"B33191224" "Group2b" "450" "776"<br>
				C11137443 Group3 15<br>
				"B11155267" "Group3" "900" "10"<br>
				C11137544 Group1 22<br>
				"C11138999" "Group2b" "900" "MissingData"<br>
				C11137123 Group2 68<br>
				"B11131605" "Group1" "456" "MissingData"<br>
				C11138150 Group1 44<br>
				"B11137784" "Group1" "900" "436"<br>
				C11138152 Group1 10<br>
				"B11156098" "Group1" "500" "886"<br>
				C11138797 Group1 24<br>
				"B11133232" "Group1" "500" "MissingData"<br>
				C11138184 Group1 57<br>
				"B11135292" "Group3" "MissingData" "MissingData"<br>
				C11138122 Group1 23<br>
				"C11138912" "Group2b" "900" "MissingData"<br>
				C11138122 MISSING 25<br>
				"B11150911" "Group2b" "900" "117"<br>
				C11138192 Group1 45<br>
				"B11152577" "Group1" "900" "756"<br>
				B12226507 Group1 26<br>
				"B11156098" "Group1" "456" "886"<br>
				B12226546 Group1 55<br>
				"B11133232" "Group1" "456" "MissingData"
				</font>
				</font></p>

				<p>
				<font class="example">Concatenate all the columns of file1.csv and file3.csv horizontally</font>
				Use a comma as separator between the columns of one file and the other.
				</p>

				<p><font class="bashcommand">
				$ paste -d ' ' test1.csv test2.csv test6.csv<br>
				<font class="bashcommand-result">
				"Anonymized ID","Subject Group","HASCONDITION","CONDITION",Anonymized ID,Subject Group,AGE<br>
				"B33199522","Group1","0","",C11138122,MISSING,21<br>
				"B33199603","Group3","0","",C11138192,Group1,54<br>
				"B11137879","Group1","0","",B12226507,Group1,68<br>
				"B11144410","Group2 b","0","",B12226546,Group1,67<br>
				"B11110455","Group2 b","0","",C11138122,Group1,24<br>
				"B11135291","Group3","0","",C11138184,Group1,59<br>
				"B11153927","Group1","0","",C11138797,Group1,22<br>
				"B11177579","Group2 b","0","",C11138152,Group1,53<br>
				"B11177806","Group1","MD","",C11138150,Group1,41<br>
				"B11157958","Group3","0","",C11137167,Group3,14<br>
				"B11110690","Group3","0","",C11137159,Group3,13<br>
				"B11152799","Group1","0","",C11137167,Group3,16<br>
				"B11154358","Group1","0","",C11137159,Group3,13<br>
				"B11110925","Group1","0","",C11131039,Group2 b,67<br>
				"B11135291","Group3","9","mTBI",C11135566,Group2 b,73<br>
				"B11135072","MISSING","0","",B11119903,Group2 b,83<br>
				"B33199603","Group3","0","",C11137544,Group1,21<br>
				"B11137879","Group1","0","",C11137443,Group3,11<br>
				"B11110603","Group1","0","",C11137123,Group2 b,69<br>
				"B11110927","Group1","0","",C11137439,Group3,79<br>
				"B11147712","Group1","0","",C11137439,Group3,15<br>
				"B33191224","Group2 b","0","",C11133100,Group1,23<br>
				"B11131290","Group2 b","0","",D11144030,Group3,13<br>
				"B11157974","Group1","0","",B11108399,Group1,23<br>
				"B33191224","Group2 b","0","",B11108326,Group1,59<br>
				"B11141503","Group3","0","",B11119909,Group2 b,61<br>
				"C11137159","Group3","9","mTBI",B11110893,Group1,28<br>
				"B33199522","Group1","0","",
				</font>
				</font></p>

				<h3>9.10. Examples: Reading specific columns from multiple files and concatenating them horizontally (in different columns).</h3>

				<p>
				<font class="example">Print the first column of file2.txt followed (horizontally) by the second column of file4.txt.</font>
				As we learned in previous examples, the command <font class="bashcommand">awk '{print $1}' file2.txt</font> will read and print the first column of file2.txt. Conversely, <font class="bashcommand">awk '{print $2}' file4.txt</font> will read and print the second column of file4.txt.<br>
				You must use the following syntax to concatenate these two results horizontally:
				</p>

				<p><font class="bashcommand">
				$ paste <(awk '{print $1}' file2.txt) <(awk '{print $2}' file4.txt)<br>
				<font class="bashcommand-result">
				"AnonymizedID"&emsp;SubjectGroup<br>
				"B11130912"&emsp;Group1<br>
				"B11137244"&emsp;Group1<br>
				"B11154534"&emsp;Group2<br>
				"B11144100"&emsp;Group3<br>
				"B11137244"&emsp;Group3<br>
				"B12226566"&emsp;Group2<br>
				"B11134987"&emsp;Group2<br>
				"B11144345"&emsp;Group1<br>
				"C11137159"&emsp;Group2<br>
				"B11156453"&emsp;Group3<br>
				"B11110676"&emsp;Group3<br>
				"C11138929"&emsp;Group3<br>
				"B11154532"&emsp;Group3<br>
				"B11155267"&emsp;Group3<br>
				"B11137120"&emsp;Group3<br>
				"B33191224"&emsp;Group3<br>
				"B11155267"&emsp;Group1<br>
				"C11138999"&emsp;Group2<br>
				"B11131605"&emsp;Group1<br>
				"B11137784"&emsp;Group1<br>
				"B11156098"&emsp;Group1<br>
				"B11133232"&emsp;Group1<br>
				"B11135292"&emsp;Group1<br>
				"C11138912"&emsp;MISSING<br>
				"B11150911"&emsp;Group1<br>
				"B11152577"&emsp;Group1<br>
				"B11156098"&emsp;Group1<br>
				"B11133232" 	
				</font>
				</font></p>

				<p>
				<font class="example">Print the first column of file1.csv followed (horizontally) by the second column of file3.csv. Separate the columns with a comma.</font>
				In this example, we use the same syntax as the example before, but remember that files file1.csv and file3.csv use comma as the column separator and you have to use the <font class="bashcommand">-F','</font> flag in the <font class="bashcommand">awk</font> commands. Additionally, remember to use the flag <font class="bashcommand">-d ','</font> for the paste command in order to separate the pasted columns with a comma.
				</p>

				<p><font class="bashcommand">
				$ paste -d ',' <(awk -F',' '{print $1}' file1.csv) <(awk -F',' '{print $2}' file3.csv)<br>
				<font class="bashcommand-result">
				"Anonymized ID",Subject Group<br>
				"B33199522",MISSING<br>
				"B33199603",Group1<br>
				"B11137879",Group1<br>
				"B11144410",Group1<br>
				"B11110455",Group1<br>
				"B11135291",Group1<br>
				"B11153927",Group1<br>
				"B11177579",Group1<br>
				"B11177806",Group1<br>
				"B11157958",Group3<br>
				"B11110690",Group3<br>
				"B11152799",Group3<br>
				"B11154358",Group3<br>
				"B11110925",Group2 b<br>
				"B11135291",Group2 b<br>
				"B11135072",Group2 b<br>
				"B33199603",Group1<br>
				"B11137879",Group3<br>
				"B11110603",Group2 b<br>
				"B11110927",Group3<br>
				"B11147712",Group3<br>
				"B33191224",Group1<br>
				"B11131290",Group3<br>
				"B11157974",Group1<br>
				"B33191224",Group1<br>
				"B11141503",Group2 b<br>
				"C11137159",Group1<br>
				"B33199522",
				</font>
				</font></p>

				<h3>9.11. Reading specific lines from one or more files.</h3>

				<p>
				<font class="example">Print the <b>first</b> line of file1.csv</font>
				In order to print the first line of the file we first read it using the <font class="bashcommand">cat</font> command, and then we select the first line from the previous output using <font class="bashcommand">head -n 1</font>.
				</p>

				<p><font class="bashcommand">
				$ cat file1.csv | head -n 1<br>
				<font class="bashcommand-result">
				"Anonymized ID","Subject Group","HASCONDITION","CONDITION" 
				</font>
				</font></p>

				<p>
				<font class="example">Print the <b>first two</b> lines of file1.csv</font>
				In order to print the first two lines of the file we first read it using the <font class="bashcommand">cat</font> command, and then we select those lines from the previous output using <font class="bashcommand">head -n 2</font>.
				</p>

				<p><font class="bashcommand">
				$ cat file1.csv | head -n 2<br>
				<font class="bashcommand-result">
				"Anonymized ID","Subject Group","HASCONDITION","CONDITION"<br>
				"B33199522","Group1","0","" 
				</font>
				</font></p>

				<font class="example">Print the <b>first three</b> lines of file1.csv</font>

				<p><font class="bashcommand">
				$ cat file1.csv | head -n 3<br>
				<font class="bashcommand-result">
				"Anonymized ID","Subject Group","HASCONDITION","CONDITION"<br>
				"B33199522","Group1","0",""<br>
				"B33199603","Group3","0","" 
				</font>
				</font></p>

				<p>
				<font class="example">Print the <b>last</b> line of file1.csv</font>
				In order to print the last line of the file we first read it using the <font class="bashcommand">cat</font> command, and then we select the last line from the previous output using <font class="bashcommand">tail -n 1</font>. 
				</p>

				<p><font class="bashcommand">
				$ cat file1.csv | tail -n 1<br>
				<font class="bashcommand-result">
				"B33199522","Group1","0","" 
				</font>
				</font></p>
			
				<font class="example">Print the <b>last two</b> lines of file1.csv</font>

				<p><font class="bashcommand">
				$ cat file1.csv | tail -n 2<br>
				<font class="bashcommand-result">
				"C11137159","Group3","9","mTBI"<br>
				"B33199522","Group1","0","" 
				</font>
				</font></p>

				<font class="example">Print the <b>last three</b> lines of file1.csv</font>

				<p><font class="bashcommand">
				$ cat file1.csv | tail -n 3<br>
				<font class="bashcommand-result">
				"B11141503","Group3","0",""<br>
				"C11137159","Group3","9","mTBI"<br>
				"B33199522","Group1","0",""
				</font>
				</font></p>

				<p>
				<font class="example">Print the <b>last three</b> lines of file1.csv in <b>reverse</b></font>
				As we learned previously, the flag <font class="bashcommand">-r</font> of <font class="bashcommand">tail</font> command can be used to print things in reversed order. 
				</p>

				<p><font class="bashcommand">
				$ cat file1.csv | tail -r -n 3<br>
				<font class="bashcommand-result">
				"B33199522","Group1","0",""<br>
				"C11137159","Group3","9","mTBI"<br>
				"B11141503","Group3","0","" 
				</font>
				</font></p>

				<font class="example">Print <b>from the beginning until the second line</b> of file1.csv (same result as printing the first two lines)</font>
				
				<p><font class="bashcommand">
				$ cat file1.csv | head -n+2<br>
				<font class="bashcommand-result">
				"Anonymized ID","Subject Group","HASCONDITION","CONDITION"<br>
				"B33199522","Group1","0","" 
				</font>
				</font></p>

				<font class="example">Print <b>from the beginning until the third line</b> of file1.csv (same result as printing the first three lines)</font>

				<p><font class="bashcommand">
				$ cat file1.csv | head -n+3<br>
				<font class="bashcommand-result">
				"Anonymized ID","Subject Group","HASCONDITION","CONDITION"<br>
				"B33199522","Group1","0",""<br>
				"B33199603","Group3","0","" 
				</font>
				</font></p>
					
				<font class="example">Print <b>from the second line until the last line</b> of file1.csv</font>

				<p><font class="bashcommand">
				$ cat file1.csv | tail -n+2<br>
				<font class="bashcommand-result">
				"B33199522","Group1","0",""<br>
				"B33199603","Group3","0",""<br>
				"B11137879","Group1","0",""<br>
				"B11144410","Group2 b","0",""<br>
				"B11110455","Group2 b","0",""<br>
				"B11135291","Group3","0",""<br>
				"B11153927","Group1","0",""<br>
				"B11177579","Group2 b","0",""<br>
				"B11177806","Group1","MD",""<br>
				"B11157958","Group3","0",""<br>
				"B11110690","Group3","0",""<br>
				"B11152799","Group1","0",""<br>
				"B11154358","Group1","0",""<br>
				"B11110925","Group1","0",""<br>
				"B11135291","Group3","9","mTBI"<br>
				"B11135072","MISSING","0",""<br>
				"B33199603","Group3","0",""<br>
				"B11137879","Group1","0",""<br>
				"B11110603","Group1","0",""<br>
				"B11110927","Group1","0",""<br>
				"B11147712","Group1","0",""<br>
				"B33191224","Group2 b","0",""<br>
				"B11131290","Group2 b","0",""<br>
				"B11157974","Group1","0",""<br>
				"B33191224","Group2 b","0",""<br>
				"B11141503","Group3","0",""<br>
				"C11137159","Group3","9","mTBI"<br>
				"B33199522","Group1","0","" 
				</font>
				</font></p>

				<font class="example">Print <b>from the third line until the last line</b> of file1.csv</font>

				<p><font class="bashcommand">
				$ cat file1.csv | tail -n+3<br>
				<font class="bashcommand-result">
				"B33199603","Group3","0",""<br>
				"B11137879","Group1","0",""<br>
				"B11144410","Group2 b","0",""<br>
				"B11110455","Group2 b","0",""<br>
				"B11135291","Group3","0",""<br>
				"B11153927","Group1","0",""<br>
				"B11177579","Group2 b","0",""<br>
				"B11177806","Group1","MD",""<br>
				"B11157958","Group3","0",""<br>
				"B11110690","Group3","0",""<br>
				"B11152799","Group1","0",""<br>
				"B11154358","Group1","0",""<br>
				"B11110925","Group1","0",""<br>
				"B11135291","Group3","9","mTBI"<br>
				"B11135072","MISSING","0",""<br>
				"B33199603","Group3","0",""<br>
				"B11137879","Group1","0",""<br>
				"B11110603","Group1","0",""<br>
				"B11110927","Group1","0",""<br>
				"B11147712","Group1","0",""<br>
				"B33191224","Group2 b","0",""<br>
				"B11131290","Group2 b","0",""<br>
				"B11157974","Group1","0",""<br>
				"B33191224","Group2 b","0",""<br>
				"B11141503","Group3","0",""<br>
				"C11137159","Group3","9","mTBI"<br>
				"B33199522","Group1","0","" 
				</font>
				</font></p>

				<h3>9.12. Examples: Reading specific columns or lines in a file or a list of files, that contain a searched value</h3>

				<font class="example">Print the line(s) of file3.csv that contain the string C11137439</font>

				<p>
				Using <font class="bashcommand">awk</font>:<br>
				<font class="bashcommand">
				$ awk '/C11137439/' file3.csv<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15 
				</font>
				</font>
				</p>

				<p>
				Using <font class="bashcommand">grep</font>:<br>
				<font class="bashcommand">
				$ grep C11137439 file3.csv<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15 
				</font>
				</font>
				</p>

				<p>
				<font class="example">Print the line(s) of file3.csv that contain the string AAA (which is <b>stored in a variable</b>)</font>
				<font class="bashcommand">$ VAR=C11137439</font>
				</p>

				<p>
				Using <font class="bashcommand">awk</font>:<br>
				<font class="bashcommand">
				$ awk -v var=$VAR '$0~var' file3.csv<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15 
				</font>
				</font>
				</p>

				<p>
				Using <font class="bashcommand">grep</font>:<br>
				<font class="bashcommand">
				$ grep $VAR file3.csv<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15 
				</font>
				</font>
				</p>

				<p>
				<font class="example">Print the line(s) of file3.csv that contain the strings C11137439 <b>or</b> B11119909</font>
				To search for more than one expression, add the flag <font class="bashcommand">-e</font> in front of each expression.
				</p>

				<p><font class="bashcommand">
				$ grep -e "C11137439" -e "B11119909" file3.csv<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				B11119909,Group2 b,61 
				</font>
				</font></p>

				<font class="example">Print the line(s) of file3.csv that contain the strings C11137439, B11119909 or B11110893</font>

				<p><font class="bashcommand">
				$ grep -e "C11137439" -e "B11119909" -e "B11110893" file3.csv<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				B11119909,Group2 b,61<br>
				B11110893,Group1,28 
				</font>
				</font></p>

				<font class="example">Print the line(s) of file3.csv that contain the strings C11137439 or B11119909 (which are <b>stored in a file</b> called patterns.txt)</font>

				<p><font class="bashcommand">
				$ cat patterns.txt<br>
				<font class="bashcommand-result">
				C11137439<br>
				B11119909 
				</font>
				</font></p>

				<p><font class="bashcommand">
				$ grep -f patterns.txt file3.csv<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				B11119909,Group2 b,61 
				</font>
				</font></p>

				<font class="example">Print the line(s) of file3.csv that <b>do not contain</b> the string C11137439</font>

				<p><font class="bashcommand">
				$ grep -v "C11137439" file3.csv<br>
				<font class="bashcommand-result">
				Anonymized ID,Subject Group,AGE<br>
				C11138122,MISSING,21<br>
				C11138192,Group1,54<br>
				B12226507,Group1,68<br>
				B12226546,Group1,67<br>
				C11138122,Group1,24<br>
				C11138184,Group1,59<br>
				C11138797,Group1,22<br>
				C11138152,Group1,53<br>
				C11138150,Group1,41<br>
				C11137167,Group3,14<br>
				C11137159,Group3,13<br>
				C11137167,Group3,16<br>
				C11137159,Group3,13<br>
				C11131039,Group2 b,67<br>
				C11135566,Group2 b,73<br>
				B11119903,Group2 b,83<br>
				C11137544,Group1,21<br>
				C11137443,Group3,11<br>
				C11137123,Group2 b,69<br>
				C11133100,Group1,23<br>
				D11144030,Group3,13<br>
				B11108399,Group1,23<br>
				B11108326,Group1,59<br>
				B11119909,Group2 b,61<br>
				B11110893,Group1,28 
				</font>
				</font></p>

				<font class="example">Print the line(s) of any file in the current directory that contain the string C11137439</font>

				<p><font class="bashcommand">
				$ awk '/C11137439/' *<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				C11137439 Group3 15<br>
				C11137439 Group3 79<br>
				C11137439 
				</font>
				</font></p>

				<p><font class="bashcommand">
				$ grep C11137439 *<br>
				<font class="bashcommand-result">
				file3.csv:C11137439,Group3,79<br>
				file3.csv:C11137439,Group3,15<br>
				file4.txt:C11137439 Group3 15<br>
				file4.txt:C11137439 Group3 79<br>
				patterns.txt:C11137439 
				</font>
				</font></p>

				<p>
				To omit the file names in the grep option, use the flag <font class="bashcommand">-h</font>:<br> 
				<font class="bashcommand">
				$ grep -h C11137439 *<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				C11137439 Group3 15<br>
				C11137439 Group3 79<br>
				C11137439 
				</font>
				</font>
				</p>

				<p>
				If you wanted to include the line number for each match, you can add the flag <font class="bashcommand">-n</font>:<br>
				<font class="bashcommand">
				$ grep -n "C11137439" *<br>
				<font class="bashcommand-result">
				file3.csv:21:C11137439,Group3,79<br>
				file3.csv:22:C11137439,Group3,15<br>
				file4.txt:15:C11137439 Group3 15<br>
				file4.txt:16:C11137439 Group3 79<br>
				patterns.txt:1:C11137439 
				</font>
				</font>
				</p>

				<p><font class="bashcommand">
				$ grep -h -n "C11137439" *<br>
				<font class="bashcommand-result">
				<b>21</b>:C11137439,Group3,79<br>
				<b>22</b>:C11137439,Group3,15<br>
				<b>15</b>:C11137439 Group3 15<br>
				<b>16</b>:C11137439 Group3 79<br>
				<b>1</b>:C11137439 
				</font>
				</font></p>

				<p>
				If you want to show only the first three matches, you can add the flag <font class="bashcommand">-m</font> with the parameter <font class="bashcommand">3</font> (to print only three lines):<br>
				<font class="bashcommand">
				$ grep -m 3 "C11137439" *<br>
				<font class="bashcommand-result">
				file3.csv:C11137439,Group3,79<br>
				file3.csv:C11137439,Group3,15<br>
				file4.txt:C11137439 Group3 15 
				</font>
				</font>
				</p>

				<p><font class="bashcommand">
				$ grep -m 3 "C11137439" * -h<br>
				<font class="bashcommand-result">
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				C11137439 Group3 15 
				</font>
				</font></p>

				<font class="example">Print the number of lines in each file of the current directory that contain the string C11137439.</font>

				<p><font class="bashcommand">
				$ grep -c "C11137439" *<br>
				<font class="bashcommand-result">
				file1.csv:0<br>
				file1_reordered.csv:0<br>
				file2.txt:0<br>
				file3.csv:2<br>
				file4.txt:2<br>
				patterns.txt:1<br>
				patterns2.txt:0
				</font>
				</font></p>

				<font class="example">Print only the name of the files in the current directory that contain the string C11137439.</font>

				<p><font class="bashcommand">
				$ grep -l "C11137439" *<br>
				<font class="bashcommand-result">
				file3.csv<br>
				file4.txt<br>
				patterns.txt 
				</font>
				</font></p>

				<font class="example">Print the line(s) of any file in the current directory that contain the string C11137439, each line followed by the next three lines in the corresponding file (if there is three or more lines after the matched one).</font>
				
				<p><font class="bashcommand">
				$ grep -A 3 "C11137439" *<br>
				<font class="bashcommand-result">
				<b>file3.csv:C11137439,Group3,79<br>
				file3.csv:C11137439,Group3,15</b><br>
				file3.csv-C11133100,Group1,23<br>
				file3.csv-D11144030,Group3,13<br>
				file3.csv-B11108399,Group1,23<br> 
				<b>--<br>
				file4.txt:C11137439 Group3 15<br>
				file4.txt:C11137439 Group3 79</b><br>
				file4.txt-C11137443 Group3 15<br>
				file4.txt-C11137544 Group1 22<br>
				file4.txt-C11137123 Group2 68<br>
				<b>--<br>
				patterns.txt:C11137439</b><br>
				patterns.txt-B11119909 
				</font>
				</font></p>

				<font class="example">Print the line(s) of any file in the current directory that contain the string C11137439, each line preceded by the previous three lines in the corresponding file (if there is three or more lines before the matched one).</font>

				<p><font class="bashcommand">
				$ grep -B 3 "C11137439" *<br>
				<font class="bashcommand-result">
				file3.csv-C11137544,Group1,21<br>
				file3.csv-C11137443,Group3,11<br>
				file3.csv-C11137123,Group2 b,69<br>
				<b>file3.csv:C11137439,Group3,79<br>
				file3.csv:C11137439,Group3,15</b><br>
				--<br>
				file4.txt-C11137159 Group3 12<br>
				file4.txt-C11137167 Group3 14<br>
				file4.txt-C11137167 Group3 16<br>
				<b>file4.txt:C11137439 Group3 15<br> 
				file4.txt:C11137439 Group3 79</b><br>
				--<br>
				<b>patterns.txt:C11137439</b>
				</font>
				</font></p>

				<font class="example">Print the line(s) of any file in the current directory that contain the string C11137439, each line preceded by the previous three lines and followed by the next three lines in the corresponding file (if there is three or more lines before/after the matched one).</font>

				<p><font class="bashcommand">
				$ grep -C 3 "C11137439" *<br>
				<font class="bashcommand-result">
				file3.csv-C11137544,Group1,21<br>
				file3.csv-C11137443,Group3,11<br>
				file3.csv-C11137123,Group2 b,69<br>
				<b>file3.csv:C11137439,Group3,79<br>
				file3.csv:C11137439,Group3,15</b><br>
				file3.csv-C11133100,Group1,23<br>
				file3.csv-D11144030,Group3,13<br>
				file3.csv-B11108399,Group1,23<br>
				--<br>
				--<br>
				file4.txt-C11137159 Group3 12<br>
				file4.txt-C11137167 Group3 14<br>
				file4.txt-C11137167 Group3 16<br>
				<b>file4.txt:C11137439 Group3 15<br>
				file4.txt:C11137439 Group3 79</b><br>
				file4.txt-C11137443 Group3 15<br>
				file4.txt-C11137544 Group1 22<br>
				file4.txt-C11137123 Group2 68<br>
				--<br>
				--<br>
				<b>patterns.txt:C11137439</b><br>
				patterns.txt-B11119909 
				</font>
				</font></p>

				<p><font class="bashcommand">
				$ grep -A 3 -B 3 "C11137439" *<br>
				<font class="bashcommand-result">
				file3.csv-C11137544,Group1,21<br>
				file3.csv-C11137443,Group3,11<br>
				file3.csv-C11137123,Group2 b,69<br>
				<b>file3.csv:C11137439,Group3,79<br>
				file3.csv:C11137439,Group3,15</b><br>
				file3.csv-C11133100,Group1,23<br>
				file3.csv-D11144030,Group3,13<br>
				file3.csv-B11108399,Group1,23<br>
				--<br>
				--<br>
				file4.txt-C11137159 Group3 12<br>
				file4.txt-C11137167 Group3 14<br>
				file4.txt-C11137167 Group3 16<br>
				<b>file4.txt:C11137439 Group3 15<br>
				file4.txt:C11137439 Group3 79</b><br>
				file4.txt-C11137443 Group3 15<br>
				file4.txt-C11137544 Group1 22<br>
				file4.txt-C11137123 Group2 68<br>
				--<br>
				--<br>
				<b>patterns.txt:C11137439</b><br>
				patterns.txt-B11119909 
				</font>
				</font></p>

				<font class="example">Print the line(s) of any file in the current directory that contain the string "B11133232" (including the quotation marks ").</font>

				<p><font class="bashcommand">
				$ awk '/"B11133232"/' *<br>
				<font class="bashcommand-result">
				"B11133232" "Group1" "500" "MissingData"<br>
				"B11133232" "Group1" "456" "MissingData" 
				</font>
				</font></p>

				<p><font class="bashcommand">
				$ grep \"B11133232\" *<br>
				<font class="bashcommand-result"> 
				file2.txt:"B11133232" "Group1" "500" "MissingData"<br>
				file2.txt:"B11133232" "Group1" "456" "MissingData" 
				</font>
				</font></p>

				<p>With the <font class="bashcommand">grep</font> command, you must include the backslash (<font class="bashcommand">\</font>) before the quotation marks (<font class="bashcommand">\"</font>) if you want to search only those lines that contain the string that includes the quotation marks. Otherwise, it will interpret the search value as <font class="bashcommand">B11133232</font> and not <font class="bashcommand">"B11133232"</font>.</p>
		    
				<p>
				<font class="example">Print the line(s) of file3.csv that contain the values B11108399 or B11108326.</font>
				This search has the following rules: We're looking for words that start with the following seven characters: <font class="bashcommand">B111083</font>, the 8<sup>th</sup> character can be a <font class="bashcommand">9</font> or a <font class="bashcommand">2</font>, and the last character can be a <font class="bashcommand">9</font> or a <font class="bashcommand">6</font>. So, in the <font class="bashcommand">grep</font> command, we replace the 8<sup>th</sup> character by <font class="bashcommand">[92]</font> to indicate that it can have any of those two values, and the last character by <font class="bashcommand">[96]</font> to indicate that it can have value <font class="bashcommand">9</font> or <font class="bashcommand">6</font>.
				</p>

				<p><font class="bashcommand">
				$ grep B111083[92][96] file3.csv<br>
				<font class="bashcommand-result">
				B11108399,Group1,23<br>
				B11108326,Group1,59 
				</font>
				</font></p>

				<font class="example">Print the line(s) of file3.csv that contain the values <font class="bashcommand">Group1</font> or <font class="bashcommand">Group2</font>.</font>

				<p><font class="bashcommand">
				$ grep Group[12] file3.csv<br>
				<font class="bashcommand-result">
				C11138192,Group1,54<br>
				B12226507,Group1,68<br>
				B12226546,Group1,67<br>
				C11138122,Group1,24<br>
				C11138184,Group1,59<br>
				C11138797,Group1,22<br>
				C11138152,Group1,53<br>
				C11138150,Group1,41<br>
				C11131039,Group2 b,67<br>
				C11135566,Group2 b,73<br>
				B11119903,Group2 b,83<br>
				C11137544,Group1,21<br>
				C11137123,Group2 b,69<br>
				C11133100,Group1,23<br>
				B11108399,Group1,23<br>
				B11108326,Group1,59<br>
				B11119909,Group2 b,61<br>
				B11110893,Group1,28 
				</font>
				</font></p>

				<p>With the <font class="bashcommand">grep</font> command, you must include the backslash (<font class="bashcommand">\</font>) before the quotation marks (<font class="bashcommand">\"</font>) if you want to search only those lines that contain the string that includes the quotation marks. Otherwise, it will interpret the search value as <font class="bashcommand">B11133232</font> and not <font class="bashcommand">"B11133232"</font>.</p>
		    
				<p>
				<font class="example">Print the first column of file2.txt and file3.csv for those lines that contain the values <font class="bashcommand">Group1</font> or <font class="bashcommand">Group2</font>.</font>
				Remember that you have to use the flag <font class="bashcommand">-F','</font> with the command <font class="bashcommand">awk</font> when the columns of the file are separated by commas and not spaces. 
				</p>

				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ grep Group[12] file2.txt | awk '{print $1}'<br>
						<font class="bashcommand-result">
						"B11130912"<br>
						"B11137244"<br>
						"B11154534"<br>
						"B11144100"<br>
						"B11137244"<br>
						"B12226566"<br>
						"B11134987"<br>
						"B11144345"<br>
						"B11110676"<br>
						"C11138929"<br>
						"B11154532"<br>
						"B11137120"<br>
						"B33191224"<br>
						"C11138999"<br>
						"B11131605"<br>
						"B11137784"<br>
						"B11156098"<br>
						"B11133232"<br>
						"C11138912"<br>
						"B11150911"<br>
						"B11152577"<br>
						"B11156098"<br>
						"B11133232" 
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ grep Group[12] file3.csv | awk -F',' '{print $1}'<br>
						<font class="bashcommand-result">
						C11138192<br>
						B12226507<br>
						B12226546<br>
						C11138122<br>
						C11138184<br>
						C11138797<br>
						C11138152<br>
						C11138150<br>
						C11131039<br>
						C11135566<br>
						B11119903<br>
						C11137544<br>
						C11137123<br>
						C11133100<br>
						B11108399<br>
						B11108326<br>
						B11119909<br>
						B11110893
						</font>
						</font></td>
					</tr>
				</table></p>

				<font class="example">Print the first and second columns of file2.txt and file3.csv for those lines that contain the values <font class="bashcommand">Group1</font> or <font class="bashcommand">Group2</font>.</font>
		    
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ grep Group[12] file2.txt | awk '{print $1,$2}'<br>
						<font class="bashcommand-result">
						"B11130912" "Group2b"<br>
						"B11137244" "Group1"<br>
						"B11154534" "Group1"<br>
						"B11144100" "Group1"<br>
						"B11137244" "Group1"<br>
						"B12226566" "Group2b"<br>
						"B11134987" "Group1"<br>
						"B11144345" "Group1"<br>
						"B11110676" "Group1"<br>
						"C11138929" "Group2b"<br>
						"B11154532" "Group1"<br>
						"B11137120" "Group2b"<br>
						"B33191224" "Group2b"<br>
						"C11138999" "Group2b"<br>
						"B11131605" "Group1"<br>
						"B11137784" "Group1"<br>
						"B11156098" "Group1"<br>
						"B11133232" "Group1"<br>
						"C11138912" "Group2b"<br>
						"B11150911" "Group2b"<br>
						"B11152577" "Group1"<br>
						"B11156098" "Group1"<br>
						"B11133232" "Group1"
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ grep Group[12] file3.csv | awk -F',' '{print $1,$2}'<br>
						<font class="bashcommand-result">
						C11138192 Group1<br>
						B12226507 Group1<br>
						B12226546 Group1<br>
						C11138122 Group1<br>
						C11138184 Group1<br>
						C11138797 Group1<br>
						C11138152 Group1<br>
						C11138150 Group1<br>
						C11131039 Group2 b<br>
						C11135566 Group2 b<br>
						B11119903 Group2 b<br>
						C11137544 Group1<br>
						C11137123 Group2 b<br>
						C11133100 Group1<br>
						B11108399 Group1<br>
						B11108326 Group1<br>
						B11119909 Group2 b<br>
						B11110893 Group1
						</font>
						</font></td>
					</tr>
				</table></p>

				<h3>9.13. Examples: Reading lines of a file that contain the searched value in a specific column</h3>

				<font class="example">Print the line(s) of file3.csv and file4.txt that have value <font class="bashcommand">11</font> <u>in the third column</u>.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$3 == "11" {print $1,$2}' file4.txt<br>
						<font class="bashcommand-result">
						D11144030 Group3<br>
						C11137159 Group3 
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$3 == "11" {print $1,$2}' file3.csv<br>
						<font class="bashcommand-result">
						C11137443 Group3 
						</font>
						</font></td>
					</tr>
				</table></p>

				<font class="example">Print the first and second columns of those lines in file3.csv and file4.txt that have value <font class="bashcommand">11</font> <u>in the third column</u>.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$3 == "11" {print $1,$2}' file4.txt<br>
						<font class="bashcommand-result">
						D11144030 Group3<br>
						C11137159 Group3 
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$3 == "11" {print $1,$2}' file3.csv<br>
						<font class="bashcommand-result">
						C11137443 Group3 
						</font>
						</font></td>
					</tr>
				</table></p>

				<font class="example">Print the line(s) of file1.csv and file2.txt that have value <font class="bashcommand">"Group1"</font> (including the colons <font class="bashcommand">""</font>) <u>in the second column</u>.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$2 == "\"Group1\""' file2.txt<br>
						<font class="bashcommand-result">
						"B11137244" "Group1" "450" "555"<br>
						"B11154534" "Group1" "456" "456"<br>
						"B11144100" "Group1" "450" "886"<br>
						"B11137244" "Group1" "450" "456"<br>
						"B11134987" "Group1" "900" "MissingData"<br>
						"B11144345" "Group1" "900" "776"<br>
						"B11110676" "Group1" "900" "10"<br>
						"B11154532" "Group1" "456" "886"<br>
						"B11131605" "Group1" "456" "MissingData"<br>
						"B11137784" "Group1" "900" "436"<br>
						"B11156098" "Group1" "500" "886"<br>
						"B11133232" "Group1" "500" "MissingData"<br>
						"B11152577" "Group1" "900" "756"<br>
						"B11156098" "Group1" "456" "886"<br>
						"B11133232" "Group1" "456" "MissingData" 
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$2 == "\"Group1\""' file1.csv<br>
						<font class="bashcommand-result">
						"B33199522","Group1","0",""<br>
						"B11137879","Group1","0",""<br>
						"B11153927","Group1","0",""<br>
						"B11177806","Group1","MD",""<br>
						"B11152799","Group1","0",""<br>
						"B11154358","Group1","0",""<br>
						"B11110925","Group1","0",""<br>
						"B11137879","Group1","0",""<br>
						"B11110603","Group1","0",""<br>
						"B11110927","Group1","0",""<br>
						"B11147712","Group1","0",""<br>
						"B11157974","Group1","0",""<br>
						"B33199522","Group1","0","" 
						</font>
						</font></td>
					</tr>
				</table></p>

				<font class="example">Print the first column of those lines in file1.csv and file2.txt that have value <font class="bashcommand">"Group1"</font> (including the colons <font class="bashcommand">""</font>) <u>in the second column</u>.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$2 == "\"Group1\"" {print $1}' file2.txt<br>
						<font class="bashcommand-result">
						"B11137244"<br>
						"B11154534"<br>
						"B11144100"<br>
						"B11137244"<br>
						"B11134987"<br>
						"B11144345"<br>
						"B11110676"<br>
						"B11154532"<br>
						"B11131605"<br>
						"B11137784"<br>
						"B11156098"<br>
						"B11133232"<br>
						"B11152577"<br>
						"B11156098"<br>
						"B11133232" 
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$2 == "\"Group1\"" {print $1}' file1.csv<br>
						<font class="bashcommand-result">
						"B33199522"<br>
						"B11137879"<br>
						"B11153927"<br>
						"B11177806"<br>
						"B11152799"<br>
						"B11154358"<br>
						"B11110925"<br>
						"B11137879"<br>
						"B11110603"<br>
						"B11110927"<br>
						"B11147712"<br>
						"B11157974"<br>
						"B33199522" 
						</font>
						</font></td>
					</tr>
				</table></p>

			<font class="example">Print the line(s) of file1.csv and file2.txt that <u>do not have</u> value <font class="bashcommand">"Group1"</font> (including the colons <font class="bashcommand">""</font>) <u>in the second column</u>.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$2 != "\"Group1\""' file2.txt<br>
						<font class="bashcommand-result">
						"AnonymizedID" "SubjectGroup" "TEST1" "TEST2"<br>
						"B11130912" "Group2b" "900" "MissingData"<br>
						"B12226566" "Group2b" "450" "MissingData"<br>
						"C11137159" "Group3" "MissingData" "MissingData"<br>
						"B11156453" "Group4" "456" "2"<br>
						"C11138929" "Group2b" "2" "MissingData"<br>
						"B11155267" "Group3" "900" "10"<br>
						"B11137120" "Group2b" "450" "456"<br>
						"B33191224" "Group2b" "450" "776"<br>
						"B11155267" "Group3" "900" "10"<br>
						"C11138999" "Group2b" "900" "MissingData"<br>
						"B11135292" "Group3" "MissingData" "MissingData"<br>
						"C11138912" "Group2b" "900" "MissingData"<br>
						"B11150911" "Group2b" "900" "117" 
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$2 != "\"Group1\""' file1.csv<br>
						<font class="bashcommand-result">
						"Anonymized ID","Subject Group","HASCONDITION","CONDITION"<br>
						"B33199603","Group3","0",""<br>
						"B11144410","Group2 b","0",""<br>
						"B11110455","Group2 b","0",""<br>
						"B11135291","Group3","0",""<br>
						"B11177579","Group2 b","0",""<br>
						"B11157958","Group3","0",""<br>
						"B11110690","Group3","0",""<br>
						"B11135291","Group3","9","mTBI"<br>
						"B11135072","MISSING","0",""<br>
						"B33199603","Group3","0",""<br>
						"B33191224","Group2 b","0",""<br>
						"B11131290","Group2 b","0",""<br>
						"B33191224","Group2 b","0",""<br>
						"B11141503","Group3","0",""<br>
						"C11137159","Group3","9","mTBI" 
						</font>
						</font></td>
					</tr>
				</table></p>

				<font class="example">Print the first column of those lines in file1.csv and file2.txt that <u>do not have value</u> <font class="bashcommand">"Group1"</font> (including the colons <font class="bashcommand">""</font>) <u>in the second column</u>.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$2 != "\"Group1\"" {print $1}' file2.txt<br>
						<font class="bashcommand-result">
						"AnonymizedID"<br>
						"B11130912"<br>
						"B12226566"<br>
						"C11137159"<br>
						"B11156453"<br>
						"C11138929"<br>
						"B11155267"<br>
						"B11137120"<br>
						"B33191224"<br>
						"B11155267"<br>
						"C11138999"<br>
						"B11135292"<br>
						"C11138912"<br>
						"B11150911"  
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$2 != "\"Group1\"" {print $1}' file1.csv<br>
						<font class="bashcommand-result">
						"Anonymized ID"<br>
						"B33199603"<br>
						"B11144410"<br>
						"B11110455"<br>
						"B11135291"<br>
						"B11177579"<br>
						"B11157958"<br>
						"B11110690"<br>
						"B11135291"<br>
						"B11135072"<br>
						"B33199603"<br>
						"B33191224"<br>
						"B11131290"<br>
						"B33191224"<br>
						"B11141503"<br>
						"C11137159" 
						</font>
						</font></td>
					</tr>
				</table></p>

				<font class="example">Print the ID (first column) of those subjects in file3.csv and file4.txt that have age (third column) <u>greater than</u> 20.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$3 > "20" {print $1}' file4.txt<br>
						<font class="bashcommand-result">
						AnonymizedID<br>
						B11108326<br>
						B11110893<br>
						B11119909<br>
						B11119903<br>
						C11131039<br>
						C11133100<br>
						C11135566<br>
						C11137439<br>
						C11137544<br>
						C11137123<br>
						C11138150<br>
						C11138797<br>
						C11138184<br>
						C11138122<br>
						C11138122<br>
						C11138192<br>
						B12226507<br>
						B12226546 
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$3 > "20" {print $1}' file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID<br>
						C11138122<br>
						C11138192<br>
						B12226507<br>
						B12226546<br>
						C11138122<br>
						C11138184<br>
						C11138797<br>
						C11138152<br>
						C11138150<br>
						C11131039<br>
						C11135566<br>
						B11119903<br>
						C11137544<br>
						C11137123<br>
						C11137439<br>
						C11133100<br>
						B11108399<br>
						B11108326<br>
						B11119909<br>
						B11110893 
						</font>
						</font></td>
					</tr>
				</table></p>

				<font class="example">Print the ID (first column) of those subjects in file3.csv and file4.txt that have age (third column) <u>less than</u> 20.</font>
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk '$3 < "20" {print $1}' file4.txt<br>
						<font class="bashcommand-result">
						D11144030<br>
						D11144030<br>
						C11137159<br>
						C11137159<br>
						C11137167<br>
						C11137167<br>
						C11137439<br>
						C11137443<br>
						C11138152 
						</font>
						</font></td>
					
						<td><font class="bashcommand">
						$ awk -F',' '$3 < "20" {print $1}' file3.csv<br>
						<font class="bashcommand-result">
						C11137167<br>
						C11137159<br>
						C11137167<br>
						C11137159<br>
						C11137443<br>
						C11137439<br>
						D11144030 
						</font>
						</font></td>
					</tr>
				</table></p>

				<p>
				<font class="example">Print the line(s) of file3.csv that have value <font class="bashcommand">"Group1"</font> <u>or</u> <font class="bashcommand">"Group3"</font> <u>in the second column</u>.</font>
				When there is more than one rule, the easiest and more organized way to run the command is to put all the rules in a text file and call that text file using the flag <font class="bashcommand">-f</font>. In the following example, patterns3.txt contains the rules to filter the lines that are to be printed (<font class="bashcommand">$2 == "Group1"</font> and <font class="bashcommand">$2 == "Group3"</font>). 
				</p>

				<font class="bashcommand">
					
				<p>
				$ cat patterns3.txt<br>
				<font class="bashcommand-result">
				$2 == "Group1"<br>
				$2 == "Group3" 
				</font>
				</p>
					
				<p>
				$ awk -F',' -f patterns3.txt file3.csv<br>
				<font class="bashcommand-result">
				C11138192,Group1,54<br>
				B12226507,Group1,68<br>
				B12226546,Group1,67<br>
				C11138122,Group1,24<br>
				C11138184,Group1,59<br>
				C11138797,Group1,22<br>
				C11138152,Group1,53<br>
				C11138150,Group1,41<br>
				C11137167,Group3,14<br>
				C11137159,Group3,13<br>
				C11137167,Group3,16<br>
				C11137159,Group3,13<br>
				C11137544,Group1,21<br>
				C11137443,Group3,11<br>
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				C11133100,Group1,23<br>
				D11144030,Group3,13<br>
				B11108399,Group1,23<br>
				B11108326,Group1,59<br>
				B11110893,Group1,28 
				</font>
				</p>
					
				<p>
				$ cat patterns4.txt<br>
				<font class="bashcommand-result">
				$2 == "Group1" || $2 == "Group3" 
				</font>
				</p>
					
				<p>
				$ awk -F',' -f test.txt file3.csv<br>
				<font class="bashcommand-result">
				C11138192,Group1,54<br>
				B12226507,Group1,68<br>
				B12226546,Group1,67<br>
				C11138122,Group1,24<br>
				C11138184,Group1,59<br>
				C11138797,Group1,22<br>
				C11138152,Group1,53<br>
				C11138150,Group1,41<br>
				C11137167,Group3,14<br>
				C11137159,Group3,13<br>
				C11137167,Group3,16<br>
				C11137159,Group3,13<br>
				C11137544,Group1,21<br>
				C11137443,Group3,11<br>
				C11137439,Group3,79<br>
				C11137439,Group3,15<br>
				C11133100,Group1,23<br>
				D11144030,Group3,13<br>
				B11108399,Group1,23<br>
				B11108326,Group1,59<br>
				B11110893,Group1,28  
				</font>
				</p>
					
				</font>

				<p>In this example, we obtained the same result using either patterns3.txt or patterns4.txt. When you want to select any line that contains any pattern in a list of patterns, you can either put each pattern in a different line of the text file or use the or (||) symbol to concatenate all the patterns or rules.</p>

				<p>
				<font class="example">Print the value of one column for those lines that have specific values in other columns</font>
				Print the ID (first column) of those subjects in file3.csv that belong to <font class="bashcommand">"Group1"</font> (second column), and have age (third column) <u>greater than</u> 60, or that belong to <font class="bashcommand">"Group3"</font> (second column) and have age (third column) <u>less than</u> 20.
				</p>

				<p>
				In this example, we want to print any line that contains one of the following rules:
				<ul>
					<li>Second column equals <font class="bashcommand">Group1</font> and third greater than 60: <font class="bashcommand">$2 == "Group1" && $3 > 60</font></li>
					<li>Second column equals and <font class="bashcommand">Group3</font> third less than 20: <font class="bashcommand">$2 == "Group3" && $3 < 20</font></li>
				</ul>
				</p>

				<p>
				So, the content of our pattern file must be:<br>
				<font class="bashcommand">
				$ cat patterns5.txt<br>
				<font class="bashcommand-result">
				$2 == "Group1" && $3 > 60<br>
				$2 == "Group3" && $3 < 20 
				</font>
				</font>
				</p>

				<p>
				To print all the columns from the selected lines:<br>
				<font class="bashcommand">
				$ awk -F',' -f patterns5.txt file3.csv<br>
				<font class="bashcommand-result">
				B12226507,Group1,68<br>
				B12226546,Group1,67<br>
				C11137167,Group3,14<br>
				C11137159,Group3,13<br>
				C11137167,Group3,16<br>
				C11137159,Group3,13<br>
				C11137443,Group3,11<br>
				C11137439,Group3,15<br>
				D11144030,Group3,13 
				</font>
				</font>
				</p>

				<p>
				To print the first column:<br>
				<font class="bashcommand">
				$ awk -F',' -f patterns5.txt file3.csv | awk -F',' '{print $1}'<br>
				<font class="bashcommand-result">
				B12226507<br>
				B12226546<br>
				C11137167<br>
				C11137159<br>
				C11137167<br>
				C11137159<br>
				C11137443<br>
				C11137439<br>
				D11144030 
				</font>
				</font>
				</p>

				<p>
				The following page contains a summary of other patterns that can be included in a pattern file: <a href="https://ss64.com/bash/awk.html" target="_blank">https://ss64.com/bash/awk.html</a>
				</p>

				<h3>9.14. Examples: Reading the lines of a file that contain a pattern (instead of a specific word).</h3>

				<p>
				<font class="example">Print the line(s) of file3.csv that start with B.</font>
				<font class="bashcommand">
				$ grep '^B' file3.csv<br>
				<font class="bashcommand-result">
				B12226507,Group1,68<br>
				B12226546,Group1,67<br>
				B11119903,Group2 b,83<br>
				B11108399,Group1,23<br>
				B11108326,Group1,59<br>
				B11119909,Group2 b,61<br>
				B11110893,Group1,28 
				</font>
				</font>
				</p>
				
				<p>
				<font class="example">Print the line(s) of test7.csv that end with 13.</font>
				<font class="bashcommand">
				$ grep '13$' file3.csv<br>
				<font class="bashcommand-result">
				C11137159,Group3,13<br>
				C11137159,Group3,13<br>
				D11144030,Group3,13 
				</font>
				</font>
				</p>
				
				<p>
				<font class="example">Print the line(s) of test7.csv that end with 13 (when this pattern is stored in a file called patterns2.txt).</font>
				<font class="bashcommand">
				$ cat patterns2.txt<br>
				<font class="bashcommand-result">
				13$ 
				</font>
				</font>
				</p>

				<p>
				<font class="bashcommand">
				$ grep -f patterns2.txt file3.csv<br>
				<font class="bashcommand-result">
				C11137159,Group3,13<br>
				C11137159,Group3,13<br>
				D11144030,Group3,13 
				</font>
				</font>
				</p>

				<p><font class="example">Print all the non-empty lines (lines with more than 0 fields NF > 0) in file3.csv and file4.txt.</font></p>

				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk 'NF > 0' file4.txt<br>
						<font class="bashcommand-result">
						AnonymizedID SubjectGroup AGE<br>
						B11108326 Group1 59<br>
						B11108399 Group1 23<br>
						B11110893 Group1 28<br>
						B11119909 Group2 61<br>
						D11144030 Group3 11<br>
						D11144030 Group3 13<br>
						B11119903 Group2 84<br>
						C11131039 Group2 67<br>
						C11133100 Group1 23<br>
						C11135566 Group2 72<br>
						C11137159 Group3 11<br>
						C11137159 Group3 12<br>
						C11137167 Group3 14<br>
						C11137167 Group3 16<br>
						C11137439 Group3 15<br>
						C11137439 Group3 79<br>
						C11137443 Group3 15<br>
						C11137544 Group1 22<br>
						C11137123 Group2 68<br>
						C11138150 Group1 44<br>
						C11138152 Group1 10<br>
						C11138797 Group1 24<br>
						C11138184 Group1 57<br>
						C11138122 Group1 23<br>
						C11138122 MISSING 25<br>
						C11138192 Group1 45<br>
						B12226507 Group1 26<br>
						B12226546 Group1 55 
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ awk -F',' 'NF > 0' file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28 
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Print all the lines that have more than two fields (NF > 2) in file3.csv and file4.txt.</font></p>
			
				<p><table>
					<tr>
						<th>Space-separated file</th>
						<th>Comma-separated file</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ awk 'NF > 2' file4.txt<br>
						<font class="bashcommand-result">
						AnonymizedID SubjectGroup AGE<br>
						B11108326 Group1 59<br>
						B11108399 Group1 23<br>
						B11110893 Group1 28<br>
						B11119909 Group2 61<br>
						D11144030 Group3 11<br>
						D11144030 Group3 13<br>
						B11119903 Group2 84<br>
						C11131039 Group2 67<br>
						C11133100 Group1 23<br>
						C11135566 Group2 72<br>
						C11137159 Group3 11<br>
						C11137159 Group3 12<br>
						C11137167 Group3 14<br>
						C11137167 Group3 16<br>
						C11137439 Group3 15<br>
						C11137439 Group3 79<br>
						C11137443 Group3 15<br>
						C11137544 Group1 22<br>
						C11137123 Group2 68<br>
						C11138150 Group1 44<br>
						C11138152 Group1 10<br>
						C11138797 Group1 24<br>
						C11138184 Group1 57<br>
						C11138122 Group1 23<br>
						C11138122 MISSING 25<br>
						C11138192 Group1 45<br>
						B12226507 Group1 26<br>
						B12226546 Group1 55 
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ awk -F',' 'NF > 2' file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28 
						</font>
						</font></td>
					</tr>
				</table></p>

				<h3>9.15. Find and replace text</h3>
	
				<p><font class="example">Replace all occurrences of C11137159 in file3.csv with XXXXXXXXX and save the modified content in file3_mod.csv.</font></p>
		
				<p>
				Command to execute the substitution:<br>
				<font class="bashcommand">$ sed 's/C11137159/XXXXXXXXX/' file3.csv > file3_mod.csv</font>
				</p>

				<p><table>
					<tr>
						<th>Content of file3.csv before the substitution:</th>
						<th>Content of the file after the substitution:</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3_mod.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						XXXXXXXXX,Group3,13<br>
						C11137167,Group3,16<br>
						XXXXXXXXX,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28 	
						</font>
						</font></td>
					</tr>
				</table></p>

				<p>In the following example, instead of replacing a fix string as we did in example 1, we will replace a group of characters (i.e. all upper-case characters in the file) by a single character or another group of characters (i.e. replace with lower-case characters). The groups of characters that can be used are listed in the following table:</p>

				<p><table>
					<tr>
						<th>Expression</th>
						<th>Group of characters</th>
					</tr>
					<tr>
						<td><font class="bashcommand">[:alnum:]</font></td>
						<td>Letters and digits</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:alpha:]</font></td>
						<td>Letters</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:blank:]</font></td>
						<td>Horizontal white space</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:cntrl:]</font></td>
						<td>Control characters</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:digit:]</font></td>
						<td>Digits</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:graph:]</font></td>
						<td>Printable characters, excluding space</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:lower:]</font></td>
						<td>Lower-case letters</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:print:]</font></td>
						<td>Printable characters, including space</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:punct:]</font></td>
						<td>Punctuation characters</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:space:]</font></td>
						<td>Horizontal or vertical white space</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:upper:]</font></td>
						<td>Upper-case letters</td>
					</tr>
					<tr>
						<td><font class="bashcommand">[:xdigit:]</font></td>
						<td>Hexadecimal digits</td>
					</tr>
				</table></p>

				<p><font class="example">Replace all upper-case letters in file3.csv by lower-case.</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr '[:upper:]' '[:lower:]'<br>
						<font class="bashcommand-result">
						anonymized id,subject group,age<br>
						c11138122,missing,21<br>
						c11138192,group1,54<br>
						b12226507,group1,68<br>
						b12226546,group1,67<br>
						c11138122,group1,24<br>
						c11138184,group1,59<br>
						c11138797,group1,22<br>
						c11138152,group1,53<br>
						c11138150,group1,41<br>
						c11137167,group3,14<br>
						c11137159,group3,13<br>
						c11137167,group3,16<br>
						c11137159,group3,13<br>
						c11131039,group2 b,67<br>
						c11135566,group2 b,73<br>
						b11119903,group2 b,83<br>
						c11137544,group1,21<br>
						c11137443,group3,11<br>
						c11137123,group2 b,69<br>
						c11137439,group3,79<br>
						c11137439,group3,15<br>
						c11133100,group1,23<br>
						d11144030,group3,13<br>
						b11108399,group1,23<br>
						b11108326,group1,59<br>
						b11119909,group2 b,61<br>
						b11110893,group1,28 
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Replace all lower-case letters in file3.csv by upper-case.</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr '[:lower:]' '[:upper:]'<br>
						<font class="bashcommand-result">
						ANONYMIZED ID,SUBJECT GROUP,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,GROUP1,54<br>
						B12226507,GROUP1,68<br>
						B12226546,GROUP1,67<br>
						C11138122,GROUP1,24<br>
						C11138184,GROUP1,59<br>
						C11138797,GROUP1,22<br>
						C11138152,GROUP1,53<br>
						C11138150,GROUP1,41<br>
						C11137167,GROUP3,14<br>
						C11137159,GROUP3,13<br>
						C11137167,GROUP3,16<br>
						C11137159,GROUP3,13<br>
						C11131039,GROUP2 B,67<br>
						C11135566,GROUP2 B,73<br>
						B11119903,GROUP2 B,83<br>
						C11137544,GROUP1,21<br>
						C11137443,GROUP3,11<br>
						C11137123,GROUP2 B,69<br>
						C11137439,GROUP3,79<br>
						C11137439,GROUP3,15<br>
						C11133100,GROUP1,23<br>
						D11144030,GROUP3,13<br>
						B11108399,GROUP1,23<br>
						B11108326,GROUP1,59<br>
						B11119909,GROUP2 B,61<br>
						B11110893,GROUP1,28
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Replace all alphabetical characters in file3.csv by the number 0</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr '[:alpha:]' 0<br>
						<font class="bashcommand-result">
						0000000000 00,0000000 00000,000<br>
						011138122,0000000,21<br>
						011138192,000001,54<br>
						012226507,000001,68<br>
						012226546,000001,67<br>
						011138122,000001,24<br>
						011138184,000001,59<br>
						011138797,000001,22<br>
						011138152,000001,53<br>
						011138150,000001,41<br>
						011137167,000003,14<br>
						011137159,000003,13<br>
						011137167,000003,16<br>
						011137159,000003,13<br>
						011131039,000002 0,67<br>
						011135566,000002 0,73<br>
						011119903,000002 0,83<br>
						011137544,000001,21<br>
						011137443,000003,11<br>
						011137123,000002 0,69<br>
						011137439,000003,79<br>
						011137439,000003,15<br>
						011133100,000001,23<br>
						011144030,000003,13<br>
						011108399,000001,23<br>
						011108326,000001,59<br>
						011119909,000002 0,61<br>
						011110893,000001,28
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Replace all digits in file3.csv by the letter X.</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr '[:digit:]' X<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						CXXXXXXXX,MISSING,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						BXXXXXXXX,GroupX,XX<br>
						BXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX b,XX<br>
						CXXXXXXXX,GroupX b,XX<br>
						BXXXXXXXX,GroupX b,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX b,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						CXXXXXXXX,GroupX,XX<br>
						DXXXXXXXX,GroupX,XX<br>
						BXXXXXXXX,GroupX,XX<br>
						BXXXXXXXX,GroupX,XX<br>
						BXXXXXXXX,GroupX b,XX<br>
						BXXXXXXXX,GroupX,XX
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Replace all punctuation characters in file3.csv by a space (<font class="bashcommand">' '</font>)</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr '[:punct:]' ' '<br>
						<font class="bashcommand-result">
						Anonymized ID Subject Group AGE<br>
						C11138122 MISSING 21<br>
						C11138192 Group1 54<br>
						B12226507 Group1 68<br>
						B12226546 Group1 67<br>
						C11138122 Group1 24<br>
						C11138184 Group1 59<br>
						C11138797 Group1 22<br>
						C11138152 Group1 53<br>
						C11138150 Group1 41<br>
						C11137167 Group3 14<br>
						C11137159 Group3 13<br>
						C11137167 Group3 16<br>
						C11137159 Group3 13<br>
						C11131039 Group2 b 67<br>
						C11135566 Group2 b 73<br>
						B11119903 Group2 b 83<br>
						C11137544 Group1 21<br>
						C11137443 Group3 11<br>
						C11137123 Group2 b 69<br>
						C11137439 Group3 79<br>
						C11137439 Group3 15<br>
						C11133100 Group1 23<br>
						D11144030 Group3 13<br>
						B11108399 Group1 23<br>
						B11108326 Group1 59<br>
						B11119909 Group2 b 61<br>
						B11110893 Group1 28
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Replace all white spaces in file3.csv by an underscore <font class="bashcommand">'_'</font>.</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr '[:blank:]' '_'<br>
						<font class="bashcommand-result">
						Anonymized_ID,Subject_Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2_b,67<br>
						C11135566,Group2_b,73<br>
						B11119903,Group2_b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2_b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2_b,61<br>
						B11110893,Group1,28
						</font>	
						</font></td>
					</tr>
				</table></p>

				<p>You can also replace a range of letters or numbers:</p>

				<p><font class="example">Replace any A, B or C (letters in the range A-C) in file3.csv by the letter D.</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr 'A-C' 'D'<br>
						<font class="bashcommand-result">
						Dnonymized ID,Subject Group,DGE<br>
						D11138122,MISSING,21<br>
						D11138192,Group1,54<br>
						D12226507,Group1,68<br>
						D12226546,Group1,67<br>
						D11138122,Group1,24<br>
						D11138184,Group1,59<br>
						D11138797,Group1,22<br>
						D11138152,Group1,53<br>
						D11138150,Group1,41<br>
						D11137167,Group3,14<br>
						D11137159,Group3,13<br>
						D11137167,Group3,16<br>
						D11137159,Group3,13<br>
						D11131039,Group2 b,67<br>
						D11135566,Group2 b,73<br>
						D11119903,Group2 b,83<br>
						D11137544,Group1,21<br>
						D11137443,Group3,11<br>
						D11137123,Group2 b,69<br>
						D11137439,Group3,79<br>
						D11137439,Group3,15<br>
						D11133100,Group1,23<br>
						D11144030,Group3,13<br>
						D11108399,Group1,23<br>
						D11108326,Group1,59<br>
						D11119909,Group2 b,61<br>
						D11110893,Group1,28
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Replace A by W, B by X, C by Y, and D by Z in file3.csv (replace letters in the range A-D with letters in the range W-Z)</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr 'A-D' 'W-Z'<br>
						<font class="bashcommand-result">
						Wnonymized IZ,Subject Group,WGE<br>
						Y11138122,MISSING,21<br>
						Y11138192,Group1,54<br>
						X12226507,Group1,68<br>
						X12226546,Group1,67<br>
						Y11138122,Group1,24<br>
						Y11138184,Group1,59<br>
						Y11138797,Group1,22<br>
						Y11138152,Group1,53<br>
						Y11138150,Group1,41<br>
						Y11137167,Group3,14<br>
						Y11137159,Group3,13<br>
						Y11137167,Group3,16<br>
						Y11137159,Group3,13<br>
						Y11131039,Group2 b,67<br>
						Y11135566,Group2 b,73<br>
						X11119903,Group2 b,83<br>
						Y11137544,Group1,21<br>
						Y11137443,Group3,11<br>
						Y11137123,Group2 b,69<br>
						Y11137439,Group3,79<br>
						Y11137439,Group3,15<br>
						Y11133100,Group1,23<br>
						Z11144030,Group3,13<br>
						X11108399,Group1,23<br>
						X11108326,Group1,59<br>
						X11119909,Group2 b,61<br>
						X11110893,Group1,28
						</font>
						</font></td>
					</tr>
				</table></p>

				<p>The command <font class="bashcommand">tr</font> doesn't allow you to replace by an empty space in order to delete a character or a set of characters, but you can use the <font class="bashcommand">-d</font> flag for deletion.</p>

				<p><font class="example">Remove all spaces in file3.csv.</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						$ cat file3.csv<br>
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr -d '[:blank:]'<br>
						<font class="bashcommand-result">
						AnonymizedID,SubjectGroup,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2b,67<br>
						C11135566,Group2b,73<br>
						B11119903,Group2b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
					</tr>
				</table></p>

				<p>In order to delete any repeated (continuous) character or sequence use the <font class="bashcommand">-s</font> flag.</p>

				<p><font class="example">Remove any repeated characters (<font class="bashcommand">[:alnum:]</font>) in file3.csv.</font></p>

				<p><table>
					<tr>
						<th>Original content of the file</th>
						<th>Content after replacements</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ cat file3.csv<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C11138122,MISSING,21<br>
						C11138192,Group1,54<br>
						B12226507,Group1,68<br>
						B12226546,Group1,67<br>
						C11138122,Group1,24<br>
						C11138184,Group1,59<br>
						C11138797,Group1,22<br>
						C11138152,Group1,53<br>
						C11138150,Group1,41<br>
						C11137167,Group3,14<br>
						C11137159,Group3,13<br>
						C11137167,Group3,16<br>
						C11137159,Group3,13<br>
						C11131039,Group2 b,67<br>
						C11135566,Group2 b,73<br>
						B11119903,Group2 b,83<br>
						C11137544,Group1,21<br>
						C11137443,Group3,11<br>
						C11137123,Group2 b,69<br>
						C11137439,Group3,79<br>
						C11137439,Group3,15<br>
						C11133100,Group1,23<br>
						D11144030,Group3,13<br>
						B11108399,Group1,23<br>
						B11108326,Group1,59<br>
						B11119909,Group2 b,61<br>
						B11110893,Group1,28
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ cat file3.csv | tr -s '[:alnum:]'<br>
						<font class="bashcommand-result">
						Anonymized ID,Subject Group,AGE<br>
						C13812,MISING,21<br>
						C138192,Group1,54<br>
						B126507,Group1,68<br>
						B126546,Group1,67<br>
						C13812,Group1,24<br>
						C138184,Group1,59<br>
						C138797,Group1,2<br>
						C138152,Group1,53<br>
						C138150,Group1,41<br>
						C137167,Group3,14<br>
						C137159,Group3,13<br>
						C137167,Group3,16<br>
						C137159,Group3,13<br>
						C131039,Group2 b,67<br>
						C1356,Group2 b,73<br>
						B1903,Group2 b,83<br>
						C13754,Group1,21<br>
						C13743,Group3,1<br>
						C137123,Group2 b,69<br>
						C137439,Group3,79<br>
						C137439,Group3,15<br>
						C1310,Group1,23<br>
						D14030,Group3,13<br>
						B10839,Group1,23<br>
						B108326,Group1,59<br>
						B1909,Group2 b,61<br>
						B10893,Group1,28
						</font>
						</font></td>
					</tr>
				</table></p>
							
				<h3>9.16. Printing other information from a file</h3>

				<p><font class="example">Print the number of lines in file3.csv and file4.txt.</font></p>

				<p><table>
					<tr>
						<th>file3.csv</th>
						<th>file4.csv</th>
					</tr>
					
					<tr>
						<td><p><font class="bashcommand">
						$ awk '{print NF}' file3.csv | wc -l<br>
						<font class="bashcommand-result">28</font>
						</font></p>
						
						<p><font class="bashcommand">
						$ nlines=$(awk '{print NF}' file3.csv | wc -l)<br>
						$ echo $nlines<br>
						<font class="bashcommand-result">28</font>
						</font></p></td>
						
						<td><p><font class="bashcommand">
						$ awk '{print NF}' file4.txt | wc -l<br>
						<font class="bashcommand-result">29</font>
						</font></p>
						
						<p><font class="bashcommand">
						$ nlines=$(awk '{print NF}' file4.txt | wc -l)<br>
						$ echo $nlines<br>
						<font class="bashcommand-result">29</font>
						</font></p></td>
					</tr>
				</table></p>

				<p><font class="example">Print the number of columns in file3.csv and file4.txt.</font></p>

				<p><table>
					<tr>
						<th>Comma-separated file</th>
						<th>Space-separated file</th>
					</tr>
					
					<tr>
						<td><p><font class="bashcommand">
						$ awk -F',' '{print NF}' file3.csv | sort –nu<br>
						<font class="bashcommand-result">3</font>
						</font></p>
						
						<p><font class="bashcommand">
						$ ncols=$(awk -F',' '{print NF}' file3.csv | sort -nu)<br>
						$ echo $ncols<br>
						<font class="bashcommand-result">3</font>
						</font></p></td>
						
						<td><p><font class="bashcommand">
						$ awk '{print NF}' file4.txt | sort -nu<br>
						<font class="bashcommand-result">3</font>
						</font></p>
						
						<p><font class="bashcommand">
						$ ncols=$(awk '{print NF}' file4.txt | sort -nu)<br>
						$ echo $ncols<br>
						<font class="bashcommand-result">3</font>
						</font></p></td>
					</tr>
				</table></p>

				<p><font class="example">Print the length of each line of file4.txt.</font></p>

				<p>To get the length of a string you can use the function <font class="bashcommand">length()</font>, and pass as parameter <font class="bashcommand">$0</font> which obtains all the fields (the whole line).</p>

				<p><table>
					<tr>
						<th>Print each line</th>
						<th>Print the length of each line</th>
					</tr>
					
					<tr>
						<td><font class="bashcommand">
						$ awk '{print $0}' file4.txt<br>
						<font class="bashcommand-result">
						AnonymizedID SubjectGroup AGE<br>
						B11108326 Group1 59<br>
						B11108399 Group1 23<br>
						B11110893 Group1 28<br>
						B11119909 Group2 61<br>
						D11144030 Group3 11<br>
						D11144030 Group3 13<br>
						B11119903 Group2 84<br>
						C11131039 Group2 67<br>
						C11133100 Group1 23<br>
						C11135566 Group2 72<br>
						C11137159 Group3 11<br>
						C11137159 Group3 12<br>
						C11137167 Group3 14<br>
						C11137167 Group3 16<br>
						C11137439 Group3 15<br>
						C11137439 Group3 79<br>
						C11137443 Group3 15<br>
						C11137544 Group1 22<br>
						C11137123 Group2 68<br>
						C11138150 Group1 44<br>
						C11138152 Group1 10<br>
						C11138797 Group1 24<br>
						C11138184 Group1 57<br>
						C11138122 Group1 23<br>
						C11138122 MISSING 25<br>
						C11138192 Group1 45<br>
						B12226507 Group1 26<br>
						B12226546 Group1 55
						</font>
						</font></td>
						
						<td><font class="bashcommand">
						$ awk '{print length($0)}' file4.txt<br>
						<font class="bashcommand-result">
						29<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>19<br>20<br>19<br>19<br>19
						</font>
						</font></td>
					</tr>
				</table></p>

				<p><font class="example">Print the length of the second field (<font class="bashcommand">length($2)</font>) in file3.csv and file4.txt.</font></p>

				<p><table>
					<tr>
						<th>Comma-separated file</th>
						<th>Space-separated file</th>
					</tr>
					
					<tr>
						<td><p><font class="bashcommand">
						$ awk '{print length($2)}' file4.txt<br>
						<font class="bashcommand-result">
						12<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>7<br>6<br>6<br>6
						</font>
						</font></td>
						
						<td><p><font class="bashcommand">
						$ awk -F',' '{print length($2)}' file3.csv<br>
						<font class="bashcommand-result">
						13<br>7<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>6<br>8<br>8<br>8<br>6<br>6<br>8<br>6<br>6<br>6<br>6<br>6<br>6<br>8<br>6
						</font>
						</font></td>
					</tr>
				</table></p>

				<p>
				<font class="example">Print all the lines of file4.txt in upper-case.</font><br>
				To convert a string to upper-case use the function <font class="bashcommand">toupper()</font> and pass as parameter <font class="bashcommand">$0</font> which contains the whole line.
				</p>

				<p><table>
					<tr><td><font class="bashcommand">$ awk '{print toupper($0)}' file4.txt</font></td></tr>
					<tr><td><font class="bashcommand-result">
						ANONYMIZEDID SUBJECTGROUP AGE<br>
						B11108326 GROUP1 59<br>
						B11108399 GROUP1 23<br>
						B11110893 GROUP1 28<br>
						B11119909 GROUP2 61<br>
						D11144030 GROUP3 11<br>
						D11144030 GROUP3 13<br>
						B11119903 GROUP2 84<br>
						C11131039 GROUP2 67<br>
						C11133100 GROUP1 23<br>
						C11135566 GROUP2 72<br>
						C11137159 GROUP3 11<br>
						C11137159 GROUP3 12<br>
						C11137167 GROUP3 14<br>
						C11137167 GROUP3 16<br>
						C11137439 GROUP3 15<br>
						C11137439 GROUP3 79<br>
						C11137443 GROUP3 15<br>
						C11137544 GROUP1 22<br>
						C11137123 GROUP2 68<br>
						C11138150 GROUP1 44<br>
						C11138152 GROUP1 10<br>
						C11138797 GROUP1 24<br>
						C11138184 GROUP1 57<br>
						C11138122 GROUP1 23<br>
						C11138122 MISSING 25<br>
						C11138192 GROUP1 45<br>
						B12226507 GROUP1 26<br>
						B12226546 GROUP1 55 
					</font></td></tr>
				</table></p>

				<p>
				<font class="example">Print all the lines of file4.txt in lower-case.</font><br>
				To convert a string to lower-case use the function <font class="bashcommand">tolower()</font> and pass as parameter <font class="bashcommand">$0</font> which contains the whole line.
				</p>

				<p><table>
					<tr><td><font class="bashcommand">$ awk '{print tolower($0)}' file4.txt</font></tr></td>
					<tr><td><font class="bashcommand-result">
						anonymizedid subjectgroup age<br>
						b11108326 group1 59<br>
						b11108399 group1 23<br>
						b11110893 group1 28<br>
						b11119909 group2 61<br>
						d11144030 group3 11<br>
						d11144030 group3 13<br>
						b11119903 group2 84<br>
						c11131039 group2 67<br>
						c11133100 group1 23<br>
						c11135566 group2 72<br>
						c11137159 group3 11<br>
						c11137159 group3 12<br>
						c11137167 group3 14<br>
						c11137167 group3 16<br>
						c11137439 group3 15<br>
						c11137439 group3 79<br>
						c11137443 group3 15<br>
						c11137544 group1 22<br>
						c11137123 group2 68<br>
						c11138150 group1 44<br>
						c11138152 group1 10<br>
						c11138797 group1 24<br>
						c11138184 group1 57<br>
						c11138122 group1 23<br>
						c11138122 missing 25<br>
						c11138192 group1 45<br>
						b12226507 group1 26<br>
						b12226546 group1 55
					</font></tr></td>
				</p></table>

				<p>Some other functions that can be used in addition to <font class="bashcommand">toupper()</font> and <font class="bashcommand">tolower()</font> can be found <a href="https://www.cs.princeton.edu/courses/archive/spr08/cos333/awk.help" target="_blank">here</a></p>
		    </div>
		       
		    <div id="content10" class="hidden">
		    	<h2>10. Manipulating image files</h2>
		    	    <h3>10.1. Changing format or properties of an image file using sips (for Mac users)</h3>
			    <p>Usage: <font class="bashcommand">sips [flags] inputFile [--out outputFile]</font></p>
			    <p>Image modification flags:</p>
			    
			    <p><table>
			    	<tr>
					<th>Flag</th>
					<th>Meaning</th>
				</tr>
			    	<tr>
					<td><font class="bashcommand">-s</font> key value<br>or<br><font class="bashcommand">--setProperty key value</font></td>
					<td>Set the <font class="bashcommand">value</font> for a <font class="bashcommand">key</font> (see tables below for the available profile property keys and acceptable values for each key).</td>
				</tr>
			    	<tr>
					<td><font class="bashcommand">-r degreesCW</font><br>or<br><font class="bashcommand">--rotate degreesCW</font></td>
					<td>Rotate an image several degrees clockwise.</td>
				</tr>
			    	<tr>
					<td><font class="bashcommand">-f option</font><br>or<br><font class="bashcommand">--flip option</font></td>
					<td>Flip the image using one of the following two options: <font class="bashcommand">horizontal</font> or <font class="bashcommand">vertical</font>.</td>
				</tr>
			    	<tr>
					<td><font class="bashcommand">-c pixelsH pixelsW</font><br>or<br><font class="bashcommand">--cropToHeightWidth pixelsH pixelsW</font></td>
			    		<td>Crop image to fit specified size. <font class="bashcommand">pixelsH</font> indicates the new height in number of pixels, <font class="bashcommand">pixelsW</font> indicates the new width in number of pixels.</td>
			    	</tr>
			    	<tr>
					<td><font class="bashcommand">-z pixelsH pixelsW</font><br>or<br><font class="bashcommand">--resampleHeightWidth pixelsH pixelsW</font></td>
					<td>Resample image at specified size. Image aspect ratio may be altered. <font class="bashcommand">pixelsH</font> indicate the new height in number of pixels, <font class="bashcommand">pixelsW</font> indicate the new width in number of pixels.</td>
				</tr>
			    	<tr>
					<td><font class="bashcommand">-Z pixelsWH</font><br>or<br><font class="bashcommand">--resampleHeightWidthMax pixelsWH</font></td>
					<td>Resample image so height and width aren't greater than specified.</td>
				</tr>
			    	<tr>
					<td><font class="bashcommand">--resampleWidth pixelsW</font></td>
					<td>Resample image to specified width. <font class="bashcommand">pixelsW</font> indicate the new width in number of pixels.</td>
				</tr>
			    	<tr>
					<td><font class="bashcommand">--resampleHeight pixelsH</font></td>
					<td>Resample image to specified height. <font class="bashcommand">pixelsH</font> indicate the new height in number of pixels.</td>
				</tr>
			    	<tr>
					<td><font class="bashcommand">-o</font><br>or<br><font class="bashcommand">--optimizeColorForSharing</td>
					<td>Optimize color for sharing.</td>
				</tr>
			    </p></table>

			    <p>If you want to modify one image to match the properties of another image (for example have one image match the height of another image), you can use the flag <font class="bashcommand">--getProperty</font> with one of the following properties (which can also be used as parameters for some of the flags described above):</p>
		    
			    <p><table>
				<tr>
					<th>Profile property keys</th>
					<th>Usage</th>
				</tr>
				<tr>
					<td><font class="bashcommand">dpiHeight</font></td>
					<td>Height in dpi (printer dots per inch).</td>
				</tr>
				<tr>
					<td><font class="bashcommand">dpiWidth</font></td>
					<td>Width in dpi (printer dots per inch).</td>
				</tr>
				<tr>
					<td><font class="bashcommand">pixelHeight</font></td>
					<td>Height in number of pixels.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">pixelWidth</font></td>
					<td>Width in number of pixels.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">format</font></td>
					<td>Image format. Acceptable values for this key: <font class="bashcommand">jpeg</font>, <font class="bashcommand">tiff</font>, <font class="bashcommand">png</font>, <font class="bashcommand">gif</font>, <font class="bashcommand">jp2</font>, <font class="bashcommand">pict</font>, <font class="bashcommand">bmp</font>, <font class="bashcommand">qtif</font>, <font class="bashcommand">psd</font>, <font class="bashcommand">sgi</font>, <font class="bashcommand">tga</font>, <font class="bashcommand">pdf</font>.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">formatOptions</font></td>
					<td>Quality of the new image. Acceptable values for this key: <font class="bashcommand">low</font>, <font class="bashcommand">normal</font>, <font class="bashcommand">high</font>, <font class="bashcommand">best</font>, or some percentage.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">samplesPerPixel</font></td>
					<td>Samples per pixel.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">bitsPerSample</font></td>
					<td>Bits per sample.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">software</font></td>
					<td>Software use to create the image.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">description</font></td>
					<td>Description.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">copyright</font></td>
					<td>Copyright.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">version</font></td>
					<td>Version.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">platform</font></td>
					<td>Platform where file was created.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">quality</font></td>
					<td>Acceptable values for this key: <font class="bashcommand">normal</font>, <font class="bashcommand">draft</font>, <font class="bashcommand">best</font>.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">renderingIntent</font></td>
					<td>Acceptable values for this key: <font class="bashcommand">perceptual</font>, <font class="bashcommand">relative</font>, <font class="bashcommand">saturation</font>, <font class="bashcommand">absolute</font>.</td>
				</tr>
				<tr>
					<td><font class="bashcommand">creator</font></td>
					<td>Creator of the file.</td>
				</tr>
			    </p></table>

			    <p>For the examples below I will be using the following image, taken from the following article, which I published long time ago: <a href='https://pubmed.ncbi.nlm.nih.gov/29113642/' target='_blank'>link to article</a>. <a href='https://pubmed.ncbi.nlm.nih.gov/29113642/#&gid=article-figures&pid=figure-2-uid-1' target='_blank'>Link to original image</a>.</p>

			    <p><img src="https://www.ncbi.nlm.nih.gov/pmc/articles/instance/5809301/bin/nihms909531f2.jpg" alt="thalamo-cortical connectivity"></p>

			    <p>
				<font class="example">Convert <a href='https://www.ncbi.nlm.nih.gov/pmc/articles/instance/5809301/bin/nihms909531f2.jpg' target='_blank'>AutismArticle1.png</a> to pdf.</font>
				<font class="bashcommand">$ sips -s format pdf AutismArticle1.png --out AutismArticle1.pdf</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br> 
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.pdf</font>
			    </p>

			    <p>
				<font class="example">Rotate <a href='https://www.ncbi.nlm.nih.gov/pmc/articles/instance/5809301/bin/nihms909531f2.jpg' target='_blank'>AutismArticle1.png</a> 45<sup>&#8728;</sup> clock-wise.</font>
				<font class="bashcommand">$ sips -r 45 AutismArticle1.png --out test.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/test.png</font>
			    </p>

			    <p>Result image:</p>
			    <p><img src="rotated1.png" alt="image rotated 45 degrees clock wise"></p>

			<p>
				<font class="example">Rotate <a href='https://www.ncbi.nlm.nih.gov/pmc/articles/instance/5809301/bin/nihms909531f2.jpg' target='_blank'>AutismArticle1.png</a> 45<sup>&#8728;</sup> counter-clock-wise.</font>
				<font class="bashcommand">$ sips -r -45 AutismArticle1.png --out test.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/test2.png</font>
			</p>

			<p>Result image:</p>
			<p><img src="rotated2.png" alt="image rotated 45 degrees counter clock wise"></p>

			<p>
				<font class="example">Flip <a href='https://www.ncbi.nlm.nih.gov/pmc/articles/instance/5809301/bin/nihms909531f2.jpg' target='_blank'>AutismArticle1.png</a> horizontally.</font>
				<font class="bashcommand">$ sips -f horizontal AutismArticle1.png --out test.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/test.png</font>
			</p>

			<p>Result image:</p>
			<p><img src="flipped.png" alt="image rotated 45 degrees counter clock wise"></p>

			<p>
				<font class="example">Flip <a href='https://www.ncbi.nlm.nih.gov/pmc/articles/instance/5809301/bin/nihms909531f2.jpg' target='_blank'>AutismArticle1.png</a> vertically.</font>
				<font class="bashcommand">$ sips -f vertical AutismArticle1.png --out test.png</font><br> 
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br> 
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/test.png</font>
			</p>

			<p>Result image:</p>
			<p><img src="flipped2.png" alt="image rotated 45 degrees counter clock wise"></p>

			<p>
				<font class="example">Crop <a href='https://www.ncbi.nlm.nih.gov/pmc/articles/instance/5809301/bin/nihms909531f2.jpg' target='_blank'>AutismArticle1.png</a> to fit a new size that be &#188;<sup>th</sup> of its original height and &#188;<sup>th</sup> of its original weight.</font>
				The first step is to obtain the current width and height using <font class="bashcommand">sips</font> with the flags <font class="bashcommand">--getProperty pixelWidth</font> and <font class="bashcommand">--getProperty pixelHeight</font>. Then, divide the two numbers by four. And finally use <font class="bashcommand">sips</font> with the <font class="bashcommand">-c</font> flag to crop the file.
			</p>

			<p>
			<font class="bashcommand">$ sips --getProperty pixelHeight AutismArticle1.png</font><br>
			<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br>
			<font class="bashcommand-result">&nbsp;&nbsp;pixelHeight: 440</font><br>
			<font class="bashcommand">$ sips --getProperty pixelWidth AutismArticle1.png</font><br>
			<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br>
			<font class="bashcommand-result">&nbsp;&nbsp;pixelWidth: 727</font><br>
			<font class="bashcommand">$ echo "440/4" | bc -l</font><br>
			<font class="bashcommand-result">110.00000000000000000000</font><br>
			<font class="bashcommand">$ echo "727/4" | bc -l</font><br>
			<font class="bashcommand-result">181.75000000000000000000</font><br>
			<font class="bashcommand">$ sips -c 110 181 AutismArticle1.png --out test.png</font><br>
			<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br>
			<font class="bashcommand-result">&nbsp;&nbsp;/Users/monica/Desktop/Backup/images_presentations/test.png</font>
			</p>

			<p>Result image:</p>
			<p><img src="cropped.png" alt="cropped image"></p>

			<p>
				<font class="example">Resample image to 110x181.</font>
				<font class="bashcommand">$ sips -z 110 181 AutismArticle1.png --out test.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/AutismArticle1.png</font><br>
				<font class="bashcommand-result">&nbsp;&nbsp;/Users/monica/Desktop/Backup/images_presentations/test.png</font><br>
				<font class="bashcommand">$ sips --getProperty pixelHeight test.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/test.png</font><br>
				<font class="bashcommand-result">&nbsp;&nbsp;pixelHeight: 110</font><br>
				<font class="bashcommand">$ sips --getProperty pixelWidth test.png</font><br>
				<font class="bashcommand-result">/Users/monica/Desktop/Backup/images_presentations/test.png</font><br>
				<font class="bashcommand-result">&nbsp;&nbsp;pixelWidth: 181</font>
			</p>

			<p>Result image:</p>
			<p><img src="resampled.png" alt="cropped image"></p>
		    </div>
		       
		    <div id="content11" class="hidden">
		    	<h2>11. Writing more complex bash scripts</h2>
		    	
		    	<h3>11.1. Reading arguments</h3>
		    		<p>Content 11.1</p>
		    		
		    	<h3>11.2. Using functions</h3>
		    		<p>Content 11.2</p>
		    		
		    	<h3>11.3. Creating/importing libraries</h3>
		    		<p>Content 11.3</p>
		    		
		    	<h3>11.4. Scripting processes in parallel</h3>
		    		<p>Content 11.4</p>
		    </div>
		       
		    <div id="content12" class="hidden">
		    	<h2>12. Remote shell</h2>
		    		<p>Content of section 12</p>
		    </div>
		       
		    <div id="content13" class="hidden">
		    	<h2>13. Cluster jobs</h2>
		    		<p>Content of section 13</p>
		    </div>
		       
		    <div id="content14" class="hidden">
		    	<h2>14. Downloading files from the web</h2>
		    		<p>Content section 14</p>
		    		<p>Stocks</p>
		    </div>
		       
		    <div id="content15" class="hidden">
		    	<h2>15. Creating backups</h2>
		    		<p>Content section 15</p>
		    </div>
		       
		    <div id="content16" class="hidden">
		    	<h2>16. File permissions</h2>
		    		<p>Content of section 16</p>
		    </div>
		       
		    <div id="content17" class="hidden">
		    	<h2>17. Using aliases</h2>
		    		<p>Content of section 17</p>
		    </div>
		       
		    <div id="content18" class="hidden">
		    	<h2>18. keyboard shortcuts</h2>
		    		<p>Content of section 18</p>
		    </div>
		       
		    <div id="content19" class="hidden">
		    	<h2>19. MySQL</h2>
		    		<p>Content of section 19</p>
		    </div>
		       
		    <div id="content20" class="hidden">
		    	<h2>20. Report an error in the tutorial</h2>
					<h3>Thanks for helping me improve this free tutorial!</h3>
					<p>Please, let me know where and what type of error did you find. I will do my best to fix it as soon as I can.</p>
					
			    	<form name="input" action="https://formspree.io/mgcgithub@gmail.com" target="_blank" method="POST">
						Chapter:<br>
						<select onclick="showErrSec()" id="chaperror" name="chaperror">
						  <option value="0">Select a chapter</option>
						  <option value="1">1. Introduction to shell scripting</option>
						  <option value="2">2. Creating simple bash scripts</option>
						  <option value="3">3. Variables</option>
						  <option value="4">4. Arithmetic calculations</option>
						  <option value="5">5. Arrays</option>
						  <option value="6">6. Condition-testing</option>
						</select><br><br>
						
						<div id="secerror1" class="hidden">
							Section:<br>
							<select id="section1" name="section1">
								<option value="0">Select a section</option>
								<option value="1">1.1. Shell scripting</option>
							</select><br><br>
						</div>
						
						<div id="secerror2" class="hidden">
							Section:<br>
							<select id="section2" name="section2">
								<option value="0">Select a section</option>
								<option value="1">2.1. The vi editor</option>
								<option value="2">2.2. Other editors</option>
								<option value="3">2.3. Tips for writing scripts</option>
								<option value="4">2.4. Running a script</option>
							</select><br><br>
						</div>
						
						<div id="secerror3" class="hidden">
							Section:<br>
							<select id="section3" name="section3">
								<option value="0">Select a section</option>
								<option value="1">3.1. Utility, declaration and accessing variables</option>
								<option value="2">3.2. Rules for assigning variable names</option>
								<option value="3">3.3. Reading user input into a variable</option>
								<option value="4">3.4. Using &lt;&lt;&lt; to get input from a different source</option>
							</select><br><br>
						</div>
						
						<div id="secerror4" class="hidden">
							Section:<br>
							<select id="section4" name="section4">
								<option value="0">Select a section</option>
								<option value="1">4.1. Integer calculations</option>
								<option value="2">4.2. Non-integer calculations</option>
							</select><br><br>
						</div>
						
						<div id="secerror5" class="hidden">
							Section:<br>
							<select id="section5" name="section5">
								<option value="0">Select a section</option>
								<option value="1">5.1. Declaring and assigning values</option>
								<option value="2">5.2. Array operations</option>
							</select><br><br>
						</div>
						
						<div id="secerror6" class="hidden">
							Section:<br>
							<select id="section6" name="section6">
								<option value="0">Select a section</option>
								<option value="1">6.1. Condition-testing to check files</option>
								<option value="2">6.2. Condition-testing to compare/evaluate strings</option>
								<option value="3">6.3. Condition-testing to compare numbers</option>
								<option value="4">6.4. Condition-testing to compare arrays</option>
								<option value="5">6.5. Combining different expressions for condition-testing</option>
							</select><br><br>
						</div>
						
						<div onclick="showOther()" id="errtype">
							Error type:<br>
							<select id="etype" name="etype">
								<option value="0">Select error type</option>
								<option value="1">An error in a bash command</option>
								<option value="2">An error in the html code</option>
								<option value="3">Something in this section is not true</option>
								<option value="4">A spelling or grammatical error</option>
								<option value="5">Other</option>
							</select><br><br>
						</div>
						
						<div id="other" class="hidden">
							Please specify: <input type="text" id="othererror" name="othererror"><br><br>
						</div>
						
						<input type="submit" value="Submit">
						<input type="hidden" name="_subject" value="New submission from github"/>
					</form> 
		    </div>
		  </article>
		</section>
		
		<footer>
			<p>
				Last update: July 20 / 2021<br>
				All the content from this tutorial was originally created by the author<br>
				Author: <a href="http://linkedin.com/in/monicakeithmri" target="_blank">Monica Keith</a>
			</p>
		</footer>
	</body>
</html>

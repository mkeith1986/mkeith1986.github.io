<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="description" content="Bash condition testing">
	<meta name="keywords" content="bash, tutorial, if command">
	<meta name="author" content="Monica Keith">
	
	<link rel="stylesheet" type="text/css" href="styles.css">
	<script src="functions.js"></script>
	<noscript>Sorry, your browser does not support JavaScript. This page needs to have JavaScript enabled.</noscript>
</head>
	
    <body>
        <h2>6. Condition-testing</h2>
		    
		    	<p>
					Variables can be used to test if a certain condition is true or false, and therefore be able to take a 
					different course of action depending on the result of the test. For example, you might want to evaluate 
					if a file exists to decide if you can copy it into a different folder or not. For condition-testing you 
					will use the if-command. This command has the following syntax:
				</p>
				
				<p>
					if [ CONDITION_TO_EVALUATE ]<br>
					then<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&lt;INSTRUCTIONS THAT WILL RUN IF THE CONDITION IS TRUE&gt;<br>
					elif [ OTHER_CONDITION_TO_EVALUATE_IF_1ST_CONDITION_IS_FALSE ]<br>
					then<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&lt;INSTRUCTIONS THAT WILL RUN IF FIRST CONDITION IS FALSE BUT SECOND IS TRUE&gt;<br>
					else<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&lt;INSTRUCTIONS THAT WILL RUN IF ALL THE PREVIOUS CONDITIONS ARE FALSE&gt;<br>
					fi
				</p>
				
				<p>
					The CONDITION_TO_EVALUATE is an expression that follows a specific syntax depending on what you want to 
					test (checking files, string comparison, comparing numbers, or combining different expressions). Lets 
					look at the different syntaxes used in each of these situations and at some examples that will help you 
					understand this seemingly confusing subject.
				</p>
				
				<h3>6.1. Condition-testing to check files</h3>
					<p>
						In the following table, <font class="bashcommand">FILE</font> refers to the path of the file or to the 
						variable that contains the path of the file. The spaces after <font class="bashcommand">[</font> and 
						before <font class="bashcommand">]</font> are very important. If those spaces are missing, bash will 
						give an error.
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Condition</b></th>
							<th style="width:70%"><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -a FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -d FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a directory.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -e FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -f FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a regular file.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -g FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and its SGID bit is set.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -h FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a symbolic link.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -k FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and its sticky bit is set.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -p FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a named pipe (FIFO).</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -r FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is readable.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -s FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and has a size greater than zero.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -t FD ]</font>
							</td>
							<td>Tests if file descriptor <font class="bashcommand">FD</font> is open and refers to a terminal.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -u FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and its SUID (set user ID) bit is set.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -w FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is writable.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -x FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is executable.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -O FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is owned by the effective user ID.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -G FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is owned by the effective group ID.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -L FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a symbolic link.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -N FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and has been modified since it was last read.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -S FILE ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE</font> exists and is a socket.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ FILE1 -nt FILE2 ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE1</font> has been changed more recently than <font class="bashcommand">FILE2</font>, or if <font class="bashcommand">FILE1</font> exists and <font class="bashcommand">FILE2</font> does not.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ FILE1 -ot FILE2 ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE1</font> is older than <font class="bashcommand">FILE2</font>, or is <font class="bashcommand">FILE2</font> exists and <font class="bashcommand">FILE1</font> does not.</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ FILE1 -ef FILE2 ]</font>
							</td>
							<td>Tests if <font class="bashcommand">FILE1</font> and <font class="bashcommand">FILE2</font> refer to the same device and inode numbers.</td>
						</tr>
					</table>
					
				<p>
					In the following section you will not find examples of the following flags because they are related to user permissions, a topic that has not been explained yet and will be explained in future chapters, or because they are less common. However, the use of these flags is the same as the ones explained below. 
				</p>
				
				<p>
					<font class="example">[ -a FILE ]:</font>
					<font class="bashcommand">
						$ FILE=/Users/MyUser/Desktop/someFile.txt<br>
						$ if [ -a "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "${FILE} exists"<br>
						&gt; else<br>
						&gt; echo "${FILE} doesn't exist"<br>
						&gt; fi 
					</font>
				</p>
				
				<p>
					<font class="bashcommand">
						$ if [ -a "/Users/MyUser/Desktop/someFile.txt" ]<br>
						&gt; then<br>
						&gt; echo "The file exists"<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist"<br>
						&gt; fi 
					</font>
				</p>
				
				<p>
					The following example shows a common mistake. Here, the quotation marks surrounding the file path are missing. Since the path has spaces, bash gives an error: 
				</p>
				
				<p>
					<font class="bashcommand">
						$ if [ -a /Users/MyUser/Desktop/some file name with spaces.txt ]<br>
						&gt; then<br>
						&gt; echo "The file exists"<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist"<br>
						&gt; fi<br>
						<font class="bashcommand-result">-bash: [: too many argument</font>
					</font>
				</p>
				
				<p>
					<font class="example">[ -d FILE ]:</font>
					<font class="bashcommand">
						$ FILE=/Users/MyUser/Desktop/someFile.txt<br>
						$ if [ -a "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "The file exists. Now I will find out if it's a directory or a regular file."<br>
						&gt; if [ -d "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "It is a directory."<br>
						&gt; else<br>
						&gt; echo "It is a regular file."<br>
						&gt; fi<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist."<br>
						&gt; fi
					</font>
				</p>
				
				<p>
					The following example shows a common mistake. Here, the spaces before and after the expression (<font class="bashcommand">-a "${FILE}"</font>) are missing. So, bash will give an error: 
				</p>
				
				<p>
					<font class="bashcommand">
						$ FILE=/Users/MyUser/Desktop/someFile.txt<br>
						$ if [-a "${FILE}"]<br>
						&gt; then<br>
						&gt; echo "The file exists. Now I will find out if it's a directory or a regular file."<br>
						&gt; if [ -d "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "It is a directory."<br>
						&gt; else<br>
						&gt; echo "It is a regular file."<br>
						&gt; fi<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist."<br>
						&gt; fi<br>
						<font class="bashcommand-result">-bash: [-a: command not found</font>
					</font>
				</p>
				
				<p>
					<font class="example">[ -f FILE ]:</font>
					<font class="bashcommand">
						$ FILE=/Users/MyUser/Desktop/someFile.txt<br>
						$ if [ -a "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "The file exists. Now I will find out if it's a directory or a regular file."<br>
						&gt; if [ -f "${FILE}" ]<br>
						&gt; then<br>
						&gt; echo "It is a regular file."<br>
						&gt; else<br>
						&gt; echo "It is a directory."<br>
						&gt; fi<br>
						&gt; else<br>
						&gt; echo "The file doesn't exist."<br>
						&gt; fi
					</font>
				</p>
				
				<p>
					<font class="example">[ -N FILE ]:</font>
					<font class="bashcommand">
						$ if [ -N "/Users/MyUser/Desktop/someFile.txt" ]<br>
						&gt; then<br>
						&gt; echo "The file exists and has been modified since the last time it was opened."<br>
						&gt; else<br>
						&gt; echo "Either the file doesn't exist, or it hasn't been modified."<br>
						&gt; fi 
					</font>
				</p>
				
				<h3>6.2. Condition-testing to compare/evaluate strings</h3>
					<p>
						When comparing strings, it is mandatory to use the quotation marks. The spaces after <font class="bashcommand">[</font> and before <font class="bashcommand">]</font> are very important. If those spaces are missing, bash will give an error. 
					</p>
					
					<table>
						<tr>
							<th style="width:30%"><b>Condition</b></th>
							<th style="width:70%"><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -z "STRING" ]</font>
							</td>
							<td>Tests if the length of <font class="bashcommand">STRING</font> is zero</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ -n "STRING" ]</font>
							</td>
							<td>Tests if the length of <font class="bashcommand">STRING</font> is non-zero</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" == "STRING2" ]</font>
							</td>
							<td>Tests if the strings are equal</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" != "STRING2" ]</font>
							</td>
							<td>Tests if the strings are not equal</td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" \< "STRING2" ]</font>
							</td>
							<td>Tests if <font class="bashcommand">STRING1</font> sorts before <font class="bashcommand">STRING2</font></td>
						</tr>
						
						<tr>
							<td>
								<font class="bashcommand">[ "STRING1" \> "STRING2" ]</font>
							</td>
							<td>Tests if <font class="bashcommand">STRING1</font> sorts after <font class="bashcommand">STRING2</font></td>
						</tr>
					</table>
					
					<p>
						<font class="example">[ -z "STRING" ]:</font>
						<font class="bashcommand">
							$ if [ -z "" ]<br>
							&gt; then<br>
							&gt; echo "Empty string"<br>
							&gt; fi<br>
							<font class="bashcommand-result">Empty string</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ -n "STRING" ]:</font>
						<font class="bashcommand">
							$ VAR="Some text"<br>
							$ if [ -n "${VAR}" ]<br>
							&gt; then<br>
							&gt; echo "The string is not empty"<br>
							&gt; fi<br>
							<font class="bashcommand-result">The string is not empty</font> 
						</font>
					</p>
					
					<p>In this example, bash will show an error because I forgot to put the quotation marks around <font class="bashcommand">${VAR}</font>.</p>
					
					<p>
						<font class="bashcommand">
							$ VAR="Some text"<br>
							$ if [ -n ${VAR} ]<br>
							&gt; then<br>
							&gt; echo "The string is not empty"<br>
							&gt; fi<br>
							<font class="bashcommand-result">-bash: [: Some: binary operator expected</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ "STRING1" == "STRING2" ]:</font>
						<font class="bashcommand">
							$ QC="Good"<br>
							$ if [ "${QC}" == "Good" ]<br>
							&gt; then<br>
							&gt; echo "Quality control good"<br>
							&gt; else<br>
							&gt; echo "Image has bad quality"<br>
							&gt; fi<br>
							<font class="bashcommand-result">Quality control good</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ "STRING1" != "STRING2" ]:</font>
						<font class="bashcommand">
							$ QC="Good"<br>
							$ if [ "${QC}" != "Good" ]<br>
							&gt; then<br>
							&gt; echo "Quality control is not good"<br>
							&gt; else<br>
							&gt; echo "Image has good quality"<br>
							&gt; fi<br>
							<font class="bashcommand-result">Image has good quality</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ "STRING1" \< "STRING2" ]:</font>
						In the following example, I am comparing the strings <font class="bashcommand">"Canada"</font> with <font class="bashcommand">"Colombia"</font> and printing the one that sorts first. <font class="bashcommand">"Canada"</font> will be printed because the first letter of both words is the same but the second letter in <font class="bashcommand">"Canada"</font> (letter <font class="bashcommand">a</font>) comes before the second letter in <font class="bashcommand">"Colombia"</font> (letter <font class="bashcommand">o</font>).<br>
						<font class="bashcommand">
							$ VAR1="Canada"<br>
							$ VAR2="Colombia"<br>
							$ if [ "${VAR1}" \< "${VAR2}" ]<br>
							&gt; then<br>
							&gt; echo ${VAR1}<br>
							&gt; else<br>
							&gt; echo ${VAR2}<br>
							&gt; fi<br>
							<font class="bashcommand-result">Canada</font>
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${VAR1}" \< "${VAR2}" ] &gt;&gt; echo ${VAR1} || echo ${VAR2}<br>
							<font class="bashcommand-result">Canada</font>
						</font>	
					</p>
					
					<p>
						<font class="example">[ "STRING1" \> "STRING2" ]:</font>
						<font class="bashcommand">
							$ VAR1="Canada"<br> 
							$ VAR2="Colombia"<br>
							$ if [ "${VAR1}" \> "${VAR2}" ]<br>
							&gt; then<br>
							&gt; echo ${VAR2}<br>
							&gt; else<br>
							&gt; echo ${VAR1}<br>
							&gt; fi<br>
							<font class="bashcommand-result">Canada</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${VAR1}" \> "${VAR2}" ] &gt;&gt; echo ${VAR2} || echo ${VAR1}<br>
							<font class="bashcommand-result">Canada</font>
						</font>
					</p>
					
				<h3>6.3. Condition-testing to compare numbers</h3>
					<p>The spaces after <font class="bashcommand">[</font> and before <font class="bashcommand">]</font> are very important. If those spaces are missing, bash will give an error.</p>
					<table>
						<tr>
							<th><b>Condition</b></th>
							<th><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -eq NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is equal to <font class="bashcommand">NUM2</font></td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -ne NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is not equal to <font class="bashcommand">NUM2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -lt NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is less than <font class="bashcommand">NUM2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -le NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is less than or equal to <font class="bashcommand">NUM2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -gt NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is greater than <font class="bashcommand">NUM2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ NUM1 -ge NUM2 ]</font></td>
							<td>Tests if <font class="bashcommand">NUM1</font> is greater than or equal to <font class="bashcommand">NUM2</font>.</td>
						</tr>
					</table>
					
					<p>
						<font class="example">[ NUM1 -eq NUM2 ]:</font>
						<font class="bashcommand">
							$ if [ 3 -eq 3 ]<br>
							&gt; then<br>		
							&gt; echo "This makes sense, 3 equals 3."<br>					
							&gt; fi<br>			
							<font class="bashcommand-result">This makes sense, 3 equals 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ 3 -eq 3 ] &gt;&gt; echo "This makes sense, 3 equals 3."<br>
							<font class="bashcommand-result">This makes sense, 3 equals 3.</font>
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -eq "3" ]<br>
							&gt; then<br> 
							&gt; echo "This makes sense, ${A} equals 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This makes sense, 3 equals 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -eq "3" ] &gt;&gt; echo "This makes sense, ${A} equals 3."<br>
							<font class="bashcommand-result">This makes sense, 3 equals 3.</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ NUM1 -ne NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -ne "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is not equal to 3"<br> 
							&gt; else<br>
							&gt; echo "Variable A equals 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A equals 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -ne "3" ] &gt;&gt; echo "Variable A is not equal to 3" || echo "Variable A equals 3."<br>
							<font class="bashcommand-result">Variable A equals 3.</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ NUM1 -lt NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -lt "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is less than 3"<br> 
							&gt; else<br>
							&gt; echo "Variable A not less than 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A is not less than 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -lt "3" ] &gt;&gt; echo "Variable A is less than 3" || echo "Variable A not less than 3."<br>
							<font class="bashcommand-result">Variable A is not less than 3.</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ NUM1 -le NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br> 
							$ if [ "${A}" -le "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is less or equal to 3"<br>
							&gt; else<br>
							&gt; echo "Variable A greater than 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A is less or equal to 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -le "3" ] &gt;&gt; echo "Variable A is less or equal to 3" || echo "Variable A greater than 3."<br>
							<font class="bashcommand-result">Variable A is less or equal to 3.</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ NUM1 -gt NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -gt "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is greater than 3."<br>
							&gt; else<br>
							&gt; echo "Variable A not greater than 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A is not greater than 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -gt "3" ] &gt;&gt; echo "Variable A is greater than 3." || echo "Variable A not greater than 3."<br>
							<font class="bashcommand-result">Variable A is not greater than 3.</font>
						</font>	
					</p>
					
					<p>
						<font class="example">[ NUM1 -ge NUM2 ]:</font>
						<font class="bashcommand">
							$ A=3<br>
							$ if [ "${A}" -ge "3" ]<br>
							&gt; then<br>
							&gt; echo "Variable A is greater or equal to 3"<br>
							&gt; else<br>
							&gt; echo "Variable A less than 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">Variable A is greater or equal to 3.</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${A}" -ge "3" ] &gt;&gt; echo "Variable A is greater or equal to 3" || echo "Variable A less than 3."<br>
							<font class="bashcommand-result">Variable A is greater or equal to 3.</font>
						</font>
					</p>
					
				<h3>6.4. Condition-testing to compare arrays</h3>
					<table>
						<tr>
							<th><b>Condition</b></th>
							<th><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ "${array1[*]}" == "${array2[*]}" ]</font></td>
							<td>Tests if <font class="bashcommand">array1</font> equals to <font class="bashcommand">array2</font>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ "${array1[*]}" != "${array2[*]}" ]</font></td>
							<td>Tests if array1 is different to array2.</td>
						</tr>
					</table>
					
					<p>
						<font class="example">[ "${array1[*]}" == "${array2[*]}" ]:</font>
						<font class="bashcommand">
							$ arr1=(a b c)<br>
							$ arr2=(a b c d)<br>
							$ arr3=(a b c)<br>
							$ if [ "${arr1[*]}" == "${arr3[*]}" ]<br>
							&gt; then<br>
							&gt; echo "equal"<br>
							&gt; else<br>
							&gt; echo "different"<br>
							&gt; fi<br>
							<font class="bashcommand-result">equal</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${arr1[*]}" == "${arr3[*]}" ] &gt;&gt; echo "equal" || echo "different"<br>
							<font class="bashcommand-result">equal</font>
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ "${arr1[*]}" == "${arr2[*]}" ]<br>
							&gt; then<br>
							&gt; echo "equal"<br>
							&gt; else<br>
							&gt; echo "different"<br>
							&gt; fi<br>
							<font class="bashcommand-result">different</font>
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${arr1[*]}" == "${arr2[*]}" ] &gt;&gt; echo "equal" || echo "different"<br>
							<font class="bashcommand-result">different</font>
						</font>
					</p>
					
					<p>
						<font class="example">[ "${arr1[*]}" != "${arr2[*]}" ]:</font>
						<font class="bashcommand">
							$ if [ "${arr1[*]}" != "${arr2[*]}" ]<br>
							&gt; then<br>
							&gt; echo "different"<br>
							&gt; else<br>
							&gt; echo "equal"<br>
							&gt; fi<br>
							<font class="bashcommand-result">different</font> 
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ "${arr1[*]}" != "${arr2[*]}" ] &gt;&gt; echo "different" || echo "equal"<br>
							<font class="bashcommand-result">different</font>
						</font>
					</p>
					
					<h3>6.5. Combining different expressions for condition-testing</h3>
					<table>
						<tr>
							<th><b>Condition</b></th>
							<th><b>Meaning</b></th>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ EXPR ]</font></td>
							<td>Tests if the expression <font class="bashcommand">EXPR</font> is <b>true</b>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ ! EXPR ]</font></td>
							<td>Tests if the expression <font class="bashcommand">EXPR</font> is <b>false</b>.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ EXPR1 ] || [ EXPR2 ]</font></td>
							<td>Tests if <font class="bashcommand">EXPR1</font> <b>or</b> <font class="bashcommand">EXPR2</font> are true. You can add as many expressions as desired.</td>
						</tr>
						
						<tr>
							<td><font class="bashcommand">[ EXPR1 ] &amp;&amp; [ EXPR2 ]</font></td>
							<td>Tests if <font class="bashcommand">EXPR1</font> <b>and</b> <font class="bashcommand">EXPR2</font> are true. You can add as many expressions as desired.</td>
						</tr>
					</table>
					
					<p>
						<font class="example">[ EXPR ] vs [ ! EXPR ]</font>
						<font class="bashcommand">
							$ if [ 3 -eq 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be printed if the expression 3 equals 3 is true."<br>
							&gt; else<br>
							&gt; echo "This will be printed if the expression is false (3 is not equal to 3)."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be printed if the expression 3 equals 3 is true.</font>
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ 3 -eq 3 ] &gt;&gt;  echo "This will be printed if the expression 3 equals 3 is true." || echo "This will be printed if the expression is false (3 is not equal to 3)."<br>
							<font class="bashcommand-result">This will be printed if the expression 3 equals 3 is true.</font>
						</font>
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ ! 3 -eq 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be printed if it is false that 3 equals 3 (so, if 3 is different than 3)."<br>
							&gt; else<br>
							&gt; echo "This will be printed if it is not false (it's true) that 3 equals 3."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be printed if it is not false (it's true) that 3 equals 3.</font>
						</font>
					</p>
					
					<p>
						The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
						<font class="bashcommand">
							$ [ ! 3 -eq 3 ] &gt;&gt; echo "This will be printed if it is false that 3 equals 3 (so, if 3 is different than 3)." || echo "This will be printed if it is not false (it's true) that 3 equals 3."<br>
							<font class="bashcommand-result">This will be printed if it is not false (it's true) that 3 equals 3.</font>
						</font>
					</p>
					
					<p>We learned that the expression <font class="bashcommand">-f FILE</font> tests if a file exists. If we want to test if a file doesn't exist, then we just need to test if <font class="bashcommand">-f FILE</font> is false.</p>

					<font class="bashcommand">
						<p>
							$ FILE="SomeFileThatExists.txt"<br>
							$ if [ -f ${FILE} ]<br>
							&gt; then<br>
							&gt; echo "The file exist"<br>
							&gt; fi <br>
							<font class="bashcommand-result">The file exist</font>
						</p>
						
						<p>
							The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
							<font class="bashcommand">$ [ -f ${FILE} ] &gt;&gt; echo "The file exist"</font><br>
							<font class="bashcommand-result">The file exist</font>
						</p>
						
						<p>
							$ FILE="SomeFileThatDoesntExist.txt"<br>
							$ if [ ! -f ${FILE} ]<br>
							&gt; then<br>
							&gt; echo "The file doesn't exist"<br>
							&gt; fi<br>
							<font class="bashcommand-result">The file doesn't exist</font>
						</p>
						
						<p>
							The previous expression can be written using a shorter syntax: [ expression ] &gt;&gt; what_to_do_if_expression_is_true || what_to_do_if_expression_is_false:<br>
							<font class="bashcommand">$ [ ! -f ${FILE} ] &gt;&gt; echo "The file doesn't exist"</font><br>
							<font class="bashcommand-result">The file doesn't exist</font>
						</p>
					</font>
					
					<p>
						<font class="example">[ EXPR1 ] || [ EXPR2 ]:</font>
						Test if any of the two expressions are true.
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ 2 -lt 3 ] || [ 4 -lt 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be echoed if any of the two expressions are true: 2&lt;3 OR 4&lt;3."<br>
							&gt; else<br>
							&gt; echo "This will be echoed if none of the two expressions are true"<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be echoed if any of the two expressions are true: 2&lt;3 OR 4&lt;3.</font> 
						</font>
					</p>
					
					<p>The previous example can also be written using a shorter syntax. When using multiple expressions, they will have to be encapsulated in parentheses using the following syntax: ( expressions ) &amp;&amp; what_to_do_if_true || what_to_do_if_false</p>
					
					<p>
						Shorter version:<br>
						<font class="bashcommand">
							$ ( [ 2 -lt 3 ] || [ 4 -lt 3 ] ) &amp;&amp; echo "This will be echoed if any of the two expressions are true: 2&lt;3 OR 4&lt;3." || echo "This will be echoed if none of the two expressions are true":<br>
							<font class="bashcommand-result">This will be echoed if any of the two expressions are true: 2&lt;3 OR 4&lt;3.</font> 
						</font>
					</p>
					
					<p>
						<font class="example">[ EXPR1 ] &amp;&amp; [ EXPR2 ]:</font>
						Test if the two expressions are true. The second expression, contrary to the previous example, has the negation (<font class="bashcommand">!</font>). So, the second expression is not testing if 4 is less than 3, it is testing if 4 is <b>NOT</b> less than 3. So, both of the expressions are true, because 4 is not less than 3, and 2 is less than 3. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be echoed if the two expressions are true."<br>
							&gt; else<br>
							&gt; echo "This will be echoed if one of the two expressions are false, or if both are false."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be echoed if the two expressions are true.</font> 
						</font>
					</p>
					
					<p>The previous example can also be written using a shorter syntax. Remember that when using multiple expressions, they will have to be encapsulated in parentheses using the following syntax: ( expressions ) &amp;&amp; what_to_do_if_true || what_to_do_if_false</p>
					
					<p>
						This is the shorter version:<br>
						<font class="bashcommand">
							$ ( [ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ] ) &amp;&amp; echo "This will be echoed if the two expressions are true." || echo "This will be echoed if one of the two expressions are false, or if both are false."<br>
							<font class="bashcommand-result">This will be echoed if the two expressions are true.</font> 
						</font>
					</p>
					
					<font class="example">Using the and (&amp;&amp;) and or (||) operands to test more than two conditions:</font>
					
					<p>
						Using &amp;&amp; to test more than two conditions:<br>
						You can combine more than two expressions. In the following example I am combining three. Because I am using the <b>AND</b> operator, the whole condition will test true <b>if and only if</b> all the three expressions are true. If one is false, then the whole expression will be false.  
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ] &amp;&amp; [ 4 -lt 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be echoed if all the three expressions are true."<br>
							&gt; else<br>
							&gt; echo "This will be echoed if any of the three expressions is false."<br> 
							&gt; fi<br>
							<font class="bashcommand-result">This will be echoed if any of the three expressions is false.</font> 
						</font>
					</p>
					
					<p>
						Let's take a look at why the whole expression evaluates false:<br>
						<font class="bashcommand">[ 2 -lt 3 ]</font>: This is true, 2 &lt; 3.<br>
						<font class="bashcommand">[ ! 4 -lt 3 ]</font>: This is true, 4 is not less than 3.<br> 
						<font class="bashcommand">[ 4 -lt 3 ]</font>: This is false, It is false that 4 be less than 3.<br>
						<font class="bashcommand">[ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ] &amp;&amp; [ 4 -lt 3 ]</font>: This is false because one of the three expressions is false. 
					</p>
					
					<p>The previous example can also be written using a shorter syntax. Remember that when using multiple expressions, they will have to be encapsulated in parentheses using the following syntax: ( expressions ) &amp;&amp; what_to_do_if_true || what_to_do_if_false</p>
					
					<p>
						This is the shorter version:</br>
						<font class="bashcommand">
							$ ( [ 2 -lt 3 ] &amp;&amp; [ ! 4 -lt 3 ] &amp;&amp; [ 4 -lt 3 ] ) &amp;&amp; echo "This will be echoed if all the three expressions are true." || echo "This will be echoed if any of the three expressions is false."<br>
							<font class="bashcommand-result">This will be echoed if any of the three expressions is false.</font> 
						</font>
					</p>
					
					<p>
						Using <font class="bashcommand">||</font> to test more than two conditions:<br>
						This example is very similar than the previous one but instead of using the operator AND (<font class="bashcommand">&gt;&gt;</font>)), we are using the operator OR (<font class="bashcommand">||</font>). So, the whole expression will be true if ANY of the three expressions is true. Since the first two are true, then the result is true. 
					</p>
					
					<p>
						<font class="bashcommand">
							$ if [ 2 -lt 3 ] || [ ! 4 -lt 3 ] || [ 4 -lt 3 ]<br>
							&gt; then<br>
							&gt; echo "This will be echoed if ANY of the three expressions is true."<br>
							&gt; else<br>
							&gt; echo "This will be echoed if all of the three expressions are false."<br>
							&gt; fi<br>
							<font class="bashcommand-result">This will be echoed if ANY of the three expressions is true.</font>
						</font>
					</p>
					
					<p>The previous example can also be written using a shorter syntax. Remember that when using multiple expressions, they will have to be encapsulated in parentheses using the following syntax: ( expressions ) &amp;&amp; what_to_do_if_true || what_to_do_if_false</p>
					
					<p>
						This is the shorter version:<br>
						<font class="bashcommand">
							$ ( [ 2 -lt 3 ] || [ ! 4 -lt 3 ] || [ 4 -lt 3 ] ) &amp;&amp; echo "This will be echoed if ANY of the three expressions is true." || echo "This will be echoed if all of the three expressions are false."<br>
							<font class="bashcommand-result">This will be echoed if ANY of the three expressions is true.</font>
						</font>
					</p>
					
					<p>
						<font class="example">Combining &amp;&amp; and || into one expression:</font>
						When combining both operands (&amp;&amp;, ||), it is better to always use parenthesis to indicate the order in which you want the operations to be evaluated. In the following example we have three files. The path of the three files are saved in the variables <font class="bashcommand">${FILE1} ${FILE2}</font> and <font class="bashcommand">${FILE3}</font>. Files <font class="bashcommand">${FILE1}</font> and <font class="bashcommand">${FILE3}</font> exist, but <font class="bashcommand">${FILE2}</font> doesn't exist. We want to evaluate the following condition: Does <font class="bashcommand">${FILE3}</font> and one of the other two files exists?
					</p>
					
					<p>
						<font class="bashcommand">[ -f ${FILE3} ]</font> This condition is true because <font class="bashcommand">${FILE3}</font> exists.<br> 
						<font class="bashcommand">[ -f ${FILE2} ] || [ -f ${FILE1} ]</font> This condition is true because even though <font class="bashcommand">${FILE2}</font> doesn't exist, <font class="bashcommand">${FILE1}</font> does exist. And with an <font class="bashcommand">OR</font> (<font class="bashcommand">||</font>) we only need one of the expressions to be true.<br> 
						<font class="bashcommand">( [ -f ${FILE1} ] || [ -f ${FILE2} ] ) &amp;&amp; [ -f ${FILE3} ]</font> This is true because both of expressions are true.
					</p>
					
					<p>
						<font class="bashcommand">
						$ if ( [ -f ${FILE1} ] || [ -f ${FILE2} ] ) &amp;&amp; [ -f ${FILE3} ]<br>
						&gt; then<br>
						&gt; echo "The condition is true"<br>
						&gt; else<br>
						&gt; echo "The condition is false"<br>
						&gt; fi<br>
						<font class="bashcommand-result">The condition is true</font>
						</font>
					</p>
					
					<p>
						This is the shorter version for the previous command:<br>
						<font class="bashcommand">
						( [ -f ${FILE1} ] || [ -f ${FILE2} ] ) &amp;&amp; [ -f ${FILE3} ] &amp;&amp; echo "The condition is true" || echo "The condition is false"
						</font>
					</p>
					
					<p>In the following example, we want to include a subject if it is female and age less than six or male and age greater than ten. </p>
					
					<p>
						<font class="bashcommand">
							$ GENDER="MALE"<br>
							$ AGE=23<br>
							$ if ( [ "${GENDER}" == "FEMALE" ] && [ "${AGE}" -lt "6" ] ) || ( [ "${GENDER}" == "MALE" ] && [ "${AGE}" -gt "10" ] )<br>
							&gt; then<br>
							&gt; echo "Include subject"<br>
							&gt; else<br>
							&gt; echo "Exclude subject"<br>
							&gt; fi<br>
							<font class="bashcommand-result">Include subject</font>
						</font>
					</p>
    </body>
</html>
